<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>命令 | ALTNT's Hexo Blog</title><meta name="author" content="ALTNT"><meta name="copyright" content="ALTNT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hexo命令clean: 1hexo clean  生成网页 1hexo g  部署: 1hexo d  在本机上部署 1hexo s   docker 命令:创建macvlan网络 为了能够让docker启动的容器作为家庭网络中的旁路由，因此需要创建macvlan网络。 其中 192.168.3.1为你局域网的网关，em1为你机器的网卡名称，这两个请根据实际情况修改。  （可选）让docker监">
<meta property="og:type" content="article">
<meta property="og:title" content="命令">
<meta property="og:url" content="http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="ALTNT&#39;s Hexo Blog">
<meta property="og:description" content="hexo命令clean: 1hexo clean  生成网页 1hexo g  部署: 1hexo d  在本机上部署 1hexo s   docker 命令:创建macvlan网络 为了能够让docker启动的容器作为家庭网络中的旁路由，因此需要创建macvlan网络。 其中 192.168.3.1为你局域网的网关，em1为你机器的网卡名称，这两个请根据实际情况修改。  （可选）让docker监">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://blog.705553939.xyz/img/altnt.jpeg">
<meta property="article:published_time" content="2024-06-22T03:44:40.000Z">
<meta property="article:modified_time" content="2024-06-22T04:06:38.000Z">
<meta property="article:author" content="ALTNT">
<meta property="article:tag" content="资料">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.705553939.xyz/img/altnt.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '命令',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-22 12:06:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/altnt.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ALTNT's Hexo Blog"><span class="site-name">ALTNT's Hexo Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-22T03:44:40.000Z" title="Created 2024-06-22 11:44:40">2024-06-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-22T04:06:38.000Z" title="Updated 2024-06-22 12:06:38">2024-06-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="命令"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><p>clean:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>生成网页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>部署:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>在本机上部署</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>


<h2 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令:"></a>docker 命令:</h2><h3 id="创建macvlan网络"><a href="#创建macvlan网络" class="headerlink" title="创建macvlan网络"></a>创建macvlan网络</h3><p><a target="_blank" rel="noopener" href="https://github.com/ALTNT/clashindocker#%E5%88%9B%E5%BB%BAmacvlan%E7%BD%91%E7%BB%9C"></a></p>
<p>为了能够让docker启动的容器作为家庭网络中的旁路由，因此需要创建macvlan网络。 其中 <code>192.168.3.1</code>为你局域网的网关，<code>em1</code>为你机器的网卡名称，这两个请根据实际情况修改。</p>
<ol>
<li>（可选）让docker监听ipv6。 编辑etc&#x2F;docker&#x2F;daemon.json文件</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">      <span class="attr">&quot;ipv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;fixed-cidr-v6&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2409:DA8:8001:7B22:200::/80&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建macvlan 没有ipv6的版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan \  </span><br><span class="line">     --subnet=192.168.3.0/24 \  </span><br><span class="line">     --gateway=192.168.3.1 \  </span><br><span class="line">      -o parent=em1 \  </span><br><span class="line">      -o macvlan_mode=bridge macnet</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>有ipv6的版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --ipv6 \  </span><br><span class="line">    --subnet=192.168.3.0/24 \  </span><br><span class="line">    --gateway=192.168.3.1 \  </span><br><span class="line">    --subnet=2409:DA8:8001:7B22:200::/80 </span><br><span class="line">    --gateway=2409:DA8:8001:7B22:200::1 \  </span><br><span class="line">     -o parent=em1 \  </span><br><span class="line">     -o macvlan_mode=bridge macnet</span><br></pre></td></tr></table></figure>

<p>注意看含义，有的值需要变</p>
<p>查看网络:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<h3 id="制作docker镜像并创建容器"><a href="#制作docker镜像并创建容器" class="headerlink" title="制作docker镜像并创建容器"></a>制作docker镜像并创建容器</h3><p><a target="_blank" rel="noopener" href="https://github.com/ALTNT/clashindocker#%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"></a></p>
<ol>
<li>获取代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/UntaggedRui/clashindocker</span><br><span class="line">cd clashindocker</span><br><span class="line">cp example.yml config.yml</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更改地址 <code>docker-compose.yml</code>中的 <code>ipv4_address</code>为你的ip地址.</li>
<li>更改 <code>config.yml</code>中的 <code>proxy-provider</code>的 <code>url</code>为你的机场订阅地址.</li>
<li>启动容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="光盘刻录："><a href="#光盘刻录：" class="headerlink" title="光盘刻录："></a>光盘刻录：</h2><p>过程：<br>开始刻录-&gt;卸载光盘-&gt;读取光盘内分段数据-&gt;数据打包-&gt;刻录。<br>系统刻录光盘日志<br>~&#x2F;.cache&#x2F;deepin&#x2F;discburn&#x2F;uburn&#x2F;xxxx&#x2F;log</p>
<p>xorriso -dev &#x2F;dev&#x2F;sr0 -map &#x2F;src&#x2F; &#x2F;dest&#x2F; -volid 卷标 -close off -commit -eject</p>
<h2 id="时区设置："><a href="#时区设置：" class="headerlink" title="时区设置："></a>时区设置：</h2><p>date -R  #查看当期时区<br>tzselect #设置时区<br>systemd-timeryncd.service服务的配置文件位于“&#x2F;etc&#x2F;systemd”路径下，文件名称为“timesyncd.conf”，可以设置ntp服务器(deepin有 &#x2F;etc&#x2F;systemd&#x2F;timesyncd.conf.d&#x2F;deepin.conf如果某个Linux发行版和deepin一样具有&#x2F;etc&#x2F;systemd&#x2F;system.d&#x2F;timesyncd.conf文件夹，那么systemd-timesyncd.service服务将优先选择这个文件夹下的.conf文件作为自己的优先配置文件，而原有的&#x2F;etc&#x2F;systemd&#x2F;timesyncd.conf将作为备用的配置文件，优先级相对较低。<br>4.3、典型故障——无论怎样修改时区，Linux系统始终都显示零区的格林尼治时间<br>出现这样的情况一般是因为&#x2F;usr&#x2F;share&#x2F;zoneinfo目录遭到严重破坏造成的，针对这样的故障，最简单粗暴的方式就是将找到一套同版本、正常运行的Linux发行版，将其&#x2F;usr&#x2F;share&#x2F;zoneinfo目录复制出来，对故障Linux系统的相关目录进行替换。</p>
<p>4.4、典型故障——安全软件在启动时强制打开操作系统时间同步功能，后因安全软件服务端时间错误导致时钟错误同步<br>在信创领域，Linux杀毒软件经常被安装在Linux电脑上，用于病毒查杀和违规外联等功能。而主流的Linux杀毒软件都具有审计功能，审计会产生大量的日志纪录，这些纪录需要有一个时间对应，因此这些杀毒软件的服务端会自带时钟同步，并且会在Linux终端启动完成后强制打开和配置操作系统的时钟同步功能，如果杀毒软件服务端的本地时间时错误的，或者说同一个局域网内有多个存在一定时间差的NTP服务器，将可能会对Linux终端带来时间上的错误。</p>
<p>sudo trace-bpfcc -tUK __alloc_pages_nodemask</p>
<p>systemctl set-property name parameter&#x3D;value</p>
<p>pactl list short modules<br>pacmd list-modules</p>
<p>设置systemdlog_level: &#x2F;etc&#x2F;systemd&#x2F;daemon.log</p>
<p>查看进程的fd:<br>ls -l &#x2F;proc&#x2F;xxx&#x2F;fd</p>
<p>1、通过以下步骤进行测试：<br>        (1)执行 mv &#x2F;usr&#x2F;bin&#x2F;pulseaudio &#x2F;usr&#x2F;bin&#x2F;pulseaudiobak, 重启让pulseaudio无法自启动<br>        (2)命令行 执行 arecord -Dhw:0,1 -d 10 -f cd -t wav test.wav通过alsa进行录音（hw:0,1为指定录音的设备，arecord命令的使用可以参考网上资料）<br>        (3) 将生成的test.wav用audacity软件进行播放，查看是否有杂音。<br>    此时依旧有杂音，基本可以确定是送上来的数据流有问题（中间音频驱动和alsa编解码的过程因为编解码过程都比较完善，一般不会出现问题）<br>2、此问题从现象上看就是将录制的音量提高到50%的时候，通过alsamixer查看此时Internal Mic boost开始有增强效果，导致噪音被放大。此问题在软件方面只能通过修改配置文件将Internal Mic boost设置为ignore来取消增强效果来减缓此问题，要根本解决还需要厂商进行适配。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiongtiancheng/article/details/80577478">https://blog.csdn.net/xiongtiancheng/article/details/80577478</a></p>
<h2 id="查看谁执行了某条命令"><a href="#查看谁执行了某条命令" class="headerlink" title="查看谁执行了某条命令:"></a>查看谁执行了某条命令:</h2><p>重现bug，然后检查日志，sudo journalctl -b0 |grep SYSCALL 能看到有 date 命令调用 syscall 112 号 设置了系统时间。</p>
<p>sudo mv &#x2F;usr&#x2F;bin&#x2F;date &#x2F;usr&#x2F;bin&#x2F;date.real</p>
<p>编写文件 &#x2F;usr&#x2F;bin&#x2F;date</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">echo &gt;&gt; /tmp/log</span><br><span class="line">pstree -p -A -l &gt;&gt; /tmp/log</span><br><span class="line">echo pid: $$ &gt;&gt; /tmp/log</span><br><span class="line">echo args: $@ &gt;&gt; /tmp/log</span><br><span class="line">logger -f /tmp/log</span><br><span class="line">/usr/bin/date.real &quot;$@&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行命令 sudo chmod +x &#x2F;usr&#x2F;bin&#x2F;date</p>
<p>然后按照步骤重现bug，然后立即查看 &#x2F;tmp&#x2F;log 文件的内容。</p>
<p>比如看到文件底部有 pid: 12345, 然后去本文件上方找到 12345，看它的父进程是什么，我看到了一个父进程 AlarmThread，pid 为 3203。</p>
<p>然后切换到 root 用户，执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd /proc/3202</span><br><span class="line"></span><br><span class="line">cat comm</span><br><span class="line"></span><br><span class="line">readlink -f exe</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到结果是 AlarmThread 和 &#x2F;opt&#x2F;apps&#x2F;cn.com.topsec.topdesk&#x2F;files&#x2F;bin&#x2F;TDATX0，这就说明了是 cn.com.topsec.topdesk 软件包里的程序调用了 date 命令设置了时间。</p>
<h2 id="quilt配置："><a href="#quilt配置：" class="headerlink" title="quilt配置："></a>quilt配置：</h2><p>for where in .&#x2F; ..&#x2F; ..&#x2F;..&#x2F; ..&#x2F;..&#x2F;..&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F; ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;; do<br>    if [ -e ${where}debian&#x2F;rules -a -d ${where}debian&#x2F;patches ]; then<br>        export QUILT_PATCHES&#x3D;debian&#x2F;patches<br>        break<br>    fi<br>done</p>
<h2 id="wpa-cli"><a href="#wpa-cli" class="headerlink" title="wpa_cli:"></a>wpa_cli:</h2><p>wpa_cli -i wlan0<br>    scan<br>    scan_results<br>nmcli con show<br>nmcli dev wifi connect ASXXX<br>查看连接情况wpa_cli -i wlan0 scan_results | grep ASXXX</p>
<h2 id="查看电脑支不支持wpa："><a href="#查看电脑支不支持wpa：" class="headerlink" title="查看电脑支不支持wpa："></a>查看电脑支不支持wpa：</h2><p>gdb wpa 在这个函数里， wpa_supplicant_set_suites</p>
<p>然后p一下这个值。</p>
<p>wpa_s-&gt;drv_flags</p>
<p>gdb 他的电脑。</p>
<h2 id="删除已连接的网络："><a href="#删除已连接的网络：" class="headerlink" title="删除已连接的网络："></a>删除已连接的网络：</h2><p>rm &#x2F;etc&#x2F;NetworkManager&#x2F;systemd-connections&#x2F;***<br>systemctl restart network-manager.service</p>
<h2 id="跟踪signal-fd"><a href="#跟踪signal-fd" class="headerlink" title="跟踪signal_fd:"></a>跟踪signal_fd:</h2><p>sudo trace-bpfcc -tK ‘do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p) “sig&#x3D;%d,recv_pid&#x3D;%d,send_pid&#x3D;%d”, sig,p-&gt;pid,info-&gt;si_pid’</p>
<p>trace-bpfcc指定头文件：加-I</p>
<p>trace-bpfcc:<br>sudo trace-bpfcc -t ‘do_filp_open(int dfd, struct filename *pathname) “name&#x3D;%s”, pathname-&gt;name’  | grep “&#x2F;dev&#x2F;rtc”</p>
<p>sudo trace-bpfcc -tK ‘btrfs_mount_root(void* f, int flags, char* name) “flags&#x3D;0x%lx name&#x3D;%s”, flags, name’</p>
<p>sudo trace-bpfcc -t ‘group_send_sig_info(int sig, void *info, struct task_struct *p)”sig&#x3D;%d, task_pid&#x3D;%d, task_name&#x3D;%s”,sig, p-&gt;pid, p-&gt;comm’ &gt;&gt; 1.log</p>
<p>sudo dbus-monitor –system interface&#x3D;org.freedesktop.login1.Manager path&#x3D;&#x2F;org&#x2F;freedesktop&#x2F;login1</p>
<p> 316 trace-bpfcc -t ‘generic_file_direct_write(struct kiocb *iocb) “func&#x3D;0x%lx”, iocb-&gt;ki_filp-&gt;f_mapping-&gt;a_ops-&gt;direct_IO’ -p 28942</p>
<p>sudo trace-bpfcc -t ‘group_send_sig_info(int sig, void *info, struct task_struct *p)”sig&#x3D;%d, task_pid&#x3D;%d, task_name&#x3D;%s”,sig, p-&gt;pid, p-&gt;comm’ &gt;&gt; 1.log</p>
<h2 id="bpfcc在5-10内核上不可用解决"><a href="#bpfcc在5-10内核上不可用解决" class="headerlink" title="bpfcc在5.10内核上不可用解决:"></a>bpfcc在5.10内核上不可用解决:</h2><p>需要重新编译bcc，参考这个文档<br><a target="_blank" rel="noopener" href="https://github.com/realwujing/ebpf-learning/blob/1d4dc60cef79a16354520fbda4f44b7013275e47/BCC.md">https://github.com/realwujing/ebpf-learning/blob/1d4dc60cef79a16354520fbda4f44b7013275e47/BCC.md</a></p>
<p>1）安装依赖<br>sudo apt-get -y install bison build-essential cmake flex git libedit-dev<br>llvm-13-dev libclang-13-dev python zlib1g-dev libelf-dev libfl-dev python3-distutils</p>
<p>依赖里面 llvm-13-dev libclang-13-dev 没有，可以添加debian源，然后再下。<br>添加debian源方法：<br>cat &#x2F;etc&#x2F;debian_version 确定debian版本，10对应buster，百度搜索debian 清华源 ，选择buster</p>
<p>2）下载代码：<br>git clone <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc.git">https://github.com/iovisor/bcc.git</a><br>git checkout -b v0.6.1<br>3）编译：<br>在执行git clone的目录写一个脚本<br>#!&#x2F;bin&#x2F;bash<br>set -ex<br>mkdir bcc&#x2F;build<br>cd bcc&#x2F;build<br>cmake ..<br>make<br>sudo make install<br>cmake -DPYTHON_CMD&#x3D;python3 .. # build python3 binding<br>pushd src&#x2F;python&#x2F;<br>make<br>sudo make install<br>popd<br>然后执行<br>4）设置环境变量<br>需要先sudo -i<br>echo “export PATH&#x3D;$PATH:&#x2F;usr&#x2F;share&#x2F;bcc&#x2F;tools” &gt;&gt; &#x2F;etc&#x2F;profile<br>sudo visudo后追加&#x2F;usr&#x2F;share&#x2F;bcc&#x2F;tools到secure_path后面<br>source &#x2F;etc&#x2F;profile</p>
<p>5）修改python默认指向python3<br>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python2 100<br>sudo update-alternatives –install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3 150<br>sudo update-alternatives –config python</p>
<p>编译出来的程序是trace； 直接 sudo trace运行，有时候需要重启</p>
<h2 id="内核编译："><a href="#内核编译：" class="headerlink" title="内核编译："></a>内核编译：</h2><p>284  ls arch&#x2F;<br>  285  ls arch&#x2F;arm64&#x2F;configs&#x2F;<br>  286  make merge_kirin990_armpc_defconfig<br>  287  sudo apt install  bison<br>  288  make merge_kirin990_armpc_defconfig<br>  289  sudo apt install  flex<br>  290  make merge_kirin990_armpc_defconfig<br>  291  make menuconfig<br>  292  lscpu<br>  294  make bindeb-pkg -j10<br>编出来后安装linux-headerXXX.deb linux-image-xxx.deb</p>
<p>sudo apt install bison flex<br>cp &#x2F;boot&#x2F;config-4.19.0-amd64-desktop arch&#x2F;x86&#x2F;configs&#x2F;icbc_x86_defconfig<br>  make icbc_x86_defconfig<br>  make menuconfig  不需要<br>lscpu<br>vim scripts&#x2F;package&#x2F;Makefile 注释掉deepin-apigail-generate的2行</p>
<p>查看回调函数具体调用的函数名<br>在Linux内核代码里面，很多结构体里面都有一些函数指针。在调试过程中，经常不知道该指针具体调用的是哪一个函数，那么有下面两种方法可以进行查看：<br>方法一：打印堆栈信息<br>在使用函数指针的后面，调用dump_stack()函数。这个函数会把堆栈信息打印出来，通过堆栈信息，就可以知道函数指针具体调用的是哪一个函数。<br>方法二：使用lookup_symbol_name函数<br>函数原型：int lookup_symbol_name(unsigned long addr, char *symname)<br>说明：    addr参数-传入函数指针的值<br>        symname参数-保存函数名字的首地址<br>        注：要使用lookup_symbol_name函数，需要包含#include &lt;linux&#x2F;kallsyms.h&gt;头文件<br>Oops: 0002 [#1] SMP<br>0002这个是 OOPS 信息的错误码</p>
<p>bit 0    0 means no page found, 1 means a protection fault<br>bit 1    0 means read, 1 means write<br>bit 2    0 means kernel, 1 means user-mode<br>位0 0    表示找不到页面，1表示保护故障<br>bit 1     0表示已读，1表示已写<br>位2 0    表示内核，1表示用户模式</p>
<p>[#1] — this value is the number of times the Oops occurred. Multiple Oops can be triggered as a cascading effect of the first one.<br>这个值是 Oops 发生的次数, 多个 Oops 可以级联效应触发</p>
<p>CPU: 0 PID: 1313 Comm: kworker&#x2F;u4:0 Tainted: G      D      3.14.52-1.1.1_ga #40<br>表示发生在CPU 0，当前运行的进程是1313 进程是kworker&#x2F;u4:0 Tainted标识为：G 内核版本：3.14.52-1.1.1_ga  操作系统#40<br>————————————————<br>版权声明：本文为CSDN博主「monkey_lqd」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a3121772305/article/details/116885768">https://blog.csdn.net/a3121772305/article/details/116885768</a></p>
<p>内核中函数指针用的很多，在debug 的时候能直接打印出一个函数指针对应的函数就会很方便。</p>
<p>打印裸指针(raw pointer)用 %p,%p除了可以用来打印指针外还可以打印其它的信息</p>
<p>%pF可打印函数指针的函数名和偏移地址，%pf只打印函数指针的函数名，不打印偏移地址。</p>
<p>如</p>
<p>printk(“%pf %pF\n”, ptr, ptr) will print:</p>
<p>module_start module_start+0x0&#x2F;0x62 [hello]</p>
<p>但是为了支持这个功能你需要开启CONFIG_KALLSYMS 选项</p>
<p>打印函数栈<br>用户态<br>打印函数栈<br>使用backtrace()相关函数来达到输出函数栈的目的，man backtrace查看详细的参数，返回值等信息<br>简单说下这3个函数的用法：</p>
<p>int backtrace(void **buffer, int size);<br>backtrace()把函数栈中的函数地址写到buffer数组，buffer数组的成员即void *类型。size表示把栈顶size个函数地址搞出来，如果想把函数栈完全搞出来，确保buffer数组和size足够大。</p>
<p>char **backtrace_symbols(void *const *buffer, int size);<br>void backtrace_symbols_fd(void *const *buffer, int size, int fd);<br>backtrace_symbols()或者backtrace_symbols_fd()与上边的backtrace()配合使用，起一个翻译作用，即把函数地址翻译为函数名（还有函数的偏移和返回地址）。backtrace_symbols()把buffer数组中的size个元素翻译为函数名，把字符串数组保存在返回值char **中，自带了malloc功能，用完需把返回值free，见测试例。backtrace_symbols_fd()前两个参数和前者一样，但是把结果字符串数组输出到fd中，如fd&#x3D;1，即输出到屏幕<br>由函数指针得到函数名<br>根据以上可以看出，backtrace_symbols和backtrace_symbols_fd可以用来将函数指针转换为函数名<br>内核态<br>打印函数栈<br>使用dump_stack()函数。直接在需要查看函数栈的位置加入这一句，然后dmesg中就可以看到函数栈了。</p>
<p>查找分区的uuid<br>grub-probe -t fs_uuid &#x2F;boot</p>
<p>bash :local a&#x3D;0 声明一个局部变量<br>判断一个命令是否存在：if ! command -v fsck &gt;&#x2F;dev&#x2F;null 2&gt;&1;then<br>将命令结果保存到指定目录logsave -a -s $LOG_FILE fsck -a -T -t “$root_fstype” “$ROOT”<br>if [ -b “$ROOT” ]; then<br>$?用于查找最后执行的命令的返回值</p>
<p>$$<br>Shell本身的PID（ProcessID）<br>$!<br>Shell最后运行的后台Process的PID<br>$?<br>最后运行的命令的结束代码（返回值）<br>$-<br>使用Set命令设定的Flag一览<br>$*<br>所有参数列表。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<br>$@<br>所有参数列表。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<br>$#<br>添加到Shell的参数个数<br>$0<br>Shell本身的文件名<br>$1～$n<br>添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p>
<p>获取当前终端<br>read -r console rest &lt;&#x2F;proc&#x2F;consoles<br>if [ “${console}” &#x3D; “tty0” ]; then<br>    # Need to choose a specific VT<br>    console&#x3D;”tty1”<br>fi<br>获取所有sh(应该也可以用其他程序）的pid集合<br>pids&#x3D;$(pidof sh)<br>获取当前pid<br>self_pid&#x3D;<br>$$</p>
<p>如何判断是否在real environment还是在initramfs中：看看dde-dock存不存在</p>
<h1 id="Whether-in-the-real-environment"><a href="#Whether-in-the-real-environment" class="headerlink" title="Whether in the real environment"></a>Whether in the real environment</h1><p>real_env&#x3D;1<br>if [ -f &#x2F;bin&#x2F;dde-dock ]; then<br>    real_env&#x3D;0<br>    LOG_FILE&#x3D;&#x2F;tmp&#x2F;$PROJ.log<br>fi</p>
<p>shell log:<br>log_info() {<br>    echo “$<em>“ &gt;&amp;2<br>    echo “TUI: $</em>“ &gt;&gt;$LOG_FILE<br>}</p>
<p>trap用法：<br>trap clean_boot EXIT<br>起因<br>项目中的升级脚本可能耗时很长，在这段时间内，脚本没有任何输出的，这带给市场部署人员的感觉就是脚本好像卡住了。通常情况下，部署人员都会直接CTRL+C停掉升级脚本，这会导致升级失败，最终需要开发人员介入去修复环境。</p>
<p>可以通过输出升级进度的方式提示部署人员升级正在进行中，但进度也可能在一段时间不动，而且无法避免意外终止升级的情况，此时可以使用Shell的内建命令trap来忽略SIGINT这些信号，保证升级不会中断。<br>trap [-lp] [[arg] sigspec …]<br>arg可以是shell命令或者自定义函数<br>sigspec可以是以下的一个或多个<br>定义在&lt;signal.h&gt;中的信号名或者数值。信号名的大小写不敏感，SIG这个前缀也是可选的。以下的命令的效果都是一样的<br>trap “echo 123” SIGINT<br>trap “echo 123” INT<br>trap “echo 123” 2<br>trap “echo 123” int<br>trap “echo 123” Int<br>EXIT：在shell退出前执行trap设置的命令，也可以指定为0<br>RETURN：在函数返回时，或者.和source执行其他脚本返回时，执行trap设置的命令<br>DEBUG：在任何命令执行前执行trap设置的命令，但对于函数仅在函数的第一条命令前执行一次</p>
<p>shell中判断语句if中-z 和 -n</p>
<p>[ -a FILE ] 如果 FILE 存在则为真。</p>
<p>[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。</p>
<p>[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。</p>
<p>[ -d FILE ] 如果 FILE 存在且是一个目录则为真。</p>
<p>[ -e FILE ] 如果 FILE 存在则为真。</p>
<p>[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</p>
<p>[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</p>
<p>[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。</p>
<p>[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</p>
<p>[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</p>
<p>[ -r FILE ] 如果 FILE 存在且是可读的则为真。</p>
<p>[ -s FILE ] 如果 FILE 存在且大小不为0则为真。</p>
<p>[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。</p>
<p>[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</p>
<p>[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。</p>
<p>[ -x FILE ] 如果 FILE 存在且是可执行的则为真。</p>
<p>[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。</p>
<p>[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</p>
<p>[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。</p>
<p>[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。</p>
<p>[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。</p>
<p>[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。</p>
<p>[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。</p>
<p>[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</p>
<p>[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。</p>
<p>[ -z STRING ] “STRING” 的长度为零则为真。</p>
<p>[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。</p>
<p>[ STRING1 &#x3D;&#x3D; STRING2 ] 如果2个字符串相同。 “&#x3D;” may be used instead of “&#x3D;&#x3D;” for strict POSIX compliance则为真。</p>
<p>[ STRING1 !&#x3D; STRING2 ] 如果字符串不相等则为真。</p>
<p>[ STRING1 &lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。</p>
<p>[ STRING1 &gt; STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。</p>
<p>[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.</p>
<p>cat &#x2F;proc&#x2F;net&#x2F;netlink| grep sockid 这里面的基本都是内核传的socket<br>sudo netstat -x | grep sockid<br>sudo netstat -xp| grep proc<br>cat &#x2F;proc&#x2F;net&#x2F;unix | grep sockid</p>
<p>给u盘改名：<br>sudo mlabel -i &#x2F;dev&#x2F;sda ::LL  （label是名字）</p>
<pre><code>例子：

sudo mlabel -i /dev/sda ::recovery
</code></pre>
<p>格式化U盘：</p>
<p>sudo mkfs.btrfs -f &#x2F;dev&#x2F;sdc</p>
<h2 id="下载wpa最上游源码："><a href="#下载wpa最上游源码：" class="headerlink" title="下载wpa最上游源码："></a>下载wpa最上游源码：</h2><p>git clone git:&#x2F;&#x2F;w1.fi&#x2F;srv&#x2F;git&#x2F;hostap.git</p>
<h2 id="使用wpa开热点："><a href="#使用wpa开热点：" class="headerlink" title="使用wpa开热点："></a>使用wpa开热点：</h2><p>ctrl_interface&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant<br>update_config&#x3D;1<br>ap_scan&#x3D;2</p>
<p>network&#x3D;{<br>        ssid&#x3D;”A-WPA3-TEST”<br>        mode&#x3D;2<br>        key_mgmt&#x3D;SAE<br>        proto&#x3D;RSN<br>        pairwise&#x3D;CCMP<br>        psk&#x3D;”12345678”<br>        sae_password&#x3D;”12345678”<br>        ieee80211w&#x3D;2<br>}<br> wpa_supplicant -Dnl80211 -iwlan0 -c wpa_supplicant.conf</p>
<h2 id="删除已连接的网络：-1"><a href="#删除已连接的网络：-1" class="headerlink" title="删除已连接的网络："></a>删除已连接的网络：</h2><p>删除&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;下，然后重启NetworkManager</p>
<h2 id="查看vim是否支持剪切板"><a href="#查看vim是否支持剪切板" class="headerlink" title="查看vim是否支持剪切板"></a>查看vim是否支持剪切板</h2><p>vim –version| grep “clipboard”<br>不支持的话安装：<br>sudo apt install vim-gtk</p>
<ol start="3">
<li>使用快捷键#<br>“+y和”+p的输入挺麻烦的，我们直接为他们创建个快捷键吧</li>
</ol>
<p>vim创建快捷键的原理可以看 jalused的博客</p>
<p>我使用的快捷键如下</p>
<p>“ 支持在Visual模式下，通过C-y复制到系统剪切板<br>vnoremap <code>&lt;C-y&gt;</code> “+y<br>“ 支持在normal模式下，通过C-p粘贴系统剪切板<br>nnoremap <code>&lt;C-p&gt;</code> “*p<br>将上面的内容copy到~&#x2F;.vimrc中即可生效，效果就是：</p>
<p>在vim的visual模式下选中了要复制的内容，再用Ctrl + y复制到系统剪切板，直接去其他窗口中Ctrl + v粘贴<br>在其他窗口中选择之后（不一定要Ctrl + c），可直接在vim中用Ctrl + p来粘贴<br>“语法高亮度显示<br>syntax on<br>“下面两行在进行编写代码时，在格式对起上很有用；<br>“第一行，vim使用自动对起，也就是把当前行的对起格式应用到下一行；<br>“第二行，依据上面的对起格式，智能的选择对起方式，对于类似C语言编<br>“写上很有用<br>set autoindent<br>set smartindent<br>“在编辑过程中，在右下角显示光标位置的状态行<br>set ruler</p>
<p>cpio格式 initrd 的解压与压缩:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/feisang/article/details/6121269">https://blog.csdn.net/feisang/article/details/6121269</a><br><a target="_blank" rel="noopener" href="https://blog.sina.com.cn/s/blog_6795385f0100kdb7.html">https://blog.sina.com.cn/s/blog_6795385f0100kdb7.html</a></p>
<p>加载initrd的过程:<br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-29073321-id-5570250.html">http://blog.chinaunix.net/uid-29073321-id-5570250.html</a></p>
<p>第二部分：initrd、initramfs<br>一、    initrd出现的背景<br>在早期的linux系统中，一般只有硬盘或者软盘被用来作为linux根文件系统的存储设备，因此也就很容易把这些设备的驱动程序集成到内核中。但是现在的嵌入式系统中可能将根文件系统保存到各种存储设备上，包括scsi、sata，u-disk等等。因此把这些设备的驱动代码全部编译到内核中显然就不是很方便。<br>在内核模块自动加载机制udev中，我们看到利用udevd可以实现内核模块的自动加载，因此我们希望如果存储根文件系统的存储设备的驱动程序也能够实现自动加载，那就好了。但是这里有一个矛盾，udevd是一个可执行文件，在根文件系统被挂载前，是不可能执行udevd的，但是如果udevd没有启动，那就无法自动加载存储根文件系统设备的驱动程序，同时也无法在&#x2F;dev目录下建立相应的设备节点。<br>为了解决这一矛盾，于是出现了基于ramdisk的initrd( bootloader initialized RAM disk )。Initrd是一个被压缩过的小型根目录，这个目录中包含了启动阶段中必须的驱动模块，可执行文件和启动脚本，也包括上面提到的udevd（实现udev机制的demon）。当系统启动的时候，bootloader会把initrd文件读到内存中，然后把initrd文件在内存中的起始地址和大小传递给内核。内核在启动初始化过程中会解压缩initrd文件，然后将解压后的initrd挂载为根目录，然后执行根目录中的&#x2F;init脚本（cpio格式的initrd为&#x2F;init,而image格式的initrd&lt;也称老式块设备的initrd或传统的文件镜像格式的initrd&gt;为&#x2F;initrc），您就可以在这个脚本中运行initrd文件系统中的udevd，让它来自动加载realfs（真实文件系统）存放设备的驱动程序以及在&#x2F;dev目录下建立必要的设备节点。在udevd自动加载磁盘驱动程序之后，就可以mount真正的根目录，并切换到这个根目录中来。<br>这里只是个简单的描述，后面慢慢分析吧。</p>
<p>5、noinitrd<br>(仅当内核配置了选项 CONFIG_BLK_DEV_RAM和CONFIG_BLK_DEV_INITRD)现在的内核都可以支持initrd了，引导进程首先装载内核和一个初始化的ramdisk，然后内核将initrd转换成普通的ramdisk，也就是读写模式的根文件系统设备。然后linuxrc执行，然后装载真正的根文件系统，之后ramdisk被卸载，最后执行启动序列，比如&#x2F;sbin&#x2F;init。</p>
<p>选项noinitrd告诉内核不执行上面的步骤，即使内核编译了initrd，而是把initrd的数据写到 &#x2F;dev&#x2F;initrd，只是这是一个一次性的设备。</p>
<p>Debian Linux 内核手册：<a target="_blank" rel="noopener" href="https://kernel-team.pages.debian.net/kernel-handbook/index.html">https://kernel-team.pages.debian.net/kernel-handbook/index.html</a></p>
<p>142347 【4.19自测】【桌面专业版】【1050update2】【第一轮】【PGV】【Kirin990】【DDE】双屏仅单屏显示，切换tty后再切换账户登录，a屏显示登录页面，b屏显示tty界面：<br>设置主屏only时候 xorg切换tty会调用10+次 drm_mode_setcrtc，调用栈基本一样<br>32.36100 1326    1326    Xorg            drm_mode_setcrtc<br>        drm_mode_setcrtc+0x0 [kernel]<br>        drm_ioctl+0x1c0 [kernel]<br>        $x+0x50 [kernel]<br>        do_vfs_ioctl+0xa4 [kernel]<br>        ksys_ioctl+0x78 [kernel]<br>        __arm64_sys_ioctl+0x1c [kernel]<br>        el0_svc_common+0x90 [kernel]<br>        el0_svc_handler+0x9c [kernel]<br>        el0_svc+0x8 [kernel]<br>        __GI___ioctl+0xc [libc-2.28.so]<br>        drmModeSetCrtc+0x98 [libdrm.so.2.4.0]<br>        [unknown] [amdgpu_drv.so]<br>        [unknown] [Xorg]<br>        xf86DisableUnusedFunctions+0xac [Xorg]<br>        [unknown] [Xorg]<br>        RRCrtcSet+0x22c [Xorg]<br>        ProcRRSetCrtcConfig+0x21c [Xorg]<br>        [unknown] [Xorg]<br>        [unknown] [Xorg]<br>        __libc_start_main+0xe4 [libc-2.28.so]<br>        [unknown] [Xorg]<br>华为机器使用的wayland，切换tty不会调用drm_mode_setcrtc，此函数用于关闭显示器. 在其他使用wayland的机器上也是如此，并且有同样的现象。说明此问题是wayland的问题。</p>
<h2 id="重新安装英伟达驱动："><a href="#重新安装英伟达驱动：" class="headerlink" title="重新安装英伟达驱动："></a>重新安装英伟达驱动：</h2><p>1、清除英伟达显卡驱动安装包：<br>dpkg -l |grep nvidia |awk ‘{print $2}’ |xargs sudo apt-get purge -y<br>2、看仓库有什么版的包：<br>apt policy nvidia-driver<br>3、安装英伟达的驱动包：<br>apt install nvidia-<strong>driver</strong></p>
<h2 id="nvidia开启drm的设置："><a href="#nvidia开启drm的设置：" class="headerlink" title="nvidia开启drm的设置："></a>nvidia开启drm的设置：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16752202244564-16752204907801.png" alt="企业微信截图_16752202244564"></p>
<p>问题分析：该机型同时存在两种显示驱动，一个是BIOS提供的，一个是amd驱动提供，默认控制终端显示采用bios提供的那个驱动，而那个驱动偏偏是有问题的， 如果在grub中添加一个参数：fbcon&#x3D;map:1 强行让amdgpu驱动来显示控制终端就可以切换tty了</p>
<p>getenforce 看selinux是否打开</p>
<p><a target="_blank" rel="noopener" href="http://pkg.loongnix.cn/loongnix/pool/main">http://pkg.loongnix.cn/loongnix/pool/main</a>  龙芯的源码在这个仓库地址里找。</p>
<p>debian官网查找类似代码的网站，可以用来参考其他包是怎么写代码的：</p>
<p><a target="_blank" rel="noopener" href="https://codesearch.debian.net/">https://codesearch.debian.net/</a></p>
<p>获取机器的机型：sudo dmidecode -s system-family</p>
<p>通过dsc下载代码：</p>
<p><a target="_blank" rel="noopener" href="http://pkg.loongnix.cn/loongnix/pool/main/o/openjdk-8/openjdk-8_8u352-b08-lnd.8.1.12.dsc">http://pkg.loongnix.cn/loongnix/pool/main/o/openjdk-8/openjdk-8_8u352-b08-lnd.8.1.12.dsc</a></p>
<p>dpkg-source -x openjdk-8_8u352-b08-lnd.8.1.12.dsc</p>
<p> 龙芯仓库 <a target="_blank" rel="noopener" href="http://pkg.loongnix.cn/loongnix/pool/main/">http://pkg.loongnix.cn/loongnix/pool/main/</a></p>
<p>龙芯mips仓库<a target="_blank" rel="noopener" href="http://ftp.loongnix.cn/os/loongnix/20/mips64el/pool/main/">http://ftp.loongnix.cn/os/loongnix/20/mips64el/pool/main/</a></p>
<h2 id="dbus-send："><a href="#dbus-send：" class="headerlink" title="dbus-send："></a>dbus-send：</h2><p>dbus-send –print-reply –session –dest&#x3D;com.deepin.daemon.InputDevices &#x2F;com&#x2F;deepin&#x2F;daemon&#x2F;InputDevice&#x2F;Wacom org.freedesktop.DBus.Properties.Get string:com.deepin.daemon.InputDevice.Wacom string:Exis</p>
<p>dbus-send –print-reply –system –type&#x3D;method_call –dest&#x3D;org.freedesktop.DBus &#x2F; org.freedesktop.DBus.ReloadConfig</p>
<p>获取当前的bssid：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbus-send --system --dest=fi.w1.wpa_supplicant1 --print-reply /fi/w1/wpa_supplicant1/Interfaces/1 org.freedesktop.DBus.Properties.Get string:fi.w1.wpa_supplicant1.Interface string:CurrentBSS</span><br><span class="line"></span><br><span class="line">    method return time=1685433175.012823 sender=:1.7 -&gt; destination=:1.861 serial=631 reply_serial=2</span><br><span class="line">       variant       object path &quot;/fi/w1/wpa_supplicant1/Interfaces/1/BSSs/22&quot;</span><br><span class="line"></span><br><span class="line">dbus-send --system --dest=fi.w1.wpa_supplicant1 --print-reply /fi/w1/wpa_supplicant1/Interfaces/1/BSSs/22 org.freedesktop.DBus.Properties.Get string:fi.w1.wpa_supplicant1.BSS string:BSSID</span><br><span class="line">	method return time=1685434152.265572 sender=:1.7 -&gt; destination=:1.1099 serial=643 reply_serial=2</span><br><span class="line">   variant       array of bytes [</span><br><span class="line">         38 eb 47 bc eb d1</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<h2 id="通过-D-Bus-访问接口，跟d-feet打印的类似："><a href="#通过-D-Bus-访问接口，跟d-feet打印的类似：" class="headerlink" title="通过 D-Bus 访问接口，跟d-feet打印的类似："></a>通过 D-Bus 访问接口，跟d-feet打印的类似：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ gdbus introspect --system --dest org.freedesktop.hostname1 --object-path /org/freedesktop/hostname1</span><br><span class="line">node /org/freedesktop/hostname1 &#123;</span><br><span class="line">  interface org.freedesktop.hostname1 &#123;</span><br><span class="line">    methods:</span><br><span class="line">      SetHostname(in  s name,</span><br><span class="line">                  in  b user_interaction);</span><br><span class="line">      SetStaticHostname(in  s name,</span><br><span class="line">                        in  b user_interaction);</span><br><span class="line">      SetPrettyHostname(in  s name,</span><br><span class="line">                        in  b user_interaction);</span><br><span class="line">      SetIconName(in  s name,</span><br><span class="line">                  in  b user_interaction);</span><br><span class="line">      SetChassis(in  s name,</span><br><span class="line">                 in  b user_interaction);</span><br><span class="line">    signals:</span><br><span class="line">    properties:</span><br><span class="line">      readonly s Hostname = &#x27;dhcp-192-168-47-11&#x27;;</span><br><span class="line">      readonly s StaticHostname = &#x27;lennarts-computer&#x27;;</span><br><span class="line">      readonly s PrettyHostname = &#x27;Lennart&#x27;s Computer&#x27;;</span><br><span class="line">      readonly s IconName = &#x27;computer-laptop&#x27;;</span><br><span class="line">      readonly s Chassis = &#x27;laptop&#x27;;</span><br><span class="line">  &#125;;</span><br><span class="line">  interface org.freedesktop.DBus.Properties &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">  interface org.freedesktop.DBus.Introspectable &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">  interface org.freedesktop.DBus.Peer &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230419101036631.png" alt="image-20230419101036631"></p>
<h3 id="一种打印非以’-0’结尾的字符串的方法："><a href="#一种打印非以’-0’结尾的字符串的方法：" class="headerlink" title="一种打印非以’\0’结尾的字符串的方法："></a>一种打印非以’\0’结尾的字符串的方法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Print only &#x27;nbytes&#x27; of &#x27;buf&#x27;, as it doesn&#x27;t contain a terminating</span><br><span class="line">              null byte (&#x27;\0&#x27;). */</span><br><span class="line">           printf(&quot;&#x27;%s&#x27; points to &#x27;%.*s&#x27;\n&quot;, argv[1], (int) nbytes, buf);</span><br></pre></td></tr></table></figure>

<h2 id="Libinput："><a href="#Libinput：" class="headerlink" title="Libinput："></a>Libinput：</h2><p>查看libinput事件：</p>
<p>sudo libinput debug-events</p>
<p>查看按的键：</p>
<p>sudo libinput debug-events –show-keycodes</p>
<h3 id="libevdev中libevdev-events-c文件对应的命令是什么？怎么使用"><a href="#libevdev中libevdev-events-c文件对应的命令是什么？怎么使用" class="headerlink" title="libevdev中libevdev-events.c文件对应的命令是什么？怎么使用"></a>libevdev中libevdev-events.c文件对应的命令是什么？怎么使用</h3><p><code>libevdev-events.c</code> 文件是 <code>libevdev</code> 库中的一个示例程序，用于演示如何使用 <code>libevdev</code> 库处理输入事件。该文件并不是一个可执行程序，而是一个源代码文件，需要通过编译生成可执行程序。</p>
<p>你可以通过以下步骤编译 <code>libevdev-events.c</code> 文件：</p>
<ol>
<li><p>确保已经安装了 <code>libevdev</code> 库及其头文件，以及编译工具链（如 gcc）。</p>
</li>
<li><p>下载 <code>libevdev</code> 源代码，并切换到对应版本的代码目录。</p>
</li>
<li><p>进入 <code>./test</code> 目录，该目录下包含了 <code>libevdev</code> 库的一些示例程序。</p>
</li>
<li><p>使用以下命令编译 <code>libevdev-events.c</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">gcc -Wall -g -o libevdev-events libevdev-events.c -levdev</span><br></pre></td></tr></table></figure>

<p>上述命令中，<code>-Wall</code> 参数用于开启所有警告信息，<code>-g</code> 参数用于开启调试信息，<code>-o</code> 参数用于指定生成的可执行文件名为 <code>libevdev-events</code>，<code>-levdev</code> 参数用于链接 <code>libevdev</code> 库。</p>
</li>
<li><p>执行编译生成的可执行文件 <code>libevdev-events</code>，并传递输入设备文件名作为参数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">./libevdev-events /dev/input/event0</span><br></pre></td></tr></table></figure>

<p>上述命令中，<code>/dev/input/event0</code> 是输入设备文件名，你需要将其替换为你想要监控的输入设备文件名。</p>
</li>
</ol>
<p>执行上述命令后，<code>libevdev-events</code> 程序会打印出输入设备上产生的所有事件信息。你可以通过修改 <code>libevdev-events.c</code> 文件中的代码，来了解如何使用 <code>libevdev</code> 库处理输入事件。</p>
<h3 id="如何确定-dev-input-eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput-debug-events然后移动鼠标就行了）"><a href="#如何确定-dev-input-eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput-debug-events然后移动鼠标就行了）" class="headerlink" title="如何确定&#x2F;dev&#x2F;input&#x2F;eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput debug-events然后移动鼠标就行了）"></a>如何确定&#x2F;dev&#x2F;input&#x2F;eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput debug-events然后移动鼠标就行了）</h3><p>您可以使用 <code>evtest</code>命令来列出可用的输入设备及其对应的event。下面是一些基本的使用方法：</p>
<ol>
<li><p>安装evtest：在大多数Linux发行版上，您可以使用以下命令安装evtest：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduinoCopy code</span><br><span class="line">sudo apt-get install evtest</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">sudo yum install evtest</span><br></pre></td></tr></table></figure></li>
<li><p>列出可用的输入设备：运行以下命令以列出可用的输入设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code</span><br><span class="line">evtest --enumerate</span><br></pre></td></tr></table></figure>

<p>该命令将列出所有的输入设备及其对应的event，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code/dev/input/event0    Lid Switch</span><br><span class="line">/dev/input/event1    Power Button</span><br><span class="line">/dev/input/event2    AT Translated Set 2 keyboard</span><br><span class="line">/dev/input/event3    SynPS/2 Synaptics TouchPad</span><br></pre></td></tr></table></figure></li>
<li><p>测试输入设备：您可以使用以下命令来测试某个输入设备，例如触摸板设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">evtest /dev/input/event3</span><br></pre></td></tr></table></figure>

<p>该命令将打印出输入设备发出的事件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">luaCopy codeEvent: time 1618822168.785292, type 3 (EV_ABS), code 0 (ABS_X), value 3097</span><br><span class="line">Event: time 1618822168.785292, type 3 (EV_ABS), code 1 (ABS_Y), value 1509</span><br><span class="line">Event: time 1618822168.785292, type 3 (EV_ABS), code 24 (ABS_PRESSURE), value 0</span><br><span class="line">Event: time 1618822168.785292, -------------- SYN_REPORT ------------</span><br></pre></td></tr></table></figure>

<p>这将帮助您确定触摸板设备对应的event号码。</p>
</li>
</ol>
<h2 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig:"></a>ldconfig:</h2><p>&#x2F;*ldconfig 命令的用途主要是在默认搜寻目录 &#x2F;lib 和 &#x2F;usr&#x2F;lib 以及动态库配置文件 &#x2F;etc&#x2F;ld.so.conf 内所列的目录下，</p>
<p>搜索出可共享的动态链接库（格式如 lib*.so*），进而创建出动态链接器（ld.so 或 ld-linux.so）所需的缓存文件。</p>
<p>缓存文件默认为 &#x2F;etc&#x2F;ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，</p>
<p>需运行动态链接库的管理命令 ldconfig 更新动态链接库的缓存文件，此执行程序存放在 &#x2F;sbin 目录下。</p>
<p>ldconfig 通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。*&#x2F;</p>
<p>一个重要的bug:<a target="_blank" rel="noopener" href="https://pms.uniontech.com/zentao/bug-view-101762.html">https://pms.uniontech.com/zentao/bug-view-101762.html</a></p>
<p>复现问题，查看cat &#x2F;proc&#x2F;bus&#x2F;input&#x2F;devices &gt;input.txt ,查看文件触摸板设备Touch为event2  远程cat &#x2F;dev&#x2F;input&#x2F;event2发现是有数据的。执行 sudo libinput debug-events –show-keycode 命令无数据，sudo libinput debug-events有数据。</p>
<p>这个问题目前分析的应该是比较全面了。分析结论如下：</p>
<p>1、休眠同时触发合盖动作，lid event节点会上报合盖事件，同时休眠。</p>
<p>2、kwin调用libinput，在接收到合盖事件后，主动禁用触摸设备，这一操作是libinput内部操作，主要的实现机制是关闭对应event的fd。在kwin场景下是通过调用systemd的releaseDevice来达到关闭触摸设备的目的。</p>
<p>3、开盖后，唤醒设备，此时系统并不会有开盖的事件上报。</p>
<p>4、因为此时kwin并没有收到开盖事件，所以触摸设备仍然处于禁用状态。</p>
<p>5、按下键盘，此时仍然不会收到开盖事件，这一点可以通过监听sudo cat &#x2F;dev&#x2F;input&#x2F;eventX设备节点可以确认，而且通过sudo evtest也可以确认确实没有监听到开盖事件，同时也可以查到此时开合盖的状态仍然处于合盖状态。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278110.png" alt="img"></p>
<p>6、按下按键后，libinput虽然发现设备仍然处于合盖状态，但是根据libinput的机制，认为触发键盘按键时，设备应该实际处于开盖状态。所以libinput主动上报了一个开盖事件出来。(通过sudo libinput debug-events –show-keycodes可以监听到这个事件)。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278105.png" alt="img"></p>
<p>上面说的2、5、6三点均为libinput的机制。官方文档地址如下</p>
<p><a target="_blank" rel="noopener" href="https://wayland.freedesktop.org/libinput/doc/1.8.1/switches.html">https://wayland.freedesktop.org/libinput/doc/1.8.1/switches.html</a></p>
<p>简单翻译</p>
<p>在可用的场景下，libinput会监听提供盖子开关的设备。evdev事件代码EV_SW SW_LID提供为LIBINPUT_SWITCH_LID。如果带有盖子开关的设备有触摸板设备，则当盖子在逻辑上关闭时，该设备将被禁用。这是为了避免触控板和闭合的盖子可能引起的鬼触。当盖子打开时，触摸板会自动重新启用。</p>
<p>这种盖子开关的处理对用户来说是透明的，不发送通知，设备在任何时候都显示为启用。</p>
<p>在某些设备上，设备的盖子状态并不总是反映物理状态，即使当盖子物理上是打开的，盖子状态也可能报告为关闭。Libinput使用一些启发式方法来检测用户输入(特别是输入)，以重新启用这些设备上的触摸板。</p>
<p>该问题的根本原因还是在于开合盖的状态和实际物理状态不一致导致的。如果想要彻底解决该问题，还是需要能够解决这个状态异常的情况。</p>
<p>问题复现时进行开盖合盖测试程序测试</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-278278.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278278.png" alt="img"></a></p>
<p>发生问题时开盖合盖简直监测：</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-278281.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278281.png" alt="img"></a></p>
<p>当问题复现时驱动层无开盖信息。</p>
<p>复现场景为待机按键后马上合盖，合盖后进入待机流程。此时待机未完成进入待机保存现场（带有合盖待机状态），处于待机未完成。当打开笔记本盖子时继续完成待机，（待机相关信息保存在硬盘，无法监测到开盖事件。）相关处理指示灭掉灯表示此时已经完成保存待机状态。待机状态设备状态此是不通电驱动层的无法感知开盖，系统层无法修改，只能应用层规避此问题。</p>
<pre><code>休眠             合盖                              开盖            半休眠状态信息保存硬盘是掉电状态驱动无法获取开盖事件
</code></pre>
<p>运行状态———》休眠到一半——-》带有合盖状态休眠保存待机状态———》恢复带有合盖状态休眠保存待机状态再次执行未完成的待机–—》开机问题复现</p>
<p>进程休眠或者待机收到为同一信号无法做区分，需要加入新的唤醒信号或者做标识，来让上层做分析处理。</p>
<p>下层处理风险太大，按现在逻辑分析按键时间会模拟开盖事件，只是滑动触摸板没有模拟开盖事件。无硬件反馈下层是无法感知，即使修改会产生很大问题。libinput是可以感应到滑动触摸板，做个开盖模拟操作就可以了。</p>
<p>查看kwin相关代码：libinput&#x2F;device.cpp +526</p>
<p>Device::Device(libinput_device *device, QObject *parent)类中有相关处理</p>
<p>cat &#x2F;dev&#x2F;input&#x2F;event 事件，触摸板有滑动事件，但是异常出问题libinput被拦截。替换麒麟内核问题依然复现不是内核原因，不是在用户内部服务修改，不然登陆界面复现问题，比较大的概率在libinput。</p>
<h2 id="安装双系统："><a href="#安装双系统：" class="headerlink" title="安装双系统："></a>安装双系统：</h2><p>第一个系统分区[注意顺序]：</p>
<p>efi 300M</p>
<p>swap 8G[和原有运行内存相当]</p>
<p>&#x2F;boot 2G</p>
<p>&#x2F;  根分区100G</p>
<p>第二个系统</p>
<p>在第一个系统的分区基础上进行</p>
<p>&#x2F;boot 2G</p>
<p>&#x2F;</p>
<h2 id="华为机型判断"><a href="#华为机型判断" class="headerlink" title="华为机型判断"></a>华为机型判断</h2><p>一、华为机型判断<br>KLV中有: HUAWEI QINGYUN L420 KLVV-W5821<br>PGV中有: PGUV W515<br>KLU中有: L410 KLVU<br>PGW中有: PGUW W525<br>机型判断3种方式<br>1.可以通过机器上的铭牌查看<br>2.进入系统后通过cat &#x2F;etc&#x2F;hw_version查看<br>3.通过dmidecode -s system-product-name查看</p>
<p>二、klu和klua机型区分<br>hwfirmware -v的结果小于等于2.0.0.53是klu,其他是klua，如:结果是2.0.1.7就是klua</p>
<p>三、pgv和pgv C版本机器区分<br>拆开机箱看显卡芯片，在风扇边上的是小芯片就是pgv机器，是大芯片就是pgv c版本机器</p>
<p>四、pgv使用ti显卡芯片还是龙讯显卡芯片区分<br>dmesg | grep lt9711a结果出现lt9711a is onboard就是龙讯显卡芯片的pgv机器<br>dmesg | grep sn65dsix6结果出现sn65dsix6 is onboard就是ti显卡芯片的pgv机器</p>
<p>五、查看目前安装的系统华为版本<br>通过cat &#x2F;etc&#x2F;hw_version查看</p>
<p>六、查看目前安装的系统统信版本<br>通过cat &#x2F;etc&#x2F;os-version查看,主要看MinorVersion&#x3D;的结果，如MinorVersion&#x3D;1022是1022版本</p>
<h2 id="systemd-analyze是如何统计开机时间的"><a href="#systemd-analyze是如何统计开机时间的" class="headerlink" title="systemd-analyze是如何统计开机时间的"></a>systemd-analyze是如何统计开机时间的</h2><p>使用systemd-analyze可以得到以下结果：<br>Startup finished in 22.440s (firmware) + 2.471s (loader) + 40.688s (kernel) + 8.427s (userspace) &#x3D; 1min 14.028s graphical.target reached after 8.420s in userspace<br>我们可以清晰的看到固件，grub，内核所耗费的时间，但systemd启动的时机在fireware,loader和kernel之后，它是如何统计这些启动阶段所耗的时间的呢。</p>
<h3 id="firmware和loader"><a href="#firmware和loader" class="headerlink" title="firmware和loader"></a>firmware和loader</h3><p>通过分析systemd代码，systemd统计fireware和loader的时间是通过读取acpi fpdt表和efi变量来完成的。具体的代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">boot_timestamps</span><span class="params">(<span class="type">const</span> dual_timestamp *n, dual_timestamp *firmware, dual_timestamp *loader)</span> &#123;</span><br><span class="line">        r = acpi_get_boot_usec(&amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                r = efi_loader_get_boot_usec(&amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中acpi_get_boot_usec主要是解析acpi fpdt表的内容。大致实现如下。在高版本的内核中已经实现了acpi表的解析，不再需要在用户态来解析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">acpi_get_boot_usec</span><span class="params">(<span class="type">usec_t</span> *loader_start, <span class="type">usec_t</span> *loader_exit)</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_table_header</span> *<span class="title">tbl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_fpdt_header</span> *<span class="title">rec</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_fpdt_boot_header</span> <span class="title">hbrec</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_fpdt_boot</span> <span class="title">brec</span>;</span></span><br><span class="line"></span><br><span class="line">        r = read_full_file(<span class="string">&quot;/sys/firmware/acpi/tables/FPDT&quot;</span>, &amp;buf, &amp;l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find Firmware Basic Boot Performance Pointer Record */</span></span><br><span class="line">        <span class="keyword">for</span> (rec = (<span class="keyword">struct</span> acpi_fpdt_header *)(buf + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_table_header));</span><br><span class="line">             (<span class="type">char</span> *)rec length)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rec-&gt;length type != ACPI_FPDT_TYPE_BOOT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (rec-&gt;length != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_header))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                ptr = rec-&gt;ptr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read Firmware Basic Boot Performance Data Record */</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_CLOEXEC|O_RDONLY);</span><br><span class="line">       l = pread(fd, &amp;hbrec, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_boot_header), ptr);  </span><br><span class="line">       l = pread(fd, &amp;brec, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_boot), ptr + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_boot_header));</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>efi_loader_get_boot_usec函数主要是读取LoaderTimeInitUSec和LoaderTimeExecUSec两个efi变量，在此不再描述。</p>
<p>如果acpi表中数据有误，systemd-analyze则无法显示firmware和loader的时间。</p>
<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p>systemd统计kernel耗费时间的方式是记录自身启动时间的monotonic time。但实际上并不是内核启动的时间，它包含了kernel+initrd+systemd加载自身的时间。具体如何分析这三部分的时间需要分析内核和initrd的日志。<br>systemd统计内核启动时间的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">        dual_timestamp initrd_timestamp = DUAL_TIMESTAMP_NULL, userspace_timestamp = DUAL_TIMESTAMP_NULL, kernel_timestamp = DUAL_TIMESTAMP_NULL;</span><br><span class="line">        <span class="comment">/* Take timestamps early on */</span></span><br><span class="line">        dual_timestamp_from_monotonic(&amp;kernel_timestamp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CMake基础学习"><a href="#CMake基础学习" class="headerlink" title="CMake基础学习"></a>CMake基础学习</h2><p><a target="_blank" rel="noopener" href="https://docsin.uniontech.com/?p=20713">https://docsin.uniontech.com/?p=20713</a></p>
<h2 id="Mount"><a href="#Mount" class="headerlink" title="Mount:"></a>Mount:</h2><p>sudo mount -o remount,rw &#x2F;dev&#x2F;sdd2 重新以可写方式挂载boot分区</p>
<p>mount -i 打印的信息就是cat &#x2F;proc&#x2F;self&#x2F;mountinfo的信息</p>
<h2 id="GDB打印所有堆栈："><a href="#GDB打印所有堆栈：" class="headerlink" title="GDB打印所有堆栈："></a>GDB打印所有堆栈：</h2><p>thread apply all bt</p>
<h2 id="玲珑包工具："><a href="#玲珑包工具：" class="headerlink" title="玲珑包工具："></a>玲珑包工具：</h2><p><a target="_blank" rel="noopener" href="https://linglong.dev/guide/ll-cli/introduction.html">https://linglong.dev/guide/ll-cli/introduction.html</a></p>
<h2 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd:"></a>trace-cmd:</h2><p>ftrace: <a target="_blank" rel="noopener" href="https://www.modb.pro/db/105914">https://www.modb.pro/db/105914</a><br>trace-cmd: <a target="_blank" rel="noopener" href="https://www.modb.pro/db/125882">https://www.modb.pro/db/125882</a></p>
<p>查看trace-cmd是否可用：</p>
<p>mount | grep tracefs(好像没啥用，我虚拟机完全没打印东西)</p>
<p>查看有哪些追踪器可用：</p>
<p>trace-cmd list -t</p>
<p>启用你的第一个追踪器:</p>
<p>trace-cmd start -p function</p>
<p>trace-cmd record -l ext4_* -p function_graph</p>
<p>trace-cmd record  -p function_graph</p>
<p>trace-cmd report</p>
<p>用 <code>-P</code><br> 选项传递PID</p>
<p>&#x2F;sys&#x2F;kernel&#x2F;tracing</p>
<h2 id="apparmor官方文档："><a href="#apparmor官方文档：" class="headerlink" title="apparmor官方文档："></a>apparmor官方文档：</h2><p><a target="_blank" rel="noopener" href="https://gitlab.com/apparmor/apparmor/-/wikis/Documentation">https://gitlab.com/apparmor/apparmor/-/wikis/Documentation</a></p>
<h2 id="scsi设备扫描："><a href="#scsi设备扫描：" class="headerlink" title="scsi设备扫描："></a>scsi设备扫描：</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61608889">https://zhuanlan.zhihu.com/p/61608889</a></p>
<h2 id="休眠的实现："><a href="#休眠的实现：" class="headerlink" title="休眠的实现："></a>休眠的实现：</h2><p>将”mem”, “standby”, “freeze” and “disk”写入&#x2F;sys&#x2F;power&#x2F;state</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/power/states.txt">https://www.kernel.org/doc/Documentation/power/states.txt</a></p>
<p>内核部分的代码：关键词Syncing filesystems..和done.</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230316161646504.png" alt="image-20230316161646504"></p>
<h2 id="openssl-调试"><a href="#openssl-调试" class="headerlink" title="openssl 调试:"></a>openssl 调试:</h2><p>\1. 编译<br>&#x2F;config –debug –prefix&#x3D;&#x2F;usr&#x2F;<br>\2. 安装<br>make install_sw 会把openssl库安装到&#x2F;usr&#x2F;lib64</p>
<p>\3. &#x2F;etc&#x2F;ld.so.conf.d&#x2F;libc.conf添加 &#x2F;usr&#x2F;lib64</p>
<p>\4. 如果openssl有问题，会导致系统无法运行，此时用live镜像或者 initramfs 删除 &#x2F;root&#x2F;lib64下的openssl库</p>
<p>&#x2F;etc&#x2F;profile是由base-file生成的</p>
<h2 id="双rtc问题（参考190897）："><a href="#双rtc问题（参考190897）：" class="headerlink" title="双rtc问题（参考190897）："></a>双rtc问题（参考190897）：</h2><p>1、分析确认设备只有一个物理时钟芯片，但从内核看到两个rtc设备节点（efi-rtc和ds1307）<br>2、两个设备中读取出来的时间存在一致的问题。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621353.png" alt="img"></p>
<p>初步分析为<br>问题1: 一个物理时钟芯片，在内核中存在两个rtc设备问题</p>
<p>双rtc的问题的根源是固件那边同时实现了物理rtc到efi-rtc的映射实现的同时，在固件传给内核的acpi表上没有屏蔽掉物理rtc芯片设备，从而导致内核这边注册了两次rtc设备。</p>
<p>这个问题可以从固件方面修改，需要固件那边屏蔽acpi上面的物理设备的传递。或者内核这边通过内核启动参数，只注册efi-rtc忽略其他rtc设备。<br>或者内核通过custome acpi表，修改和屏蔽一个rtc设备。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621355.png" alt="img"></p>
<p>问题2:设备中读取出来的时间存在不一致的问题<br>通过修改bios中时间，在系统下读内核注册的rtc时间发现。</p>
<p>固件中修改时间后，rtc0 （efi-rtc）中的年份时间与预期一致。<br>但rtc1中（ds1307） 中的年份与预期不一致。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621357.png" alt="img"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621359.png" alt="img"></p>
<p>因内核第二次从rtc中读出年份解析错误，而导致系统时间变成了 2106（这个是系统显示时间上限问题）</p>
<p>这个问题初步确认为内核中rtc1的驱动读取时间时，出现解析年份异常。导致出现了2124年，这个问题是否是双rtc问题导致不确定（需要设备进一步排除）。</p>
<p>结论，以上问题非系统问题，建议转内核或厂商固件处理。</p>
<h2 id="Shutdown-reboot"><a href="#Shutdown-reboot" class="headerlink" title="Shutdown&#x2F;reboot"></a>Shutdown&#x2F;reboot</h2><p>对于目前使用systemd的linux发行版，reboot，shutdown，halt等命令是指向systemctl的软链接，执行reboot相当于执行 systemctl reboot，systemctl reboot 会切换到 reboot.target.</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/v2-7e584546c229a0b2784cad5d37939b99_720w.webp" alt="img"></p>
<p>注意，如果应用程序希望重启系统， 那么不应该直接启动此目标，而应该使用 systemctl reboot 命令(有可能还需要加上 –no-block 选项)或者直接调用 systemd-logind.service(8) 的 org.freedesktop.login1.Manager.Reboot D-Bus 方法。</p>
<p>为了保持与SysV的兼容性， runlevel6.target 是此单元的一个别名(软连接)。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/v2-c8220c022468b4a9e1e80aa31b4f54b5_720w.webp" alt="img"></p>
<p>conflicts with all system services：指那些定义了Conflicts&#x3D;shutdown.target 和 Before&#x3D;shutdown.target 依赖关系（除非明确设置了 DefaultDependencies&#x3D;no ，否则 service 单元将会自动添加这些依赖）的服务，这些服务在shutdown.target运行之前会停止。</p>
<p>实际执行过程从上到下，以reboot为例：</p>
<pre><code>systemd-reboot.service:
</code></pre>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/v2-f23a61e22a6d505f59281d3f8804750e_720w.webp" alt="img"></p>
<pre><code>我们的systemd-reboot.service是这样写的：
</code></pre>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103814108.png" alt="image-20230322103814108"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103941482.png" alt="image-20230322103941482"></p>
<p><strong>\1. 停止和shutdown.target、umount.target冲突的服务。</strong></p>
<p><strong>\2. shutdown.target、umount.target</strong></p>
<p><strong>\3. various low-level services</strong></p>
<p><strong>\4. final.target</strong></p>
<p><strong>\5. systemd-reboot.service</strong></p>
<p>该服务执行的命令行：ExecStart&#x3D;&#x2F;bin&#x2F;systemctl –force reboot，这条命令会调用systemd-shutdown，它将以简单而强大的方式卸载任何剩余的文件系统，杀死任何剩余的进程并释放任何其他剩余的资源，而不再考虑任何服务或单元概念。一般这是最后执行的服务。</p>
<p><strong>\6. reboot.target</strong></p>
<p>目标单元的功能仅仅是通过依赖关系将一组单元汇聚在一起， 形成一个同步点，并给这个同步点取一个众所周知的名称， 以便用作启动目标或其他单元的依赖。对于shutdown.target、umount.target、final.target、reboot.target这些目标单元，其组内的单元（.wants&#x2F;、.requires&#x2F;）实际的启动顺序取决于单元自身的依赖关系。</p>
<h2 id="systemd常规启动流程："><a href="#systemd常规启动流程：" class="headerlink" title="systemd常规启动流程："></a>systemd常规启动流程：</h2><p>当成功挂载了”root&#x3D;”内核引导选项指定的根文件系统之后，内核将启动由”init&#x3D;”内核引导选项指定的init程序， 从这个时间点开始，即进入了”常规启动流程”： 检测硬件设备并加载驱动、挂载必要的文件系统、启动所有必要的服务，等等。对于 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.html#">systemd(1)</a> 系统来说，上述”init程序”就是 systemd 进程， 而整个”常规启动流程”也以几个特殊的 target 单元(详见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.target.html#">systemd.target(5)</a>) 作为节点，被划分为几个阶段性步骤。 在每个阶段性步骤内部，任务是高度并行的， 所以无法准确预测同一阶段内单元的先后顺序， 但是不同阶段之间的先后顺序总是固定的。</p>
<p>当启动系统时， systemd 将会以 <code>default.target</code> 为启动目标， 借助单元之间环环相扣的依赖关系，即可完成”常规启动流程”。 <code>default.target</code> 通常只是一个指向 <code>graphical.target</code>(图形界面) 或 <code>multi-user.target</code>(文本控制台) 的软连接。 为了强制启动流程的规范性以及提高单元的并行性， 预先定义了一些具有特定含义的 target 单元。 详见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.special.html#">systemd.special(7)</a> 手册。</p>
<p>下面的图表解释了 这些具有特定含义的 target 单元之间的依赖关系 以及各自在启动流程中的位置。 图中的箭头表示了单元之间的依赖关系与先后顺序， 整个图表按照自上而下的时间顺序执行。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322102843189.png" alt="image-20230322102843189"></p>
<p>用<em>斜体</em>标识的目标单元经常被用作启动目标。 有两种方法可以指定启动目标： (1)使用 <code>systemd.unit=</code> 内核引导选项(参见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.html#">systemd(1)</a>)； (2)使用 <code>default.target</code> 软连接。</p>
<p>因为 <code>timers.target</code> 以异步方式包含在 <code>basic.target</code> 中， 所以 timer 单元可以依赖于在 <code>basic.target</code> 之后才启动的服务。</p>
<h2 id="initrd-Initial-RAM-Disk-启动流程-¶-http-www-jinbuguo-com-systemd-bootup-html-initrd-Initial-RAM-Disk-启动流程"><a href="#initrd-Initial-RAM-Disk-启动流程-¶-http-www-jinbuguo-com-systemd-bootup-html-initrd-Initial-RAM-Disk-启动流程" class="headerlink" title="initrd(Initial RAM Disk) 启动流程[¶](http://www.jinbuguo.com/systemd/bootup.html#initrd(Initial RAM Disk) 启动流程)"></a>initrd(Initial RAM Disk) 启动流程[¶](<a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/bootup.html#initrd">http://www.jinbuguo.com/systemd/bootup.html#initrd</a>(Initial RAM Disk) 启动流程)</h2><p>在initrd内部， 也可以将 systemd 用作 init程序(由”rdinit&#x3D;”内核引导选项指定)。</p>
<p>此时 <code>initrd.target</code> 将是默认目标。 initrd内部启动流程的上半部分与前一小节 <code>basic.target</code> 之前的部分完全相同。 随后的启动流程将以 <code>initrd.target</code> 为目标(如下图所示)。 在挂载任何文件系统之前(也就是在启动 <code>local-fs-pre.target</code> 之前)， <code>systemd-hibernate-resume@.service</code> 将会首先完成启动， 以检查系统是要从先前的休眠状态中恢复， 还是要执行常规的启动流程。 在检查完成之前，将不会挂载任何文件系统。 当根文件系统设备可用时，将到达 <code>initd-root-device.target</code> 目标。 如果成功的将根文件系统挂载到 <code>/sysroot</code> 目录，那么 <code>sysroot.mount</code> 单元将被启动，然后进一步到达 <code>initrd-root-fs.target</code> 目标。 <code>initrd-parse-etc.service</code> 将会分析 <code>/sysroot/etc/fstab</code> 文件以挂载 <code>/usr</code> (若需要) 与带有 <em>x-initrd.mount</em> 标记的挂载点。 所有这些挂载点都将被挂载到 <code>/sysroot</code> 之下，然后流程到达 <code>initrd-fs.target</code> 目标。再接下来 <code>initrd-cleanup.service</code> 将会使用 <strong>systemctl –no-block isolate</strong> 命令启动 <code>initrd-switch-root.target</code> 目标。 因为 isolate 表示立即停止所有在新的目标单元中不需要的进程， 所以此动作实际上是为接下来切换根目录做预先的准备(也就是清理环境)。 最后，启动 <code>initrd-switch-root.service</code> 服务，将系统的根目录切换至 <code>/sysroot</code> 目录。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103231804.png" alt="image-20230322103231804"></p>
<h2 id="关机流程¶"><a href="#关机流程¶" class="headerlink" title="关机流程¶"></a>关机流程<a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/bootup.html#%E5%85%B3%E6%9C%BA%E6%B5%81%E7%A8%8B">¶</a></h2><p>systemd 系统在关机时同样遵循固定的流程， 具体如下图所示：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103311681.png" alt="image-20230322103311681"></p>
<p><em>斜体</em>标识的目标单元经常被用作关机目标。</p>
<p>注意， <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd-halt.service.html#">systemd-halt.service(8)</a>, <code>systemd-reboot.service</code>, <code>systemd-poweroff.service</code>, <code>systemd-kexec.service</code> 会将系统与 systemd(PID&#x3D;1) 带入关机流程的第二个阶段(由 <code>systemd-shutdown</code> 执行)， 也就是不再考虑任何服务与单元等概念， 只用一种简单粗暴的方式卸载所有文件系统、杀死所有进程、释放所有资源。 一般来说，在第一阶段结束时，常规应用都已终止、常规资源都已释放，第二阶段只是一个兜底的安全网， 那些在第一阶段基于单元的关闭流程中(见前文) 未能结束的进程将被强制终止、未能释放的资源将被强制释放。</p>
<h2 id="出现D状态程序后打印内核堆栈："><a href="#出现D状态程序后打印内核堆栈：" class="headerlink" title="出现D状态程序后打印内核堆栈："></a>出现D状态程序后打印内核堆栈：</h2><p>如果出现D状态程序后，开两个终端，一个先执行dmesg -w，另一个再执行echo w &gt; &#x2F;proc&#x2F;sysrq-trigger, 在dmesg里打印内核的调用栈，</p>
<p>&#x2F;etc&#x2F;sysctl.conf file:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq=1</span><br><span class="line"></span><br><span class="line">下面是抓程序堆栈（没试过）：</span><br><span class="line">文管卡住的时候，</span><br><span class="line">1. 查询文管 PID </span><br><span class="line">2. gcore <span class="variable">$PID</span> 生成 core.xxx 文件</span><br><span class="line">3. gdb dde-file-manager core.xxxx</span><br></pre></td></tr></table></figure>

<h2 id="休眠变重启问题："><a href="#休眠变重启问题：" class="headerlink" title="休眠变重启问题："></a><strong>休眠变重启问题：</strong></h2><p>系统安装中最后一次执行的update-initramfs动作是在chroot环境内,在chroot环境中执行是不会生成initrd&#x2F;conf&#x2F;conf.d&#x2F;zz-resume-auto文件，该文件用于记录休眠唤醒时的起点，必须在真机上执行update-initramfs时才会生成</p>
<p>该问题使用临时方案进行解决：将安装配置（用户、时区等）放在系统安装之后</p>
<p><a target="_blank" rel="noopener" href="https://gerrit.uniontech.com/plugins/gitiles/system-devel/iso-build-deepin/+/ae9276819d28e1e7dd63fd25950f026fe6331798">https://gerrit.uniontech.com/plugins/gitiles/system-devel/iso-build-deepin/+/ae9276819d28e1e7dd63fd25950f026fe6331798</a></p>
<p>该问题根因：安装器的配置流程放在了系统安装之前，V20上是安装完成之后才开始配置的</p>
<p><strong>wpa 打开log日志：</strong></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230323093436435.png" alt="image-20230323093436435"></p>
<h2 id="虚拟机搭建："><a href="#虚拟机搭建：" class="headerlink" title="虚拟机搭建："></a>虚拟机搭建：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libvirt0 libvirt-daemon libvirt-daemon-system qemu virt-manager bridge-utils libvirt-clients python-libvirt qemu-efi uml-utilities virtinst qemu-system</span><br></pre></td></tr></table></figure>

<h4 id="设置网络桥接"><a href="#设置网络桥接" class="headerlink" title="设置网络桥接"></a><strong>设置网络桥接</strong></h4><h6 id="首先：要停止网络服务"><a href="#首先：要停止网络服务" class="headerlink" title="首先：要停止网络服务"></a>首先：要停止网络服务</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop network-manager.service</span><br></pre></td></tr></table></figure>

<h6 id="其次：修改网络配置文件"><a href="#其次：修改网络配置文件" class="headerlink" title="其次：修改网络配置文件"></a>其次：修改网络配置文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>

<h6 id="手动设置ip"><a href="#手动设置ip" class="headerlink" title="手动设置ip"></a>手动设置ip</h6><p>请将以下代码复制到编辑的文件中，注意：IP等设置自己按照需要修改。不想手动设置ip可跳过这一步，使用下面自动获取ip的方法</p>
<p>auto lo</p>
<p>iface lo inet loopback</p>
<p>auto eth0</p>
<p>iface eth0 inet manual</p>
<p>auto br0</p>
<p>iface br0 inet static</p>
<p>address 192.168.200.130</p>
<p>network 192.168.200.0</p>
<p>netmask 255.255.255.0</p>
<p>broadcast 192.168.200.255</p>
<p>gateway 192.168.200.1</p>
<p>dns-nameservers 8.8.8.8</p>
<p>bridge_ports eth0</p>
<p>bridge_stp off</p>
<p>bridge_fd 0</p>
<p>bridge_maxwait 0</p>
<h6 id="自动从DHCP获取ip"><a href="#自动从DHCP获取ip" class="headerlink" title="自动从DHCP获取ip"></a>自动从DHCP获取ip</h6><p>请将一下代码复制到编辑的文件中</p>
<p>auto lo</p>
<p>iface lo inet loopback</p>
<p>#auto eth0</p>
<p>#iface eth0 inet manual</p>
<p>auto br0</p>
<p>iface br0 inet dhcp</p>
<p>bridge_ports eth0</p>
<p>bridge_stp off</p>
<p>bridge_fd 0</p>
<h6 id="最后：重新启动网络服务便可"><a href="#最后：重新启动网络服务便可" class="headerlink" title="最后：重新启动网络服务便可"></a>最后：重新启动网络服务便可</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start network-manager.service</span><br></pre></td></tr></table></figure>

<h6 id="启用虚拟网络-每次启动虚拟机报network相关错误就执行命令"><a href="#启用虚拟网络-每次启动虚拟机报network相关错误就执行命令" class="headerlink" title="启用虚拟网络(每次启动虚拟机报network相关错误就执行命令)"></a>启用虚拟网络(每次启动虚拟机报network相关错误就执行命令)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh net-start default</span><br></pre></td></tr></table></figure>

<h2 id="X11获取设备信息"><a href="#X11获取设备信息" class="headerlink" title="X11获取设备信息:"></a>X11获取设备信息:</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152658407.png" alt="image-20230324152658407"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152721451.png" alt="image-20230324152721451"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152537663.png" alt="image-20230324152537663"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152549668.png" alt="image-20230324152549668"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152559927.png" alt="image-20230324152559927"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152609252.png" alt="image-20230324152609252"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152622996.png" alt="image-20230324152622996"></p>
<p>这里上面的xcb_connection_t  里的fd应该是&#x2F;tmp&#x2F;.X11-unix&#x2F;x:</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324153059779.png" alt="image-20230324153059779"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324153336357.png" alt="image-20230324153336357"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152958599.png" alt="image-20230324152958599"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152829036.png" alt="image-20230324152829036"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324153538211.png" alt="image-20230324153538211"></p>
<h2 id="systemctl-is-enabled-返回-indirect-是什么意思？"><a href="#systemctl-is-enabled-返回-indirect-是什么意思？" class="headerlink" title="systemctl is-enabled 返回 indirect 是什么意思？"></a>systemctl is-enabled 返回 indirect 是什么意思？</h2><p>当你运行 <code>systemctl is-enabled &lt;unit&gt;</code>命令来检查指定的systemd服务单元的启用状态时，可能会得到”indirect”的结果。这表示指定的单元并没有直接启用，而是被其他服务单元所依赖而间接启用。</p>
<p>换句话说，如果一个服务单元A依赖于另一个服务单元B，并且B已经启用，那么A也会被间接地启用，即使它本身没有直接被启用。在这种情况下，当你运行 <code>systemctl is-enabled A</code>时，你会得到”indirect”的输出结果。</p>
<p>需要注意的是，间接启用并不意味着服务单元A可以独立地启动或停止。如果依赖于A的其他服务单元也被启用，那么A将保持运行状态。</p>
<h2 id="systemctl-enable-A-service后，开机启动后并没有启动A-service，只是起了A-socket，这是为什么？"><a href="#systemctl-enable-A-service后，开机启动后并没有启动A-service，只是起了A-socket，这是为什么？" class="headerlink" title="systemctl enable A.service后，开机启动后并没有启动A.service，只是起了A.socket，这是为什么？"></a>systemctl enable A.service后，开机启动后并没有启动A.service，只是起了A.socket，这是为什么？</h2><p>当你运行 <code>systemctl enable A.service</code>命令来启用一个systemd服务单元时，它将创建一个符号链接，指向启用的服务单元文件（通常是位于 <code>/etc/systemd/system</code>或 <code>/usr/lib/systemd/system</code>目录下的 <code>.service</code>文件）到 <code>/etc/systemd/system</code>目录下的一个目标文件（通常是 <code>/etc/systemd/system/multi-user.target.wants</code>目录下的符号链接）。这将导致服务单元在系统启动时自动启动。</p>
<p>然而，<strong>在某些情况下，systemd服务单元本身并不是实际需要自动启动的程序，而是一种被动的服务单元（例如，一个.socket文件），它监听一个端口并等待传入的连接请求。这种情况下，systemd会自动创建一个与服务单元文件同名的.socket文件，并将其链接到启用的服务单元文件（即创建一个 <code>A.socket -&gt; A.service</code>的符号链接）。</strong></p>
<p>因此，<strong>在你运行 <code>systemctl enable A.service</code>命令后，如果A.service是一个被动的服务单元，那么systemd将自动创建一个与之同名的.socket文件，并将其链接到A.service文件。在系统启动时，systemd会启动这个.socket文件并等待传入的连接请求，而不是直接启动A.service文件。如果你想要启动A.service，你可以手动运行 <code>systemctl start A.service</code>命令来启动它。</strong></p>
<h2 id="怎么判断service是一个被动的服务单元？"><a href="#怎么判断service是一个被动的服务单元？" class="headerlink" title="怎么判断service是一个被动的服务单元？"></a>怎么判断service是一个被动的服务单元？</h2><p>一般来说，可以通过查看systemd服务单元文件的内容来判断它是否是一个被动的服务单元。</p>
<p>被动的服务单元通常是 <code>.socket</code>或 <code>.path</code>类型的服务单元。<code>.socket</code>服务单元用于监听一个网络端口或一个文件系统中的套接字文件，等待传入的连接请求。<code>.path</code>服务单元用于监视一个文件系统中的路径，当指定的文件或目录发生变化时触发服务单元的启动。</p>
<p>而普通的服务单元则通常是 <code>.service</code>类型的服务单元，它是一种主动的服务单元，通常用于执行某些操作或运行某些程序。</p>
<p>因此，如果一个systemd服务单元文件的名称以 <code>.socket</code>或 <code>.path</code>结尾，那么它很可能是一个被动的服务单元。另外，你还可以查看服务单元文件的内容，查看其中的 <code>[Socket]</code>或 <code>[Path]</code>部分是否存在，以确认服务单元是否是被动的服务单元。</p>
<h2 id="这个服务是被动服务单元吗-？-从哪个地方可以看出？"><a href="#这个服务是被动服务单元吗-？-从哪个地方可以看出？" class="headerlink" title="这个服务是被动服务单元吗 ？ 从哪个地方可以看出？"></a>这个服务是被动服务单元吗 ？ 从哪个地方可以看出？</h2><p>[Unit]<br>Description&#x3D;PC&#x2F;SC Smart Card Daemon<br>Requires&#x3D;pcscd.socket<br>Documentation&#x3D;man:pcscd(8)</p>
<p>[Service]<br>ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;pcscd –foreground –auto-exit<br>ExecReload&#x3D;&#x2F;usr&#x2F;sbin&#x2F;pcscd –hotplug</p>
<p>[Install]<br>Also&#x3D;pcscd.socket</p>
<p>根据提供的systemd服务单元文件的内容，可以看出这是一个被动服务单元。原因如下：</p>
<ul>
<li>该服务单元文件的名称是 <code>pcscd.service</code>，而不是 <code>.socket</code>或 <code>.path</code>类型的服务单元文件。</li>
<li>在 <code>[Unit]</code>部分，它的描述（Description）是“PC&#x2F;SC Smart Card Daemon”，而不是“PC&#x2F;SC Smart Card Socket”或“PC&#x2F;SC Smart Card Path”等名称，这进一步说明它是一个服务而不是一个socket或path服务单元。</li>
<li><strong>在 <code>[Unit]</code>部分，它有一个 <code>Requires=pcscd.socket</code>的依赖项，这意味着它依赖于一个 <code>.socket</code>类型的服务单元，这通常是被动服务单元</strong>。</li>
<li>在 <code>[Install]</code>部分，它有一个**<code>Also=pcscd.socket</code>的指令，这意味着如果该服务单元被启用，也会同时启用与之同名的 <code>.socket</code>服务单元，这也是被动服务单元的标志之一**。</li>
</ul>
<p>综上所述，根据该服务单元文件的内容，可以判断它是一个被动服务单元，<strong>用于启动 <code>pcscd.socket</code>服务单元，监听一个网络端口，等待传入的连接请求</strong>。</p>
<h2 id="systemctl-enable-此服务会做什么？-enable之后开机对此服务会做什么"><a href="#systemctl-enable-此服务会做什么？-enable之后开机对此服务会做什么" class="headerlink" title="systemctl enable 此服务会做什么？ enable之后开机对此服务会做什么"></a>systemctl enable 此服务会做什么？ enable之后开机对此服务会做什么</h2><p><code>systemctl enable</code>命令用于将systemd服务单元设置为开机自动启动。具体来说，当你运行 <code>systemctl enable service_name</code>命令来启用一个systemd服务单元时，它会在 <code>/etc/systemd/system</code>目录下创建一个符号链接，指向该服务单元文件（通常是位于 <code>/etc/systemd/system</code>或 <code>/usr/lib/systemd/system</code>目录下的 <code>.service</code>文件）到 <code>/etc/systemd/system/multi-user.target.wants</code>目录下的一个目标文件（也是一个符号链接）。这将导致服务单元在系统启动时自动启动。</p>
<p>因此，当你运行 <code>systemctl enable service_name</code>命令来启用一个服务单元时，在系统下次启动时，systemd将自动启动该服务单元，以确保服务在系统启动后可用。这对于一些关键的系统服务，如网络服务、系统日志服务等非常重要，因为这些服务需要在系统启动时启动，以确保系统的正常运行。</p>
<p>总之，<code>systemctl enable</code>命令的作用是将指定的systemd服务单元设置为开机自动启动，以确保服务在系统启动时自动启动并运行。</p>
<p>[Unit]<br>Description&#x3D;PC&#x2F;SC Smart Card Daemon<br>Requires&#x3D;pcscd.socket<br>Documentation&#x3D;man:pcscd(8)</p>
<p>[Service]<br>ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;pcscd –foreground –auto-exit<br>ExecReload&#x3D;&#x2F;usr&#x2F;sbin&#x2F;pcscd –hotplug</p>
<p>[Install]<br>Also&#x3D;pcscd.socket</p>
<h2 id="systemctl-enable上面这个service会做什么？-enable之后开机此服务会启动吗"><a href="#systemctl-enable上面这个service会做什么？-enable之后开机此服务会启动吗" class="headerlink" title="systemctl enable上面这个service会做什么？ enable之后开机此服务会启动吗"></a>systemctl enable上面这个service会做什么？ enable之后开机此服务会启动吗</h2><p>这个服务单元的作用是启动 PC&#x2F;SC 智能卡守护进程（PC&#x2F;SC Smart Card Daemon），并将其设置为开机自动启动。</p>
<p>具体来说，在 <code>[Service]</code> 部分中，指定了 PC&#x2F;SC 智能卡守护进程的启动命令，即 <code>/usr/sbin/pcscd --foreground --auto-exit</code>。<code>--foreground</code>参数指定该服务以前台模式启动（即不以守护进程的方式运行），而 <code>--auto-exit</code> 参数指定当没有智能卡连接到系统时，服务将自动退出。</p>
<p>在 <code>[Install]</code> 部分中，使用了 <code>Also=pcscd.socket</code> 来指示 systemd 同时启用 <code>pcscd.socket</code> socket 服务单元。这表示当 <code>pcscd.service</code> 服务单元启动时，同时也会启动 <code>pcscd.socket</code> 服务单元。<code>pcscd.socket</code> 负责监听 PC&#x2F;SC 客户端的连接请求，因此 <code>pcscd.service</code> 是一个被动的服务单元，它依赖于 <code>pcscd.socket</code> 服务单元的启动，以接受客户端连接请求。</p>
<p>当你运行 <code>systemctl enable pcscd.service</code> 命令启用此服务单元时，它将在 <code>/etc/systemd/system/multi-user.target.wants</code> 目录下创建一个符号链接，指向该服务单元文件。这将导致 <code>pcscd.service</code> 服务单元在系统启动时自动启动，并同时启动 <code>pcscd.socket</code> 服务单元。</p>
<p>因此，如果你启用了 <code>pcscd.service</code> 服务单元，则在下次系统启动时，该服务将自动启动，并以前台模式运行 PC&#x2F;SC 智能卡守护进程，同时启动 <code>pcscd.socket</code> 服务单元，以便监听 PC&#x2F;SC 客户端的连接请求。</p>
<h2 id="audit审计："><a href="#audit审计：" class="headerlink" title="audit审计："></a>audit审计：</h2><p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-defining_audit_rules_and_controls">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-defining_audit_rules_and_controls</a></p>
<p>1、查看进程被谁杀死：</p>
<p>sudo apt install auditd<br>systemctl enable auditd.service<br>systemctl restart auditd.service<br>然后通过auditctrl添加规则： auditctl -a exit,always -F arch&#x3D;b64 -S kill -F a1&#x3D;9（好像auditctl -a exit,always -S kill就行了，-F参数表示额外匹配，这里选择匹配系统调用的第一个参数，参数内容是要监控进程的PID(这里要用16进制)。）<br>启动然后kill掉Python程序; 查看日志，即可发现kill发起的程序和用户；</p>
<p>sudo ausearch -sc kill</p>
<p>日志如下：</p>
<p>time-&gt;Thu Feb 24 04:00:08 2022</p>
<p>type&#x3D;PROCTITLE msg&#x3D;audit(1645675208.403:201): proctitle&#x3D;”htop”</p>
<p>type&#x3D;OBJ_PID msg&#x3D;audit(1645675208.403:201): opid&#x3D;40099 oauid&#x3D;1016 ouid&#x3D;1016 oses&#x3D;12951 obj&#x3D;&#x3D;unconfined ocomm&#x3D;”nvtop”</p>
<p>type&#x3D;SYSCALL msg&#x3D;audit(1645675208.403:201): arch&#x3D;c000003e syscall&#x3D;62 success&#x3D;yes exit&#x3D;0 a0&#x3D;9ca3 a1&#x3D;9 a2&#x3D;c1 a3&#x3D;8 items&#x3D;0 ppid&#x3D;45939 pid&#x3D;40129 auid&#x3D;1016 uid&#x3D;1016 gid&#x3D;1016 euid&#x3D;1016 suid&#x3D;1016 fsuid&#x3D;1016 egid&#x3D;1016 sgid&#x3D;1016 fsgid&#x3D;1016 tty&#x3D;pts4 ses&#x3D;18035 comm&#x3D;”htop” exe&#x3D;”&#x2F;usr&#x2F;bin&#x2F;htop” subj&#x3D;&#x3D;unconfined key&#x3D;(null)</p>
<p>type&#x3D;OBJ_PID 那一列是杀进程的命令（ocomm&#x3D;”nvtop” ）</p>
<p>type&#x3D;SYSCALL 那一列是kill的调用者详情和系统命名码（syscall&#x3D;62 ）</p>
<p>2、查看文件被谁删除</p>
<p>在&#x2F;etc&#x2F;audit&#x2F;rules.d&#x2F;audit.rules加上以下两行:<br>-a always,exit -F arch&#x3D;b32 -S unlink -S unlinkat -S rename -S renameat -S rmdir -k delete<br>-a always,exit -F arch&#x3D;b64 -S unlink -S unlinkat -S rename -S renameat -S rmdir -k delete</p>
<p>然后重启auditd服务:</p>
<p>systemctl restart auditd</p>
<p>检查规则是否生效:</p>
<p># auditctl -l<br>-a always,exit -F arch&#x3D;b32 -S unlink,rename,rmdir,unlinkat,renameat -F key&#x3D;delete<br>-a always,exit -F arch&#x3D;b64 -S rename,rmdir,unlink,unlinkat,renameat -F key&#x3D;delete</p>
<p>然后检查&#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log即可看到什么文件被什么程序删除</p>
<p>3、查看谁使用了某个文件</p>
<p>service auditd start</p>
<p>auditctl -w &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches -p rwxa         （-w表示使用watch功能， 要watch的文件为 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches， 观察的事件为文件的读写执行。通过man auditctl 可以知道， audit是通过内核里面hook open系统调用实现的该功能。， -W是删除）</p>
<p>ausearch -f &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</p>
<p>1.查看信息：<br>输入以下程序：</p>
<p>dmesg | egrep -i -B100 ‘killed process’<br>可以输出最近killed的信息。</p>
<p>2.设定kill优先度：<br>（1）完全关掉oom（不建议）：<br>sysctl vm.overcommit_memory&#x3D;2<br>echo “vm.overcommit_memory&#x3D;2” &gt;&gt; &#x2F;etc&#x2F;sysctl.conf<br>（2）出现 Out of memory之后重启：<br>sysctl vm.panic_on_oom&#x3D;1<br>sysctl kernel.panic&#x3D;X<br>echo “vm.panic_on_oom&#x3D;1” &gt;&gt; &#x2F;etc&#x2F;sysctl.conf<br>echo “kernel.panic&#x3D;X” &gt;&gt; &#x2F;etc&#x2F;sysctl.conf<br>（3）优先考虑kill这个进程：<br>sudo echo 10&gt;&#x2F;proc&#x2F;[PID]&#x2F;oom_adj<br>（4）尽量不去kill这个进程：<br>sudo echo -15&gt;&#x2F;proc&#x2F;[PID]&#x2F;oom_adj<br>（5）不会kill这个进程：<br>sudo echo -17&gt;&#x2F;proc&#x2F;[PID]&#x2F;oom_adj<br>oom_adj的值在-16 到 +15之间，值越高被kill的优先度越高。当该值为-17时，系统将不会杀死指定pid的进程，而-16~15则会使得进程的&#x2F;proc&#x2F;[pid]&#x2F;oom_adj值呈指数（）形式递增，即它们被杀掉的可能性呈指数递增。针对init（进程号为1）这个进程，无论该值设为多少都不会被杀。</p>
<p>3.若拒绝访问：<br>命令改为：</p>
<p>bash -c “echo ‘10’ | tee &#x2F;proc&#x2F;[PID]&#x2F;oom_adj”<br>bash -c “echo ‘-15’ | tee &#x2F;proc&#x2F;[PID]&#x2F;oom_adj”<br>bash -c “echo ‘-17’ | tee &#x2F;proc&#x2F;[PID]&#x2F;oom_adj”</p>
<h2 id="1-手动修改-etc-shadow中的用户密码"><a href="#1-手动修改-etc-shadow中的用户密码" class="headerlink" title="1.手动修改&#x2F;etc&#x2F;shadow中的用户密码"></a>1.<a target="_blank" rel="noopener" href="http://www.cppblog.com/mydriverc/archive/2009/10/09/98196.html?spm=a2c6h.12873639.article-detail.4.28085ae6QTkYWD">手动修改&#x2F;etc&#x2F;shadow中的用户密码</a></h2><p>&#x2F;etc&#x2F;shadow文件</p>
<p>第一字段：用户名（也被称为登录名），在&#x2F;etc&#x2F;shadow中，用户名和&#x2F;etc&#x2F;passwd 是相同的，这样就把passwd 和shadow中用的用户记录联系在一起；这个字段是非空的；<br>第二字段：密码（已被加密），这个字段是非空的；<br>第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），您可以通过passwd 来修改用户的密码，然后查看&#x2F;etc&#x2F;shadow中此字段的变化；<br>第四字段：两次修改口令间隔最少的天数；如果这个字段的值为空，帐号永久可用；</p>
<p>第五字段：两次修改口令间隔最多的天数；如果这个字段的值为空，帐号永久可用；</p>
<p>第六字段：提前多少天警告用户口令将过期；如果这个字段的值为空，帐号永久可用；</p>
<p>第七字段：在口令过期之后多少天禁用此用户；如果这个字段的值为空，帐号永久可用；</p>
<p>第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用；<br>第九字段：保留字段，目前为空，以备将来发展之用；</p>
<p>&#x2F;etc&#x2F;shadow中格式如下<br>#testaccount:<strong>$1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0</strong>:13402:0:99999:7:::<br>$1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0段为加密后的密码，$1$表示采用的是md5加密，acQMceF9$是简单的字符串，1SaCpG2qiKKA3eGolU4Fp0为加密后的密码</p>
<p>只要删除 $1$acQMceF9$1SaCpG2qiKKA3eGolU4Fp0 它后，就删除了密码</p>
<p>2.linux忘记登陆密码修改&#x2F;etc&#x2F;passwd也可以</p>
<p>很简单的一个技巧，给大家介绍一下<br>在这个界面 按任意键<br>按 e键(编辑命令之前启动)<br>选择第二项 在按e键(修改选定的命令在启动)<br>输入single (注意空格)进入单用户模式<br>选择b 启动<br>输入 vi &#x2F;etc&#x2F;passwd<br>root❌0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>光标移至x下面按delete 键 删除它<br>输入：x！<br>输入reboot重启<br>重启后你会发现 没让你输密码，破译成功</p>
<p>原理解释：<br>在 &#x2F;etc&#x2F;passwd 的文件里 保存着用户的信息文件 root❌0:0:Administrator:&#x2F;root:&#x2F;bin&#x2F;bash</p>
<p>在这一句中</p>
<p>root就是用户名，</p>
<p>x是密码标志，只是说明密码的存放位置，具体呢是放在&#x2F;etc&#x2F;passwd的 至于密码别想了 全 是密文保存，看不懂的</p>
<p>0 用户id号</p>
<p>0 组id号</p>
<p>administrator估计是我在装系统的时候，原来的名字没改（虚拟机默认用户名），是用户说 明的意思，</p>
<p>root 用户的家目录</p>
<p>&#x2F;bin&#x2F;bash 记录着用户登陆后所拥有的权限，即所拥有的shell</p>
<p>那么我们把密码标示删掉之后，自然就不会有问你密码的对话框了</p>
<p>当然</p>
<p>GRUB这个引导装载程序是可以设密码的</p>
<p>不过 设密码 我们可以光启 ，用安装光盘进入安全模式，在把密码清除</p>
<p>光启 是可以设BIOS密码的，</p>
<p>BIOS 密码是可以拆机箱 扣电池的</p>
<p>那这么说来 传说中的linux岂不是很不安全，通常所说的安全是基于网络的 ，意思是连接互联网后，对方通过网络途径入侵你的linux计算机是很困难的，这种破译的方法只是以防万一，在万一你忘记密码的时候使用的，至于物理安全，那就看你怎么保护了.</p>
<h1 id="gdb调试宏定义并显示宏定义的值"><a href="#gdb调试宏定义并显示宏定义的值" class="headerlink" title="gdb调试宏定义并显示宏定义的值"></a>gdb调试宏定义并显示宏定义的值</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjs0322/article/details/39666889">https://blog.csdn.net/zhangjs0322/article/details/39666889</a></p>
<p>编译时需添加-gdwarf-2和-g3两个参数。</p>
<p>加了-g3的参数后，gcc编译的时候，会将扩展的debug 信息编译进二进制文件里面，包括宏定义信息。</p>
<h2 id="Linux-ACL-access-control-list-访问控制权限列表"><a href="#Linux-ACL-access-control-list-访问控制权限列表" class="headerlink" title="Linux ACL(access control list)访问控制权限列表"></a>Linux ACL(access control list)访问控制权限列表</h2><p>在普通权限中，用户对文件只有三种身份，就是属主、属组和其他人；每种用户身份拥有读（read）、写（write）和执行（execute）三种权限。但是在实际工作中，这三种身份实在是不够用，我们举个例子来看看。</p>
<p>图 1 ACL权限简介</p>
<p><img src="file:////tmp/wps-altnt/ksohtml/wpsEA32ZO.png" alt="img"></p>
<p>图 1 的根目录中有一个 &#x2F;project 目录，这是班级的项目目录。班级中的每个学员都可以访问和修改这个目录，老师也需要对这个目录拥有访问和修改权限，其他班级的学员当然不能访问这个目录。需要怎么规划这个目录的权限呢？应该这样：老师使用 root 用户，作为这个目录的属主，权限为 rwx；班级所有的学员都加入 tgroup 组，使 tgroup 组作为 &#x2F;project 目录的属组，权限是 rwx；其他人的权限设定为 0。这样这个目录的权限就可以符合我们的项目开发要求了。</p>
<p>有一天，班里来了一位试听的学员 st，她必须能够访问 &#x2F;project 目录，所以必须对这个目录拥有 r 和 x 权限；但是她又没有学习过以前的课程，所以不能赋予她 w 权限，怕她改错了目录中的内容，所以学员 st 的权限就是 r-x。可是如何分配她的身份呢？变为属主？当然不行，要不 root 该放哪里？加入 tgroup 组？也不行，因为 tgroup 组的权限是 rwx，而我们要求学员 st 的权限是 r-x。如果把其他人的权限改为 r-x 呢？这样一来，其他班级的所有学员都可以访问 &#x2F;project 目录了。</p>
<p>当出现这种情况时，普通权限中的三种身份就不够用了。ACL 权限就是为了解决这个问题的。在使用 ACL 权限给用户 st 陚予权限时，st 既不是 &#x2F;project 目录的属主，也不是属组，仅仅赋予用户 st 针对此目录的 r-x 权限。这有些类似于 Windows 系统中分配权限的方式，单独指定用户并单独分配权限，这样就解决了用户身份不足的问题。</p>
<p>ACL是Access Control List（访问控制列表）的缩写，不过在Linux系统中，ACL用于设定用户针对文件的权限，而不是在交换路由器中用来控制数据访问的功能（类似于防火墙）。</p>
<p><strong>开启ACL权限****在 CentOS 6.x 系统中 ACL 权限默认是开启的，不需要手工开启。不过，如果你的操作系统不是 CentOS 6.x，那该如何查看 ACL 权限是否开启了呢？可以这样查看：</strong></p>
<p>[root@localhost ~]# mount</p>
<p>&#x2F;dev&#x2F;sda1 on &#x2F;boot type ext4 (rw)</p>
<p>&#x2F;dev&#x2F;sda3 on I type ext4 (rw)</p>
<p>…省略部分输出…</p>
<p>#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</p>
<p>[root@localhost ~]# dumpe2fs -h &#x2F;dev&#x2F;sda3</p>
<p>#dumpe2fs是查询指定分区文件系统详细信息的命令</p>
<p>…省略部分输出…</p>
<p>Default mount options: user_xattr acl</p>
<p>…省略部分输出…其中，dumpe2fs 命令可选的选项及其含义如下：</p>
<p>-h：仅显示超级块中的信息，而不显示磁盘块组的详细信息；</p>
<p>使用 mount 命令可以査看到系统中已经挂载的分区，而使用 dumpe2fs 命令可以査看到这个分区文件系统的详细信息。大家可以看到，我们的 ACL 权限是 &#x2F;dev&#x2F;sda3 分区的默认挂载选项，所以不需要手工挂载。</p>
<p>不过我的 Linux 系统如果没有默认挂载，则可以手工挂载吗？当然可以，执行如下命令：</p>
<p>[root@localhost ~]# mount -o remount, acl &#x2F;</p>
<p>#重新挂载根分区，并加入ACL权限使用 mount 命令重新挂载，并加入 ACL 权限。不过使用此命令是临时生效的。要想永久生效，需要修改 &#x2F;etc&#x2F;fstab 文件，命令如下：</p>
<p>[root@localhost ~]#vi &#x2F;etc&#x2F;fstab</p>
<p>UUID&#x3D;c2ca6f57-b15c-43ea-bca0-f239083d8bd2 &#x2F;ext4 defaults, acl 1 1</p>
<p>#加入ACL权限</p>
<p>[root@localhost ~]# mount -o remount &#x2F;</p>
<p>#重新挂载文件系统或重启系统，使修改生效在你需要开启 ACL 权限的分区行上（也就是说 ACL 权限针对的是分区），手工在 defaults 后面加入”，acl”即可永久在此分区中开启 ACL 权限。</p>
<p><strong>ACL权限设置</strong></p>
<p><strong>1) ACL权限管理命令****我们知道了 ACL 权限的作用，也知道了如何开启 ACL 权限，接下来学习如何査看和设定 ACL 权限。命令如下：</strong></p>
<p>[root@localhost ~]# getfacle 文件名</p>
<p>#查看ACL权限</p>
<p>[root@localhost ~]# setfacl 选项 文件名</p>
<p>#设定ACL权限选项：</p>
<p>-m：设定 ACL 权限。如果是给予用户 ACL 权限，则使用”u:用户名：权限”格式赋予；如果是给予组 ACL 权限，则使用”g:组名：权限” 格式赋予；</p>
<p>-x：删除指定的 ACL 权限；</p>
<p>-b：删除所有的 ACL 权限；</p>
<p>-d：设定默认 ACL 权限。只对目录生效，指目录中新建立的文件拥有此默认权限；</p>
<p>-k：删除默认 ACL 权限；</p>
<p>-R：递归设定 ACL 权限。指设定的 ACL 权限会对目录下的所有子文件生效；</p>
<p><strong>2) 给用户和用户组添加ACL权限****举个例子，就来看看图 1 中的权限怎么分配。我们要求 root 是 &#x2F;project 目录的属主，权限是 rwx；tgroup 是此目录的属组，tgroup 组中拥有班级学员 zhangsan 和 lisi，权限是 rwx；其他人的权限是 0。这时，试听学员 st 来了，她的权限是 r-x。我们来看具体的分配命令。</strong></p>
<p>[root@localhost ~]# useradd zhangsan</p>
<p>[root@localhost ~]# useradd lisi</p>
<p>[root@localhost ~]# useradd st</p>
<p>[root@localhost ~]# groupadd tgroup</p>
<p>#添加需要试验的用户和用户组，省略设定密码的过程</p>
<p>[root@localhost ~]# mkdir &#x2F;project #建立需要分配权限的目录</p>
<p>[root@localhost ~]# chown root:tgroup &#x2F;project&#x2F;</p>
<p>#改变&#x2F;project目录的属主和属组</p>
<p>[root@localhost ~]# chmod 770 &#x2F;project&#x2F;</p>
<p>#指定&#x2F;project目录的权限</p>
<p>[root@localhost ~]# ll -d &#x2F;project&#x2F;</p>
<p>drwxrwx— 2 root tgroup 4096 1月19 04:21 &#x2F;project&#x2F;</p>
<p>#查看一下权限，已经符合要求了</p>
<p>#这时st学员来试听了，如何给她分配权限</p>
<p>[root@localhost ~]# setfacl -m u:st:rx &#x2F;project&#x2F;</p>
<p>#给用户st赋予r-x权限，使用”u:用户名：权限” 格式</p>
<p>[root@localhost &#x2F;]# cd &#x2F;</p>
<p>[root@localhost &#x2F;]# ll -d project&#x2F;</p>
<p>drwxrwx—+ 3 root tgroup 4096 1月19 05:20 project&#x2F;</p>
<p>#使用ls-l査询时会发现，在权限位后面多了一个”+”，表示此目录拥有ACL权限</p>
<p>[root@localhost &#x2F;]# getfacl project</p>
<p>#查看&#x2F;prpject目录的ACL权限</p>
<p>#file: project &lt;-文件名</p>
<p>#owner: root &lt;-文件的属主</p>
<p>#group: tgroup &lt;-文件的属组</p>
<p>user::rwx &lt;-用户名栏是空的，说明是属主的权限</p>
<p>user:st:r-x &lt;-用户st的权限</p>
<p>group::rwx &lt;-组名栏是空的，说明是属组的权限</p>
<p>mask::rwx &lt;-mask权限</p>
<p>other::— &lt;-其他人的权限大家可以看到，st 用户既不是 &#x2F;prpject 目录的属主、属组，也不是其他人，我们单独给 st 用户分配了 r-x 权限。这样分配权限太方便了，完全不用先辛苦地规划用户身份了。</p>
<p>我想给用户组赋予 ACL 权限可以吗？当然可以，命令如下：</p>
<p>[root@localhost &#x2F;]# groupadd tgroup2</p>
<p>#添加测试组</p>
<p>[root@localhost &#x2F;]# setfacl -m g:tgroup2:rwx project&#x2F;</p>
<p>#为组tgroup2纷配ACL权限，使用”g:组名:权限”格式</p>
<p>[root@localhost &#x2F;]# ll -d project&#x2F;</p>
<p>drwxrwx—+ 2 root tgroup 4096 1月19 04:21 project&#x2F;</p>
<p>#属组并没有更改</p>
<p>[root@localhost &#x2F;]# getfacl project&#x2F;</p>
<p>#file: project&#x2F;</p>
<p>#owner: root</p>
<p>#group: tgroup</p>
<p>user::rwx</p>
<p>user:st:r-x</p>
<p>group::rwx</p>
<p>group:tgroup2:rwx &lt;-用户组tgroup2拥有了rwx权限</p>
<p>mask::rwx</p>
<p>other::–</p>
<p><strong>3) 最大有效权限mask****mask 是用来指定最大有效权限的。mask 的默认权限是 rwx，如果我给 st 用户赋予了 r-x 的 ACL 权限，mj 需要和 mask 的 rwx 权限”相与”才能得到 st 的真正权限，也就是 r-x “相与”rwxtj 出的值是 r-x，所以 st 用户拥有 r-x 权限。</strong></p>
<p>如果把 mask 的权限改为 r–，和 st 用户的权限相与，也就是 r–”相与”r-x 得出的值是 r–，st 用户的权限就会变为只读。大家可以这么理解：用户和用户组所设定的权限必须在 mask 权限设定的范围之内才能生效，mask权限就是最大有效权限。</p>
<p>不过我们一般不更改 mask 权限，只要给予 mask 最大权限 rwx，那么任何权限和 mask 权限相与，得出的值都是权限本身。也就是说，我们通过给用户和用户组直接赋予权限，就可以生效，这样做更直观。</p>
<p>补充：逻辑与运算的运算符是”and”。可以理解为生活中所说的”并且”。也就是相与的两个值都为真，结果才为真；有一个值为假，与的结果就为假。比如 A 相与 B，结果入表 2 所示。</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody><tr>
<td>真</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>真</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>真</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>假</td>
<td>假</td>
</tr>
</tbody></table>
<p>那么两个权限相与和上面的结果类似，我们以读（r）权限为例，结果如表 3 所示。</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>所以，”rwx”相与”r-x”，结果是”r-x”；”r–”相与”r-x”，结果是”r–”。</p>
<p>修改最大有效权限的命令如下：</p>
<p>[root@localhost &#x2F;]# setfacl -m m:rx project&#x2F;</p>
<p>#设定mask权限为r-x，使用”m:权限”格式</p>
<p>[root@localhost &#x2F;]# getfacl project&#x2F;</p>
<p>#file：project&#x2F;</p>
<p>#owner：root</p>
<p>#group：tgroup</p>
<p>user::rwx</p>
<p>group::rwx #effective:r-x</p>
<p>mask::r-x</p>
<p>#mask权限变为r-x</p>
<p>other::–</p>
<p><strong>4) 默认ACL权限和递归ACL权限****我们已经给 &#x2F;project 目录设定了 ACL 权限，那么，在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？我们试试吧。</strong></p>
<p>[root@localhost &#x2F;]# cd &#x2F;project&#x2F;</p>
<p>[root@localhost prq’ect]# touch abc</p>
<p>[root@localhost prq’ect]# mkdir d1</p>
<p>#在&#x2F;project目录中新建了abc文件和d1目录</p>
<p>[root@localhost project]#ll</p>
<p>总用量4</p>
<p>-rw-r–r– 1 root root 01月19 05:20 abc</p>
<p>drwxr-xr-x 2 root root 4096 1月19 05:20 d1</p>
<p>#这两个新建立的文件权限位后面并没有”+”，表示它们没有继承ACL权限子文件 abc 和子目录 d1 因为是后建立的，所以并没有继承父目录的 ACL 权限。当然，我们可以手工给这两个文件分配 ACL 权限，但是如果在目录中再新建文件，都要手工指定，则显得过于麻烦。这时就需要用到默认 ACL 权限。</p>
<p>默认 ACL 权限的作用是：如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。默认 ACL 权限只对目录生效。命令如下：</p>
<p>[root@localhost &#x2F;]# setfacl -m d:u:st:rx &#x2F;project&#x2F;</p>
<p>#使用”d:u:用户名：权限”格式设定默认ACL权限</p>
<p>[root@localhost project]# getfacl project&#x2F;</p>
<p># file: project&#x2F;</p>
<p># owner: root</p>
<p># group: tgroup</p>
<p>user:: rwx</p>
<p>user:st:r-x</p>
<p>group::rwx</p>
<p>group:tgroup2:rwx</p>
<p>mask::rwx</p>
<p>other::–</p>
<p>default:user::rwx &lt;-多出了default字段</p>
<p>default:user:st:r-x</p>
<p>default:group::rwx</p>
<p>default😷:rwx</p>
<p>default:other::–</p>
<p>[root@localhost &#x2F;]# cd project&#x2F;</p>
<p>[root@localhost project]# touch bcd</p>
<p>[root@localhost project]# mkdir d2</p>
<p>#新建子文件和子目录</p>
<p>[root@localhost project]# ll 总用量8</p>
<p>-rw-r–r– 1 root root 01月19 05:20 abc</p>
<p>-rw-rw—-+ 1 root root 01月19 05:33 bcd</p>
<p>drwxr-xr-x 2 root root 4096 1月19 05:20 d1</p>
<p>drwxrwx—+ 2 root root 4096 1月19 05:33 d2</p>
<p>#新建的bcd和d2已经继承了父目录的ACL权限大家发现了吗？原先的 abc 和 d1 还是没有 ACL 权限，因为默认 ACL 权限是针对新建立的文件生效的。</p>
<p>再说说递归 ACL 权限。递归是指父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p>
<p>[root@localhost project]# setfacl -m u:st:rx -R&#x2F;project&#x2F;</p>
<p>#-R递归</p>
<p>[root@localhost project]# ll</p>
<p>总用量8</p>
<p>-rw-r-xr–+ 1 root root 01月19 05:20 abc</p>
<p>-rw-rwx–+ 1 root root 01月19 05:33 bcd</p>
<p>drwxr-xr-x+ 2 root root 4096 1月19 05:20 d1</p>
<p>drwxrwx–+ 2 root root 4096 1月19 05:33 d2</p>
<p>#abc和d1也拥有了ACL权限总结一下：默认 ACL 权限指的是针对父目录中新建立的文件和目录会继承父目录的 ACL 权限，格式是”setfacl-m d:u:用户名：权限 文件名”；递归 ACL 权限指的是针对父目录中已经存在的所有子文件和子目录继承父目录的 ACL 权限，格式是”setfacl-m u:用户名： 权限 -R 文件名”。</p>
<p><strong>5) 删除ACL权限****我们来看看怎么删除 ACL 权限，命令如下：</strong></p>
<p>删除指定的ACL权限：</p>
<p>[root@localhost &#x2F;]# setfacl -x u:st &#x2F;project&#x2F;</p>
<p>#删除指定用户和用户组的ACL权限</p>
<p>[root@localhost &#x2F;]# getfacl project&#x2F;</p>
<p># file:project&#x2F;</p>
<p># owner: root</p>
<p># group: tgroup</p>
<p>user::rwx</p>
<p>group::rwx</p>
<p>group:tgroup2:rwx</p>
<p>mask::rwx</p>
<p>other::–</p>
<p>#st用户的权限已被删除</p>
<p>删除所有ACL权限：</p>
<p>[root@localhost &#x2F;]# setfacl -b project&#x2F;</p>
<p>#会删除文件的所有ACL权限</p>
<p>[root@localhost &#x2F;]# getfacl project&#x2F;</p>
<p>#file: project&#x2F;</p>
<p>#owner: root</p>
<p># group: tgroup</p>
<p>user::rwx</p>
<p>group::rwx</p>
<p>other::–</p>
<p>#所有ACL权限已被删除</p>
<h2 id="丁昊的笔记："><a href="#丁昊的笔记：" class="headerlink" title="丁昊的笔记："></a>丁昊的笔记：</h2><p>丁昊 2-3 20:16:37<br><a target="_blank" rel="noopener" href="https://note.youdao.com/s/Pc3xVfF3">https://note.youdao.com/s/Pc3xVfF3</a> PXE安装</p>
<p>丁昊 2-3 20:20:54<br><a target="_blank" rel="noopener" href="https://note.youdao.com/s/FuARzknP">https://note.youdao.com/s/FuARzknP</a></p>
<p>丁昊 2-3 20:21:18<br><a target="_blank" rel="noopener" href="https://note.youdao.com/s/EREk5WMt">https://note.youdao.com/s/EREk5WMt</a></p>
<p>丁昊 2-3 20:21:35<br><a target="_blank" rel="noopener" href="https://note.youdao.com/s/3CazyEHa">https://note.youdao.com/s/3CazyEHa</a></p>
<h2 id="Ubuntu-Tmux-启用鼠标滚动"><a href="#Ubuntu-Tmux-启用鼠标滚动" class="headerlink" title="Ubuntu Tmux 启用鼠标滚动"></a>Ubuntu Tmux 启用鼠标滚动</h2><p>在Ubuntu上使用Tmux是一件非常舒服的事，但有时使用鼠标滚轮时，和平时使用终端的习惯不怎么一致，因此可以设置启用鼠标滚轮。<br>具体方式：<br>按完前缀ctrl+B后，再按冒号：进入命令行模式，<br>输入以下命令：</p>
<p>set -g mouse on<br>1<br>就启用了鼠标滚轮，可以通过鼠标直接选择不同的窗口，也可以上下直接翻页。</p>
<p>Tip<br>但在以上设置下，会发现无法用中键向 tmux 中复制文本，也无法将 tmux 中选择好的文本中键复制到系统其他应用程序中。<br>这里有一个 trick，那就是在 tmux 中不论选择还是复制时，都按住 Shift 键，你会发现熟悉的中键又回来了 ? 此外，还可以使用 Shift+Insert 快捷键将系统剪切板中的内容输入 tmux 中。 相对于 tmux 原生的选择模式（不加 shift 键），使用系统选择有个缺陷，即当一行内存在多个面板时，无法选择单个面板中的内容，这时就必须使用 tmux 自带的复制粘贴系统了。</p>
<h2 id="qemu虚拟机的配置文件："><a href="#qemu虚拟机的配置文件：" class="headerlink" title="qemu虚拟机的配置文件："></a>qemu虚拟机的配置文件：</h2><p>在&#x2F;etc&#x2F;libvirt目录下，可以修改虚拟机路径等</p>
<p>修改好了好需要执行systemctl restart libvirtd.service</p>
<h2 id="my-log-info"><a href="#my-log-info" class="headerlink" title="my_log_info:"></a>my_log_info:</h2><p>void my_log_info(const char <em>fmt,…)<br>{<br>    FILE</em> g_log_FP &#x3D; fopen(“&#x2F;tmp&#x2F;1.log”,”a”);<br>  if (g_log_FP !&#x3D; 0) {<br>      va_list ap;<br>      va_start(ap, fmt);<br>      vfprintf(g_log_FP, fmt, ap);<br>      va_end(ap);<br>      &#x2F;&#x2F;fflush(g_log_FP);<br>      fclose(g_log_FP);<br>  }<br>}</p>
<p>udev读block块设备容量读的是&#x2F;sys&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:0a.0&#x2F;virtio3&#x2F;block&#x2F;vdb&#x2F;size 这种接口文件</p>
<h1 id="C语言打印函数堆栈方法"><a href="#C语言打印函数堆栈方法" class="headerlink" title="C语言打印函数堆栈方法"></a>C语言打印函数堆栈方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#define STACK_SIZE 32</span><br><span class="line"></span><br><span class="line">static void printStack(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	void *trace[STACK_SIZE];</span><br><span class="line">	size_t size = backtrace(trace, STACK_SIZE);</span><br><span class="line">	char **symbols = (char **)backtrace_symbols(trace,size);</span><br><span class="line">	size_t i = 0;</span><br><span class="line">	for(; i&lt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%ld---&gt;%s\n&quot;, i, symbols[i]);           //注意这个得改</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">static void printStack(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	void *trace[STACK_SIZE];</span><br><span class="line">	size_t size = backtrace(trace, STACK_SIZE);</span><br><span class="line">	char **symbols = (char **)backtrace_symbols(trace,size);</span><br><span class="line">	size_t i = 0;</span><br><span class="line">	for(; i&lt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		log_error(&quot;ly---%ld---&gt;%s\n&quot;, i, symbols[i]);           //注意这个得改</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">static void printStack(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    void *bt[50];</span><br><span class="line">    int bt_size;</span><br><span class="line">    char **bt_syms;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    bt_size = backtrace(bt, 50);</span><br><span class="line">    bt_syms = backtrace_symbols(bt, bt_size);</span><br><span class="line">    for (i = 0; i &lt; bt_size; i++) &#123;</span><br><span class="line">        Dl_info info;</span><br><span class="line">        if (dladdr(bt[i], &amp;info) &amp;&amp; info.dli_sname) &#123;</span><br><span class="line">            log_error(&quot;ly---%d--%s&quot;, i, info.dli_sname);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log_error(&quot;ly---%d--%s\n&quot;, i,bt_syms[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(bt_syms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个错误提示是缺少动态链接库 libdl.so.2，可以尝试LDFLAGS加上 -ldl 参数来链接该库(改完之后得删掉原来的二进制文件)</p>
<p>#include &lt;execinfo.h&gt;<br>#include &lt;dlfcn.h&gt;</p>
<p>static void print_backtrace(void) {<br>    void *bt[50];<br>    int bt_size;<br>    char **bt_syms;<br>    int i;</p>
<pre><code>bt_size = backtrace(bt, 50);
bt_syms = backtrace_symbols(bt, bt_size);
for (i = 0; i &lt; bt_size; i++) &#123;
    Dl_info info;
    if (dladdr(bt[i], &amp;info) &amp;&amp; info.dli_sname) &#123;
        printf(&quot;%s\n&quot;, info.dli_sname);
    &#125; else &#123;
        printf(&quot;???\n&quot;);
    &#125;
&#125;
free(bt_syms);
</code></pre>
<p>}</p>
<h2 id="内网仓库："><a href="#内网仓库：" class="headerlink" title="内网仓库："></a>内网仓库：</h2><p><a target="_blank" rel="noopener" href="http://pools.uniontech.com/desktop-professional/pool/main/p/python-netaddr/">http://pools.uniontech.com/desktop-professional/pool/main/p/python-netaddr/</a></p>
<h2 id="blkid-l-t-“UUID-9cd72106-5e81-4860-a8e1-8285bc74a5ac”-o-device"><a href="#blkid-l-t-“UUID-9cd72106-5e81-4860-a8e1-8285bc74a5ac”-o-device" class="headerlink" title="blkid -l -t “UUID&#x3D;9cd72106-5e81-4860-a8e1-8285bc74a5ac” -o device"></a>blkid -l -t “UUID&#x3D;9cd72106-5e81-4860-a8e1-8285bc74a5ac” -o device</h2><p>首先读&#x2F;run&#x2F;blkid&#x2F;blkid.tab缓存文件，如果能找到直接返回</p>
<p>否则通过realpath(&#x2F;dev&#x2F;disk&#x2F;by-uuid&#x2F;af467362-9f82-4219-808f-fb23ca11a4ea)找到对应设备</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403181751780.png" alt="image-20230403181751780"></p>
<p>realpath实际就是找&#x2F;dev&#x2F;disk&#x2F;by-uuid&#x2F;af467362-9f82-4219-808f-fb23ca11a4ea的软链接</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403181959316.png" alt="image-20230403181959316"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403181616823.png" alt="image-20230403181616823"></p>
<h2 id="usr-lib-klibc-bin-fstype原理："><a href="#usr-lib-klibc-bin-fstype原理：" class="headerlink" title="&#x2F;usr&#x2F;lib&#x2F;klibc&#x2F;bin&#x2F;fstype原理："></a>&#x2F;usr&#x2F;lib&#x2F;klibc&#x2F;bin&#x2F;fstype原理：</h2><p>搞一个静态数组然后遍历它，如果ip-&gt;identify能识别独处的 超级块，则返回对应的ip-&gt;name</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403184655148.png" alt="image-20230403184655148"></p>
<p>这里针对”ext4”进行讨论：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403184849483.png" alt="image-20230403184849483"></p>
<h2 id="查看某个版本号对应的包的所以已安装包："><a href="#查看某个版本号对应的包的所以已安装包：" class="headerlink" title="查看某个版本号对应的包的所以已安装包："></a>查看某个版本号对应的包的所以已安装包：</h2><p>dpkg -l | grep 2:2.1.0-5+deb10u2 | cut -d ‘ ‘ -f 3|cut -d “:” -f 1 | xargs</p>
<p>或dpkg -l | grep 2:2.1.0-5+deb10u2 | cut -d ‘ ‘ -f 3|cut -d “:” -f 1 | awk ‘{printf(“%s “, $0)} END {printf(“\n”)}’</p>
<h2 id="查看dpkg安装过程的详细信息："><a href="#查看dpkg安装过程的详细信息：" class="headerlink" title="查看dpkg安装过程的详细信息："></a>查看dpkg安装过程的详细信息：</h2><p>dpkg -D333</p>
<h2 id="报这个错的解决方法-PCIe-Bus-Error"><a href="#报这个错的解决方法-PCIe-Bus-Error" class="headerlink" title="报这个错的解决方法(PCIe Bus Error):"></a>报这个错的解决方法(PCIe Bus Error):</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/001f50367ab88be4530f8ac6919d9c26-16805757986091.jpg" alt="001f50367ab88be4530f8ac6919d9c26"></p>
<p>pcie 物理链路层报错，应该是硬件出问题了</p>
<p>解决方法：启动参数加pcie_aspm&#x3D;off</p>
<h2 id="开启coredump："><a href="#开启coredump：" class="headerlink" title="开启coredump："></a>开启coredump：</h2><p>建议卸载systemd-coredump使用内核自带的core机制（systemd-coredump不会生成systemd的core文件）</p>
<p>ulimit -c unlimited</p>
<p>（测试发现在普通用户下开启coredump和在root下开启coredump 时，在不同用户下执行ulimit -c以及coredumpctl list显示的值不一样，如下面所示，所以最好在所有用户下都执行下）</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406134935521.png" alt="image-20230406134935521"></p>
<p>如果进程已经在运行，可以设置指定pid的limit</p>
<ol>
<li>临时修改进程 <code>prlimit --core=unlimited -p $PID</code></li>
</ol>
<p>注：上面的配置重启会失效，所以要永久启用请参考下面的：</p>
<p>2、永久修改</p>
<p>对于普通用户进程来说，编辑&#x2F;etc&#x2F;profile最后加上ulimit -c unlimited就行了，但是测试对root不生效。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406135145550.png" alt="image-20230406135145550"></p>
<p>注：实测对root用户，用户名替换为*未生效，所以最好是显示指定为root</p>
<p>最好改成这样<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230418165303527.png" alt="image-20230418165303527"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*               soft    core            unlimited</span><br><span class="line">*               hard    core            unlimited</span><br><span class="line">root            soft    core            unlimited</span><br><span class="line">root            hard    core            unlimited</span><br><span class="line">message+            soft    core            unlimited</span><br><span class="line">message+            hard    core            unlimited</span><br><span class="line">message            soft    core            unlimited</span><br><span class="line">message            hard    core            unlimited</span><br></pre></td></tr></table></figure>

<p>这个文件是由pam_limits模块来读的：</p>
<p>#define _PAM_LOGFILE “&#x2F;var&#x2F;run&#x2F;pam-debug.log”</p>
<p>其他dbus-daemon服务等实测要修改这个地方：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230508112416923.png" alt="image-20230508112416923"></p>
<h2 id="设置格式："><a href="#设置格式：" class="headerlink" title="设置格式："></a>设置格式：</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;/tmp/core-%e-%p-%t&quot;</span> &gt;<span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern</span><br><span class="line">echo <span class="string">&quot;/home/uos/systemd-coredumps/core-%e-%p-%t&quot;</span> &gt;<span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern</span><br><span class="line">echo <span class="string">&quot;/var/log/systemd-coredumps/core-%e-%p-%t&quot;</span> &gt;<span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern</span><br></pre></td></tr></table></figure>

<p>这样更改只是临时的，要想永久生效可以通过更改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">添加一行：kernel.core_pattern=/home/uos/systemd-coredumps/core-%e-%p-%t</span><br><span class="line">kernel.core_pattern=/var/log/systemd-coredumps/core-%e-%p-%t</span><br></pre></td></tr></table></figure>

<p>对于dbus-daemon:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑 /etc/sysctl.conf 文件来设置 /proc/sys/fs/suid_dumpable 参数。在该文件中添加以下行：</span><br><span class="line">fs.suid_dumpable = 1</span><br></pre></td></tr></table></figure>

<p>如果您已经设置了 <code>ulimit -c unlimited</code>，并且仍然没有生成core文件，可能是因为以下原因之一：</p>
<ol>
<li><p>内核可能已被配置为禁用生成core文件。您可以检查 <code>/proc/sys/kernel/core_pattern</code>文件的内容，以确定是否已禁用生成core文件。如果它是空的或包含“|&#x2F;bin&#x2F;false”之类的命令，则生成core文件已被禁用。您可以使用以下命令将其重置为默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">echo &quot;/var/core/core-%e-%p-%t.core&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></li>
<li><p>如果 <code>/var/core</code>目录不存在或不可写，则core文件可能无法写入。您可以尝试手动创建该目录，并确保该目录对当前用户可写。</p>
</li>
<li><p>如果您正在运行Systemd，可能需要将 <code>LimitCORE=infinity</code>添加到 <code>/etc/systemd/system.conf</code>或相关服务单元中。这将确保系统可以生成无限制大小的core文件。</p>
</li>
<li><p>另外，如果dbus-daemon在使用journald作为日志记录系统，则它可能会导致core文件无法生成。您可以尝试将其配置为使用其他日志记录系统，如syslog。</p>
</li>
</ol>
<p>如果您已经检查了以上问题，并且仍然无法生成core文件，请尝试重新启动系统，然后再次测试dbus-daemon崩溃是否可以生成core文件。</p>
<h3 id="查看某个运行中的进程对应的limit配置："><a href="#查看某个运行中的进程对应的limit配置：" class="headerlink" title="查看某个运行中的进程对应的limit配置："></a>查看某个运行中的进程对应的limit配置：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/xxx/limits</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230418163539455.png" alt="image-20230418163539455"></p>
<h2 id="使用内核机制生成coredump的过程："><a href="#使用内核机制生成coredump的过程：" class="headerlink" title="使用内核机制生成coredump的过程："></a>使用内核机制生成coredump的过程：</h2><p>1、堆栈如下（do_coredump）：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230419105156862.png" alt="image-20230419105156862"></p>
<p>查看lz4的core文件：</p>
<p>1-先解压：lz4 -d sss.lz4 sss<br>2-查看：gdb 程序名 -c sss</p>
<h2 id="gvfs"><a href="#gvfs" class="headerlink" title="gvfs:"></a>gvfs:</h2><p>GVfs 是 GIO（GLib 中可用的库）的用户空间虚拟文件系统实现。GVfs 带有一组后端，包括垃圾支持、SFTP、SMB、HTTP、DAV 和<a target="_blank" rel="noopener" href="https://wiki.gnome.org/Projects/gvfs/schemes">许多其他后端</a>。GVfs 还包含用于实现卷监视器和持久元数据存储的 GIO 模块。还有 FUSE 支持，为不使用 GIO 的应用程序提供对 GVfs 文件系统的有限访问。</p>
<p>报这个问题的代码逻辑：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406145744572.png" alt="image-20230406145744572"></p>
<p>首先借助gdb可以知道代码路径是在这里：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151216996.png" alt="image-20230406151216996"></p>
<p>这个gvfsd的作用：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151534579.png" alt="image-20230406151534579"></p>
<p>这里是有on_name_lost打印的日志，条件为connection&#x3D;&#x3D;NULL</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406145835453.png" alt="image-20230406145835453"></p>
<p>显然是g_bus_own_name失败时执行的on_name_lost</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151314396.png" alt="image-20230406151314396"></p>
<p>g_bus_own_name(代码在glib2.0中)</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151715089.png" alt="image-20230406151715089"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406152046796.png" alt="image-20230406152046796"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151835335.png" alt="image-20230406151835335"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406153412509.png" alt="image-20230406153412509"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g_bus_own_name&#123;client-&gt;name_lost_handler = name_lost_handler;</span><br><span class="line">			  &#123;g_bus_get（connection_get_cb）&#123;g_task_new&#123;task-&gt;callback = callback</span><br><span class="line">											&#123;connection = get_uninitialized_connection</span><br><span class="line">											&#123;g_async_initable_init_async（反正这里会执行connection_get_cb），g_async_initable_init_async中初始化的结果由g_bus_get_finish返回（这是代码的注释）</span><br><span class="line">connection_get_cb中，当client-&gt;connection返回为NULL时，执行call_lost_handler,进而打印该错误日志</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406145725352.png" alt="image-20230406145725352"></p>
<p>g_bus_get_finish返回的 是res-&gt;result.pointer</p>
<h2 id="通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）："><a href="#通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）：" class="headerlink" title="通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）："></a>通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-572921.png" alt="img"></p>
<h2 id="切换java："><a href="#切换java：" class="headerlink" title="切换java："></a>切换java：</h2><p>sudo update-alternatives –config java</p>
<h2 id="切换iptable："><a href="#切换iptable：" class="headerlink" title="切换iptable："></a>切换iptable：</h2><p>sudo update-alternatives –set iptables &#x2F;usr&#x2F;sbin&#x2F;iptables-legacy</p>
<p>当然用上面那个也行</p>
<p>xtables-nft — iptables using nftables kernel api</p>
<p>DESCRIPTION<br>       xtables-nft  are  versions  of iptables that use the nftables API.  This is a set of tools to help the system administrator mi‐<br>       grate the ruleset from iptables(8), ip6tables(8), arptables(8), and ebtables(8) to nftables(8).</p>
<p>xtables-legacy — iptables using old getsockopt&#x2F;setsockopt-based kernel api</p>
<p>DESCRIPTION<br>       xtables-legacy  are  the  original versions of iptables that use old getsockopt&#x2F;setsockopt-based kernel interface.  This kernel<br>       interface has some limitations, therefore iptables can also be used with the newer nf_tables based API.  See xtables-nft(8) for<br>       information about the xtables-nft variants of iptables.</p>
<h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><p><strong>iptables命令</strong> 是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。</p>
<p><a target="_blank" rel="noopener" href="https://wangchujiang.com/linux-command/c/iptables.html">https://wangchujiang.com/linux-command/c/iptables.html</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-t, --table table 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通用匹配：源地址目标地址的匹配</span></span><br><span class="line">-p：指定要匹配的数据包协议类型；</span><br><span class="line">-s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。</span><br><span class="line">-d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。</span><br><span class="line">-i, --in-interface [!] &lt;网络接口name&gt; ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，&quot;!&quot; 表示取反。</span><br><span class="line">-o, --out-interface [!] &lt;网络接口name&gt; ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看管理命令</span></span><br><span class="line">-L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">规则管理命令</span></span><br><span class="line">-A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。</span><br><span class="line">-I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。</span><br><span class="line">-D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。</span><br><span class="line">-R num：Replays替换/修改第几条规则</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">链管理命令（这都是立即生效的）</span></span><br><span class="line">-P, --policy chain target ：为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的。</span><br><span class="line">-F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。</span><br><span class="line">-N, --new-chain chain 用指定的名字创建一个新的链。</span><br><span class="line">-X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。</span><br><span class="line">-E, --rename-chain old-chain new-chain ：用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响。</span><br><span class="line">-Z, --zero [chain] ：把指定链，或者表中的所有链上的所有计数器清零。</span><br><span class="line"></span><br><span class="line">-j, --jump target &lt;指定目标&gt; ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。</span><br><span class="line">-h：显示帮助信息；</span><br></pre></td></tr></table></figure>

<h2 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-P</td>
<td>设置默认策略:iptables -P INPUT (DROP</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I</td>
<td>num 在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D</td>
<td>num 删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP&#x2F;MASK，加叹号”!”表示除这个IP外。</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-i</td>
<td>网卡名称 匹配从这块网卡流入的数据</td>
</tr>
<tr>
<td>-o</td>
<td>网卡名称 匹配从这块网卡流出的数据</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议,如tcp,udp,icmp</td>
</tr>
<tr>
<td>–dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>–sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody></table>
<h4 id="命令选项输入顺序"><a href="#命令选项输入顺序" class="headerlink" title="命令选项输入顺序"></a>命令选项输入顺序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.iptables.info/en/structure-of-iptables.html#NATTABLE">NAT 表</a>：</p>
<blockquote>
<p>该表应该只用于不同数据包上的 NAT（网络地址转换）。换句话说，它应该只用于转换数据包的源字段或目标字段。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.iptables.info/en/structure-of-iptables.html#FILTERTABLE">过滤表</a>：</p>
<blockquote>
<p>过滤表主要用于过滤数据包。我们可以匹配数据包并以我们想要的任何方式过滤它们。这是我们实际对数据包采取行动并查看它们包含的内容并根据其内容丢弃或接受它们的地方。当然我们也可以做事前过滤；然而，这个特定的表是设计过滤的地方。</p>
<p>filter 的 FORWARD 链只被转发的数据包（来自网络和出去到网络的数据包）遍历，即你的计算机就像一个路由器，而 nat 的 PREROUTING 链被两个转发的数据包遍历目的是本地主机的数据包和数据包。</p>
<p>您应该仅使用 nat 的 PREROUTING 来更改数据包的目标地址，而过滤器的 FORWARD 仅用于过滤（丢弃&#x2F;接受数据包）。</p>
</blockquote>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>规则链名包括(也被称为五个钩子函数（hook functions）)：</p>
<ul>
<li><strong>INPUT链</strong> ：处理输入数据包。</li>
<li><strong>OUTPUT链</strong> ：处理输出数据包。</li>
<li><strong>FORWARD链</strong> ：处理转发数据包。</li>
<li><strong>PREROUTING链</strong> ：用于目标地址转换（DNAT）。</li>
<li><strong>POSTOUTING链</strong> ：用于源地址转换（SNAT）。</li>
</ul>
<h4 id="防火墙的策略"><a href="#防火墙的策略" class="headerlink" title="防火墙的策略"></a>防火墙的策略</h4><p>防火墙策略一般分为两种，一种叫 <code>通</code>策略，一种叫 <code>堵</code>策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，<code>所以通，是要全通，而堵，则是要选择</code>。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。</p>
<p>我们现在用的比较多个功能有3个：</p>
<ol>
<li>filter 定义允许或者不允许的，只能做在3个链上：INPUT ，FORWARD ，OUTPUT</li>
<li>nat 定义地址转换的，也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING</li>
<li>mangle功能:修改报文原数据，是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li>
</ol>
<p>我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记&#x2F;修改内容的。而防火墙标记，其实就是靠mangle来实现的。</p>
<p>小扩展:</p>
<ul>
<li>对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT</li>
<li>对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING</li>
<li>而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li>
</ul>
<p>iptables&#x2F;netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。</p>
<p>iptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。</p>
<p>注意：规则的次序非常关键，<code>谁的规则越严格，应该放的越靠前</code>，而检查规则的时候，是按照从上往下的方式进行检查的。</p>
<p>表名包括：</p>
<ul>
<li><strong>raw</strong> ：高级功能，如：网址过滤。</li>
<li><strong>mangle</strong> ：数据包修改（QOS），用于实现服务质量。</li>
<li><strong>nat</strong> ：地址转换，用于网关路由器。</li>
<li><strong>filter</strong> ：包过滤，用于防火墙规则。</li>
</ul>
<p>动作包括：</p>
<ul>
<li><strong>ACCEPT</strong> ：接收数据包。</li>
<li><strong>DROP</strong> ：丢弃数据包。</li>
<li><strong>REDIRECT</strong> ：重定向、映射、透明代理。</li>
<li><strong>SNAT</strong> ：源地址转换。</li>
<li><strong>DNAT</strong> ：目标地址转换。</li>
<li><strong>MASQUERADE</strong> ：IP伪装（NAT），用于ADSL。</li>
<li><strong>LOG</strong> ：日志记录。</li>
<li><strong>SEMARK</strong> : 添加SEMARK标记以供网域内强制访问控制（MAC）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓</span><br><span class="line"> ┌───────────────┐           ┃    Network    ┃</span><br><span class="line"> │ table: filter │           ┗━━━━━━━┳━━━━━━━┛</span><br><span class="line"> │ chain: INPUT  │◀────┐             │</span><br><span class="line"> └───────┬───────┘     │             ▼</span><br><span class="line">         │             │   ┌───────────────────┐</span><br><span class="line">  ┌      ▼      ┐      │   │ table: nat        │</span><br><span class="line">  │local process│      │   │ chain: PREROUTING │</span><br><span class="line">  └             ┘      │   └─────────┬─────────┘</span><br><span class="line">         │             │             │</span><br><span class="line">         ▼             │             ▼              ┌─────────────────┐</span><br><span class="line">┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅    │     ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      │table: nat       │</span><br><span class="line"> Routing decision      └───── outing decision ─────▶│chain: PREROUTING│</span><br><span class="line">┅┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅┅          ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      └────────┬────────┘</span><br><span class="line">         │                                                   │</span><br><span class="line">         ▼                                                   │</span><br><span class="line"> ┌───────────────┐                                           │</span><br><span class="line"> │ table: nat    │           ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅               │</span><br><span class="line"> │ chain: OUTPUT │    ┌─────▶ outing decision ◀──────────────┘</span><br><span class="line"> └───────┬───────┘    │      ┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅</span><br><span class="line">         │            │              │</span><br><span class="line">         ▼            │              ▼</span><br><span class="line"> ┌───────────────┐    │   ┌────────────────────┐</span><br><span class="line"> │ table: filter │    │   │ chain: POSTROUTING │</span><br><span class="line"> │ chain: OUTPUT ├────┘   └──────────┬─────────┘</span><br><span class="line"> └───────────────┘                   │</span><br><span class="line">                                     ▼</span><br><span class="line">                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓</span><br><span class="line">                             ┃    Network    ┃</span><br><span class="line">                             ┗━━━━━━━━━━━━━━━┛</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="清空当前的所有规则和计数"><a href="#清空当前的所有规则和计数" class="headerlink" title="清空当前的所有规则和计数"></a>清空当前的所有规则和计数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -F  # 清空所有的防火墙规则</span><br><span class="line">iptables -X  # 删除用户自定义的空链</span><br><span class="line">iptables -Z  # 清空计数</span><br></pre></td></tr></table></figure>

<h4 id="配置允许ssh端口连接"><a href="#配置允许ssh端口连接" class="headerlink" title="配置允许ssh端口连接"></a>配置允许ssh端口连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求</span></span><br></pre></td></tr></table></figure>

<h4 id="允许本地回环地址可以正常使用"><a href="#允许本地回环地址可以正常使用" class="headerlink" title="允许本地回环地址可以正常使用"></a>允许本地回环地址可以正常使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许</span></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br></pre></td></tr></table></figure>

<h4 id="设置默认的规则"><a href="#设置默认的规则" class="headerlink" title="设置默认的规则"></a>设置默认的规则</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -P INPUT DROP # 配置默认的不让进</span><br><span class="line">iptables -P FORWARD DROP # 默认的不允许转发</span><br><span class="line">iptables -P OUTPUT ACCEPT # 默认的可以出去</span><br></pre></td></tr></table></figure>

<h4 id="配置白名单"><a href="#配置白名单" class="headerlink" title="配置白名单"></a>配置白名单</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT  # 允许机房内网机器可以访问</span><br><span class="line">iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT  # 允许机房内网机器可以访问</span><br><span class="line">iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口</span><br></pre></td></tr></table></figure>

<h4 id="开启相应的服务端口"><a href="#开启相应的服务端口" class="headerlink" title="开启相应的服务端口"></a>开启相应的服务端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来</span><br></pre></td></tr></table></figure>

<h4 id="保存规则到配置文件中"><a href="#保存规则到配置文件中" class="headerlink" title="保存规则到配置文件中"></a>保存规则到配置文件中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line">cat /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>

<h4 id="列出已设置的规则"><a href="#列出已设置的规则" class="headerlink" title="列出已设置的规则"></a>列出已设置的规则</h4><blockquote>
<p>iptables -L [-t 表名] [链名]</p>
</blockquote>
<ul>
<li>四个表名 <code>raw</code>，<code>nat</code>，<code>filter</code>，<code>mangle</code></li>
<li>五个规则链名 <code>INPUT</code>、<code>OUTPUT</code>、<code>FORWARD</code>、<code>PREROUTING</code>、<code>POSTROUTING</code></li>
<li>filter表包含 <code>INPUT</code>、<code>OUTPUT</code>、<code>FORWARD</code>三个规则链</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -t nat                  # 列出 nat 上面的所有规则</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           ^ -t 参数指定，必须是 raw， nat，filter，mangle 中的一个</span></span><br><span class="line">iptables -L -t nat  --line-numbers  # 规则带编号</span><br><span class="line">iptables -L INPUT</span><br><span class="line"></span><br><span class="line">iptables -L -nv  # 查看，这个列表看起来更详细</span><br></pre></td></tr></table></figure>

<h4 id="清除已有规则"><a href="#清除已有规则" class="headerlink" title="清除已有规则"></a>清除已有规则</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -F INPUT  # 清空指定链 INPUT 上面的所有规则</span><br><span class="line">iptables -X INPUT  # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。</span><br><span class="line">                   # 如果没有指定链名，则会删除该表中所有非内置的链。</span><br><span class="line">iptables -Z INPUT  # 把指定链，或者表中的所有链上的所有计数器清零。</span><br></pre></td></tr></table></figure>

<h4 id="删除已添加的规则"><a href="#删除已添加的规则" class="headerlink" title="删除已添加的规则"></a>删除已添加的规则</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一条规则</span></span><br><span class="line">iptables -A INPUT -s 192.168.1.5 -j DROP</span><br></pre></td></tr></table></figure>

<p>将所有iptables以序号标记显示，执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure>

<p>比如要删除INPUT里序号为8的规则，执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 8</span><br></pre></td></tr></table></figure>

<h4 id="开放指定的端口"><a href="#开放指定的端口" class="headerlink" title="开放指定的端口"></a>开放指定的端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行</span><br><span class="line">iptables -A OUTPUT -j ACCEPT         #允许所有本机向外的访问</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    #允许访问22端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT    #允许ftp服务的21端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT    #允许FTP服务的20端口</span><br><span class="line">iptables -A INPUT -j reject       #禁止其他未允许的规则访问</span><br><span class="line">iptables -A FORWARD -j REJECT     #禁止其他未允许的规则访问</span><br></pre></td></tr></table></figure>

<h4 id="屏蔽IP"><a href="#屏蔽IP" class="headerlink" title="屏蔽IP"></a>屏蔽IP</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP  # 屏蔽恶意主机（比如，192.168.0.8</span><br><span class="line">iptables -I INPUT -s 123.45.6.7 -j DROP       #屏蔽单个IP的命令</span><br><span class="line">iptables -I INPUT -s 123.0.0.0/8 -j DROP      #封整个段即从123.0.0.1到123.255.255.254的命令</span><br><span class="line">iptables -I INPUT -s 124.45.0.0/16 -j DROP    #封IP段即从123.45.0.1到123.45.255.254的命令</span><br><span class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP    #封IP段即从123.45.6.1到123.45.6.254的命令是</span><br></pre></td></tr></table></figure>

<h4 id="指定数据包出去的网络接口"><a href="#指定数据包出去的网络接口" class="headerlink" title="指定数据包出去的网络接口"></a>指定数据包出去的网络接口</h4><p>只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -o eth0</span><br></pre></td></tr></table></figure>

<h4 id="查看已添加的规则"><a href="#查看已添加的规则" class="headerlink" title="查看已添加的规则"></a>查看已添加的规则</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n -v</span><br><span class="line">Chain INPUT (policy DROP 48106 packets, 2690K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"> 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line"> 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>

<h4 id="启动网络转发规则"><a href="#启动网络转发规则" class="headerlink" title="启动网络转发规则"></a>启动网络转发规则</h4><p>公网 <code>210.14.67.7</code>让内网 <code>192.168.188.0/24</code>上网</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127</span><br></pre></td></tr></table></figure>

<h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>本机的 2222 端口映射到内网 虚拟机的22 端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222  -j DNAT --to-dest 192.168.188.115:22</span><br></pre></td></tr></table></figure>

<h4 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h4><p>比如，我们要过滤所有TCP连接中的字符串 <code>test</code>，一旦出现它我们就终止这个连接，我们可以这么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m string --algo kmp --string &quot;test&quot; -j REJECT --reject-with tcp-reset</span><br><span class="line">iptables -L</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Chain INPUT (policy ACCEPT)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target     prot opt <span class="built_in">source</span>               destination</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">REJECT     tcp  --  anywhere             anywhere            STRING match <span class="string">&quot;test&quot;</span> ALGO name kmp TO 65535 reject-with tcp-reset</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Chain FORWARD (policy ACCEPT)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target     prot opt <span class="built_in">source</span>               destination</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Chain OUTPUT (policy ACCEPT)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target     prot opt <span class="built_in">source</span>               destination</span></span><br></pre></td></tr></table></figure>

<h4 id="阻止Windows蠕虫的攻击"><a href="#阻止Windows蠕虫的攻击" class="headerlink" title="阻止Windows蠕虫的攻击"></a>阻止Windows蠕虫的攻击</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string &quot;cmd.exe&quot;</span><br></pre></td></tr></table></figure>

<h4 id="防止SYN洪水攻击"><a href="#防止SYN洪水攻击" class="headerlink" title="防止SYN洪水攻击"></a>防止SYN洪水攻击</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT</span><br></pre></td></tr></table></figure>

<h4 id="添加SECMARK记录"><a href="#添加SECMARK记录" class="headerlink" title="添加SECMARK记录"></a>添加SECMARK记录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -A INPUT -p tcp --src 192.168.1.2 --dport 443 -j SECMARK --selctx system_u:object_r:myauth_packet_t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向从 192.168.1.2:443 以TCP方式发出到本机的包添加MAC安全上下文 system_u:object_r:myauth_packet_t</span></span><br></pre></td></tr></table></figure>

<h2 id="查看iptables-加入规则的流程大概是这样的："><a href="#查看iptables-加入规则的流程大概是这样的：" class="headerlink" title="查看iptables 加入规则的流程大概是这样的："></a>查看iptables 加入规则的流程大概是这样的：</h2><p>1、执行命令后，iptabls通过一个netlink socket像内核发送获取rules的命令，内核返回一个rules list，iptables保存到一个cache_list中， 然后iptables再将新的规则加进去放到h-&gt;obj_list中，然后再通过构建一个msg再通过socket发送给内核，如果有错误再保存給 h-&gt;err_list.</p>
<h2 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h2><blockquote>
<p>用iptables搭建一套强大的安全防护盾 <a target="_blank" rel="noopener" href="http://www.imooc.com/learn/389">http://www.imooc.com/learn/389</a></p>
</blockquote>
<p>iptables: linux 下应用层防火墙工具</p>
<p>iptables 5链: 对应 Hook point netfilter: linux 操作系统核心层内部的一个数据包处理模块 Hook point: 数据包在 netfilter 中的挂载点; <code>PRE_ROUTING / INPUT / OUTPUT / FORWARD / POST_ROUTING</code></p>
<p>iptables &amp; netfilter <img src="http://7xq89b.com1.z0.glb.clouddn.com/netfilter&iptables.jpg" alt="img"></p>
<p>iptables 4表5链 <img src="http://7xq89b.com1.z0.glb.clouddn.com/iptables-data-stream.jpg" alt="img"></p>
<p>iptables rules <img src="http://7xq89b.com1.z0.glb.clouddn.com/iptables-rules.jpg" alt="img"></p>
<ul>
<li>4表</li>
</ul>
<p><strong>filter</strong>: 访问控制 &#x2F; 规则匹配 <strong>nat</strong>: 地址转发 mangle &#x2F; raw</p>
<ul>
<li>规则</li>
</ul>
<p>数据访问控制: ACCEPT &#x2F; DROP &#x2F; REJECT 数据包改写(nat -&gt; 地址转换): snat &#x2F; dnat 信息记录: log</p>
<h2 id="使用场景实例"><a href="#使用场景实例" class="headerlink" title="使用场景实例"></a>使用场景实例</h2><ul>
<li>场景一</li>
</ul>
<p>开放 tcp 10-22&#x2F;80 端口 开放 icmp 其他未被允许的端口禁止访问</p>
<p>存在的问题: 本机无法访问本机; 本机无法访问其他主机</p>
<ul>
<li>场景二</li>
</ul>
<p>ftp: 默认被动模式(服务器产生随机端口告诉客户端, 客户端主动连接这个端口拉取数据) vsftpd: 使 ftp 支持主动模式(客户端产生随机端口通知服务器, 服务器主动连接这个端口发送数据)</p>
<ul>
<li>场景三</li>
</ul>
<p>允许外网访问: web http -&gt; 80&#x2F;tcp; https -&gt; 443&#x2F;tcp mail smtp -&gt; 25&#x2F;tcp; smtps -&gt; 465&#x2F;tcp pop3 -&gt; 110&#x2F;tcp; pop3s -&gt; 995&#x2F;tcp imap -&gt; 143&#x2F;tcp</p>
<p>内部使用: file nfs -&gt; 123&#x2F;udp samba -&gt; 137&#x2F;138&#x2F;139&#x2F;445&#x2F;tcp ftp -&gt; 20&#x2F;21&#x2F;tcp remote ssh -&gt; 22&#x2F;tcp sql mysql -&gt; 3306&#x2F;tcp oracle -&gt; 1521&#x2F;tcp</p>
<ul>
<li>场景四</li>
</ul>
<p>nat 转发</p>
<ul>
<li>场景五</li>
</ul>
<p>防CC攻击</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -F -A -D # list flush append delete</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景一</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT # 允许 tcp 80 端口</span><br><span class="line">iptables -I INPUT -p tcp --dport 10:22 -j ACCEPT # 允许 tcp 10-22 端口</span><br><span class="line">iptables -I INPUT -p icmp -j ACCEPT # 允许 icmp</span><br><span class="line">iptables -A INPUT -j REJECT # 添加一条规则, 不允许所有</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化场景一</span></span><br><span class="line">iptables -I INPUT -i lo -j ACCEPT # 允许本机访问</span><br><span class="line">iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许访问外网</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -s 10.10.188.233 -j ACCEPT # 只允许固定ip访问80</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景二</span></span><br><span class="line">vi /etc/vsftpd/vsftpd.conf # 使用 vsftpd 开启 ftp 主动模式</span><br><span class="line">port_enable=yes</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">iptables -I INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line"></span><br><span class="line">vi /etc/vsftpd/vsftpd.conf # 建议使用 ftp 被动模式</span><br><span class="line">pasv_min_port=50000</span><br><span class="line">pasv_max_port=60000</span><br><span class="line">iptables -I INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 50000:60000 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还可以使用 iptables 模块追踪来自动开发对应的端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景三</span></span><br><span class="line">iptables -I INPUT -i lo -j ACCEPT # 允许本机访问</span><br><span class="line">iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许访问外网</span><br><span class="line">iptables -I INPUT -s 10.10.155.0/24 -j ACCEPT # 允许内网访问</span><br><span class="line">iptables -I INPUT -p tcp -m multiport --dports 80,1723 -j ACCEPT # 允许端口, 80 -&gt; http, 1723 -&gt; vpn</span><br><span class="line">iptables -A INPUT -j REJECT # 添加一条规则, 不允许所有</span><br><span class="line"></span><br><span class="line">iptables-save # 保存设置到配置文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景四</span></span><br><span class="line">iptables -t nat -L # 查看 nat 配置</span><br><span class="line"></span><br><span class="line">iptables -t nat -A POST_ROUTING -s 10.10.177.0/24 -j SNAT --to 10.10.188.232 # SNAT</span><br><span class="line">vi /etc/sysconfig/network # 配置网关</span><br><span class="line"></span><br><span class="line">iptables -t nat -A POST_ROUTING -d 10.10.188.232 -p tcp --dport 80 -j DNAT --to 10.10.177.232:80 # DNAT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">场景五</span></span><br><span class="line">iptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 100 -j REJECT # 限制并发连接访问数</span><br><span class="line">iptables -I INPUT -m limit --limit 3/hour --limit-burst 10 -j ACCEPT # limit模块; --limit-burst 默认为5</span><br></pre></td></tr></table></figure>

<h1 id="iptables-legacy-与-iptables-nft-的关系与区别"><a href="#iptables-legacy-与-iptables-nft-的关系与区别" class="headerlink" title="iptables-legacy 与 iptables-nft 的关系与区别"></a><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#iptables-legacy-%E4%B8%8E-iptables-nft-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB">iptables-legacy 与 iptables-nft 的关系与区别</a></h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#%E5%8C%BA%E5%88%AB">区别</a></h2><ul>
<li>iptables-legacy 调用的是 iptables kernel API，iptables-nft 调用的是 nftables kernel API，所以它们的规则在不同内核模块中管理，nft 命令只读取 nftables 内核模块中的规则，所以 nft list ruleset 只能看到 iptables-nft 配置的规则。</li>
</ul>
<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#%E5%85%B1%E5%90%8C%E7%82%B9">共同点</a></h2><ul>
<li>都兼容 iptables 命令配置规则的语法。</li>
<li>匹配报文逻辑共用的同一份代码(xtables match)，nft 配置的规则才会用 nftables match。</li>
</ul>
<h2 id="与-iptables-命令的关系"><a href="#与-iptables-命令的关系" class="headerlink" title="与 iptables 命令的关系"></a><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#%E4%B8%8E-iptables-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB">与 iptables 命令的关系</a></h2><ul>
<li>通常在支持 nftables 的发行版中才会有 iptables-legacy 与 iptables-nft，而 iptables 命令本身是个软链，用户可以选择在两这者之间切换。</li>
<li>iptables-legacy 等同于不支持 nftables 发行版的 iptables 命令，即传统的 iptables。</li>
<li>较新发行版往往将 iptables 软链到 iptables-nft。</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></h2><ul>
<li>当系统支持 iptables-nft 时，可以取代 iptables-legacy。</li>
<li>不要两者混用，避免混淆。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------------+     +--------------+     +--------------+</span><br><span class="line">|   iptables   |     |   iptables   |     |     nft      |   USER</span><br><span class="line">|    legacy    |     |     nft      |     |  (nftables)  |   SPACE</span><br><span class="line">+--------------+     +--------------+     +--------------+</span><br><span class="line">       |                          |         |</span><br><span class="line">====== | ===== KERNEL API ======= | ======= | =====================</span><br><span class="line">       |                          |         |</span><br><span class="line">+--------------+               +--------------+</span><br><span class="line">|   iptables   |               |   nftables   |              KERNEL</span><br><span class="line">|      API     |               |     API      |              SPACE</span><br><span class="line">+--------------+               +--------------+</span><br><span class="line">             |                    |         |</span><br><span class="line">             |                    |         |</span><br><span class="line">          +--------------+        |         |     +--------------+</span><br><span class="line">          |   xtables    |--------+         +-----|   nftables   |</span><br><span class="line">          |    match     |                        |    match     |</span><br><span class="line">          +--------------+                        +--------------+</span><br></pre></td></tr></table></figure>

<p>安装配置阶段进入tty配置用户以及修改默认启动程序的操作步骤<br>1 安装完成后不要重启<br>2 切tty2 crtl+alt+F2<br>3 lsblk -f 查看roota的设备节点名,本例中是sdd3<br>4 sudo mkdir &#x2F;target<br>5 cd &#x2F;target<br>6 sudo mount &#x2F;dev&#x2F;sdd3 &#x2F;target 将roota挂载到新建的target<br>7 sudo chroot &#x2F;target<br>8 passwd root 修改root密码</p>
<h2 id="切wayland"><a href="#切wayland" class="headerlink" title="切wayland :"></a>切wayland :</h2><p>1、下载dde-dconfig-editor</p>
<p>2、修改 &#x2F;usr&#x2F;share&#x2F;dsg&#x2F;configs&#x2F;org.deepin.dde.lightdm-deepin-greeter&#x2F;org.deepin.dde.lightdm-deepin-greeter.json</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406174135280.png" alt="image-20230406174135280"></p>
<h2 id="解压live系统："><a href="#解压live系统：" class="headerlink" title="解压live系统："></a>解压live系统：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406173901628.png" alt="image-20230406173901628"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406173935523.png" alt="image-20230406173935523"></p>
<p>简单来说就3点:<br>\1. 在live系统中更新httpfs2并执行update-initramfs -u更新initrd<br>\2. 更新的initrd文件拷贝出来覆盖&#x2F;var&#x2F;www&#x2F;html&#x2F;iso&#x2F;live&#x2F;initrd.lz<br>\3. 重新压缩filesystem.squashfs并覆盖&#x2F;var&#x2F;www&#x2F;html&#x2F;iso&#x2F;live&#x2F;下的同名文件</p>
<h2 id="查询socket"><a href="#查询socket" class="headerlink" title="查询socket:"></a>查询socket:</h2><p>netstat -nalp</p>
<p>sudo netstat -nalp | grep “&#x2F;run&#x2F;systemd&#x2F;private”</p>
<h2 id="调试使用某个so文件的进程："><a href="#调试使用某个so文件的进程：" class="headerlink" title="调试使用某个so文件的进程："></a>调试使用某个so文件的进程：</h2><p>如果你想调试调用libinput库的进程，首先需要找到正在调用libinput的进程。可以使用命令 <code>lsof</code> 和 <code>grep</code> 来查找正在使用libinput库的进程，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">sudo lsof -n | grep libinput</span><br></pre></td></tr></table></figure>

<p>该命令会列出所有正在使用libinput库的进程及其对应的PID和文件描述符。接下来，使用GDB调试这个进程的话，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code</span><br><span class="line">sudo gdb -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;pid&gt;</code> 是你要调试的进程的PID。这会启动GDB并附加到指定的进程上。</p>
<p>通过上面的过程可以发现控制鼠标、触摸板等是被Xorg调用的</p>
<p>#0  0x00007f033060c168 in tp_palm_detect (tp&#x3D;0x3374be0, t&#x3D;0x33751a0, time&#x3D;1085585244) at ..&#x2F;src&#x2F;evdev-mt-touchpad.c:1043<br>#1  0x00007f033060d7f2 in tp_process_state (tp&#x3D;0x3374be0, time&#x3D;1085585244) at ..&#x2F;src&#x2F;evdev-mt-touchpad.c:1789<br>#2  0x00007f033060dbde in tp_handle_state (tp&#x3D;0x3374be0, time&#x3D;1085585244) at ..&#x2F;src&#x2F;evdev-mt-touchpad.c:1915<br>#3  0x00007f033060dcf3 in tp_interface_process (dispatch&#x3D;0x3374be0, device&#x3D;0x336f8c0, e&#x3D;0x7f02f37fcca0, time&#x3D;1085585244) at ..&#x2F;src&#x2F;evdev-mt-touchpad.c:1967<br>#4  0x00007f03305fe2dc istn evdev_process_event (device&#x3D;0x336f8c0, e&#x3D;0x7f02f37fcca0) at ..&#x2F;src&#x2F;evdev.c:873<br>#5  0x00007f03305fe321 in evdev_device_dispatch_one (device&#x3D;0x336f8c0, ev&#x3D;0x7f02f37fcca0) at ..&#x2F;src&#x2F;evdev.c:881<br>#6  0x00007f03305fe506 in evdev_device_dispatch (data&#x3D;0x336f8c0) at ..&#x2F;src&#x2F;evdev.c:940<br>#7  0x00007f03305f82bc in libinput_dispatch (libinput&#x3D;0x32f9b80) at ..&#x2F;src&#x2F;libinput.c:2070<br>#8  0x00007f033066ea18 in  () at &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;modules&#x2F;input&#x2F;libinput_drv.so<br>#9  0x000000000059b913 in  ()<br>#10 0x000000000059df01 in  ()<br>#11 0x000000000059b75e in  ()<br>#12 0x00007f0361147fa3 in start_thread (arg&#x3D;<code>&lt;optimized out&gt;</code>) at pthread_create.c:486<br>#13 0x00007f036107663f in clone () at ..&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;x86_64&#x2F;clone.S:95</p>
<p>使用手掌控制触摸板会进入这里然后goto out</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417110045540.png" alt="image-20230417110045540"></p>
<p>#0  0x00007f033060b02f in tp_process_absolute (tp&#x3D;0x3374be0, e&#x3D;0x7f02f37fcca0, time&#x3D;2035521967) at ..&#x2F;src&#x2F;evdev-mt-touchpad.c:509<br>#1  0x00007f033060dc93 in tp_interface_process (dispatch&#x3D;0x3374be0, device&#x3D;0x336f8c0, e&#x3D;0x7f02f37fcca0, time&#x3D;2035521967) at ..&#x2F;src&#x2F;evdev-mt-touchpad.c:1956<br>#2  0x00007f03305fe2dc in evdev_process_event (device&#x3D;0x336f8c0, e&#x3D;0x7f02f37fcca0) at ..&#x2F;src&#x2F;evdev.c:873<br>#3  0x00007f03305fe321 in evdev_device_dispatch_one (device&#x3D;0x336f8c0, ev&#x3D;0x7f02f37fcca0) at ..&#x2F;src&#x2F;evdev.c:881<br>#4  0x00007f03305fe506 in evdev_device_dispatch (data&#x3D;0x336f8c0) at ..&#x2F;src&#x2F;evdev.c:940<br>#5  0x00007f03305f82bc in libinput_dispatch (libinput&#x3D;0x32f9b80) at ..&#x2F;src&#x2F;libinput.c:2070<br>#6  0x00007f033066ea18 in  () at &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;modules&#x2F;input&#x2F;libinput_drv.so<br>#7  0x000000000059b913 in  ()<br>#8  0x000000000059df01 in  ()<br>#9  0x000000000059b75e in  ()<br>#10 0x00007f0361147fa3 in start_thread (arg&#x3D;<code>&lt;optimized out&gt;</code>) at pthread_create.c:486<br>#11 0x00007f036107663f in clone () at ..&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;x86_64&#x2F;clone.S:95</p>
<h3 id="libinput防误触配置："><a href="#libinput防误触配置：" class="headerlink" title="libinput防误触配置："></a>libinput防误触配置：</h3><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417151650132.png" alt="image-20230417151650132"></p>
<p>但是我看代码里默认是开启的，应该不需要开</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417151757687.png" alt="image-20230417151757687"></p>
<h2 id="禁用域管："><a href="#禁用域管：" class="headerlink" title="禁用域管："></a>禁用域管：</h2><p>systemctl disable system-udcp-daemon.service 和 systemctl –user disable session-udcp-daemon.service</p>
<h2 id="获取是否是笔记本："><a href="#获取是否是笔记本：" class="headerlink" title="获取是否是笔记本："></a>获取是否是笔记本：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417165322081.png" alt="image-20230417165322081"></p>
<p>代码来自 libdframeworkdbus2库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline const char* strempty(const char *s) &#123;</span><br><span class="line"></span><br><span class="line">        return s ?: &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="service文件拒绝手动启动："><a href="#service文件拒绝手动启动：" class="headerlink" title="service文件拒绝手动启动："></a>service文件拒绝手动启动：</h2><p>放在【Unit】下</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230419102130173.png" alt="image-20230419102130173"></p>
<h2 id="systemd-service-依赖"><a href="#systemd-service-依赖" class="headerlink" title="systemd service 依赖:"></a>systemd service 依赖:</h2><h3 id="一、自动依赖"><a href="#一、自动依赖" class="headerlink" title="一、自动依赖"></a>一、自动依赖</h3><h4 id="1、隐含依赖"><a href="#1、隐含依赖" class="headerlink" title="1、隐含依赖"></a>1、隐含依赖</h4><p>下列依赖关系是自动隐含的：</p>
<p>设置了 Type&#x3D;dbus 的服务会自动添加 Requires&#x3D;dbus.socket 与 After&#x3D;dbus.socket 依赖。</p>
<p>基于套接字启动的服务会自动添加对关联的 .socket 单元的 After&#x3D; 依赖。 服务单元还会为所有在 Sockets&#x3D; 中列出的 .socket 单元自动添加 Wants&#x3D; 与 After&#x3D; 依赖。</p>
<p>还有一些 其他依赖关系是由 systemd.exec(5) 与 systemd.resource-control(5) 中的某些资源限制选项自动隐含添加的。</p>
<h4 id="2、默认依赖"><a href="#2、默认依赖" class="headerlink" title="2、默认依赖"></a>2、默认依赖</h4><p>除非明确设置了 DefaultDependencies&#x3D;no ，否则 service 单元将会自动添加下列依赖关系：</p>
<p>Requires&#x3D;sysinit.target, After&#x3D;sysinit.target, After&#x3D;basic.target, Conflicts&#x3D;shutdown.target, Before&#x3D;shutdown.target 。 这样可以确保普通的服务单元： (1)在基础系统启动完毕之后才开始启动，(2)在关闭系统之前先被干净的停止。 只有那些需要在系统启动的早期就必须启动的服务， 以及那些必须在关机动作的结尾才能停止的服务才需要设置 DefaultDependencies&#x3D;no 。</p>
<p>从同一个模版实例化出来的所有服务单元(单元名称中带有 “@” 字符)， 默认全部属于与模版同名的同一个 slice 单元(参见 systemd.slice(5))。 该同名 slice 一般在系统关机时，与所有模版实例一起停止。 如果你不希望像上面这样，那么可以在模版单元中明确设置 DefaultDependencies&#x3D;no ， 并且：要么在该模版文件中明确定义特定的 slice 单元(同样也要明确设置 DefaultDependencies&#x3D;no)、 要么在该模版文件中明确设置 Slice&#x3D;system.slice (或其他合适的 slice)。 参见 systemd.resource-control(5) 手册。</p>
<h3 id="systemd-service中的Before-和After-代表的含义是什么"><a href="#systemd-service中的Before-和After-代表的含义是什么" class="headerlink" title="systemd service中的Before&#x3D; 和After&#x3D;代表的含义是什么"></a>systemd service中的Before&#x3D; 和After&#x3D;代表的含义是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在systemd服务中，Before= 和After=用于定义服务之间的启动顺序。</span><br><span class="line"></span><br><span class="line">Before=用于指定一个服务应该在哪些服务之前启动。例如：</span><br><span class="line"></span><br><span class="line">Before=nginx.service httpd.service</span><br><span class="line">这将确保在启动nginx.service和httpd.service之前，该服务将被启动。</span><br><span class="line"></span><br><span class="line">相反，After=用于指定服务应该在哪些服务之后启动。例如：</span><br><span class="line"></span><br><span class="line">After=network.target syslog.target</span><br><span class="line">这将确保在network.target和syslog.target服务之后，该服务将被启动。</span><br><span class="line"></span><br><span class="line">需要注意的是，在同一级别的依赖关系中，Before和After并没有严格的先后顺序，因为systemd不保证在同一级别的依赖关系中按照任何特定的顺序启动服务。相反，它使用一种称为“启动、启用或激活控制”的机制来管理依赖性。</span><br></pre></td></tr></table></figure>

<h4 id="为什么systemd-machine-id-commit-service中明明设置了Before-sysinit-target-shutdown-target，但是systemctl-list-dependences却显示systemd-machine-id-commit-service依赖sysinit-target"><a href="#为什么systemd-machine-id-commit-service中明明设置了Before-sysinit-target-shutdown-target，但是systemctl-list-dependences却显示systemd-machine-id-commit-service依赖sysinit-target" class="headerlink" title="为什么systemd-machine-id-commit.service中明明设置了Before&#x3D;sysinit.target shutdown.target，但是systemctl list-dependences却显示systemd-machine-id-commit.service依赖sysinit.target"></a>为什么systemd-machine-id-commit.service中明明设置了Before&#x3D;sysinit.target shutdown.target，但是systemctl list-dependences却显示systemd-machine-id-commit.service依赖sysinit.target</h4><p>在 Systemd 中，服务的依赖关系是根据单元文件中声明的 Before 和 After 关键字来计算的。如果一个服务 A 声明了 Before&#x3D;B，那么在启动或停止服务 B 之前，服务 A 将被启动或停止。</p>
<p>然而，在显示服务的依赖关系时，Systemd 还会考虑单元文件中的其他信息，比如必需的<strong>配置文件和其他服务的启动状态</strong>等。这可能会导致某些服务与它们声明的依赖关系不一致，因为这些附加信息可能会修改启动顺序。</p>
<p>对于你提到的 systemd-machine-id-commit.service，尽管它声明了 Before&#x3D;sysinit.target shutdown.target，但它实际上需要在 sysinit.target 启动后才能运行，因为它需要读取 &#x2F;etc&#x2F;machine-id 文件并将其写入 &#x2F;var&#x2F;lib&#x2F;dbus&#x2F;machine-id 文件，这些文件都由 sysinit.target 提供。因此，Systemd 在计算依赖关系时将 systemd-machine-id-commit.service 视为依赖于 sysinit.target，即使 Before 关键字声明了相反的顺序。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230420164920843.png" alt="image-20230420164920843"></p>
<p>总之，单元文件中的 Before 和 After 关键字只是服务之间启动顺序的一部分，还有其他因素可能影响系统中服务的实际启动顺序。</p>
<h3 id="before-After和Wantedby的区别是什么："><a href="#before-After和Wantedby的区别是什么：" class="headerlink" title="before After和Wantedby的区别是什么："></a>before After和Wantedby的区别是什么：</h3><p>Before 和 After 关键字用于定义服务之间的启动顺序，而 WantedBy 关键字用于指定 systemd 启动该服务的目标。</p>
<p>Before 和 After 关键字可以在系统中建立服务之间的启动顺序依赖关系。例如，如果一个服务 A 声明了 Before&#x3D;B，那么在启动或停止服务 B 之前，服务 A 将被启动或停止。相反地，如果一个服务 A 声明了 After&#x3D;B，则服务 B 将在启动或停止服务 A 之后启动或停止。</p>
<p>WantedBy 关键字用于指定 systemd 启动该服务的目标。这通常是一个 target 单元，如 multi-user.target 或 graphical.target。例如，如果一个服务声明了 WantedBy&#x3D;multi-user.target，则该服务将在系统进入 multi-user.target 目标时启动。</p>
<p>因此，Before 和 After 关键字用于控制服务之间的启动顺序，而 WantedBy 关键字则指定 systemd 启动该服务的目标。这些关键字可以一起使用来创建复杂的启动依赖关系和目标层次结构。</p>
<h3 id="systemd-单元的dependencies-UNIT-REFERENCED-BY-和dependencies-UNIT-REFERENCES-的区别是什么？"><a href="#systemd-单元的dependencies-UNIT-REFERENCED-BY-和dependencies-UNIT-REFERENCES-的区别是什么？" class="headerlink" title="systemd 单元的dependencies[UNIT_REFERENCED_BY]和dependencies[UNIT_REFERENCES]的区别是什么？"></a>systemd 单元的dependencies[UNIT_REFERENCED_BY]和dependencies[UNIT_REFERENCES]的区别是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencies[UNIT_REFERENCES] 属性用于记录一个单元所依赖的其他单元，而 dependencies[UNIT_REFERENCED_BY] 属性用于记录依赖该单元的其他单元。</span><br></pre></td></tr></table></figure>

<h2 id="systemctl-set-default-关闭和开启图形化界面"><a href="#systemctl-set-default-关闭和开启图形化界面" class="headerlink" title="systemctl set-default(关闭和开启图形化界面):"></a>systemctl set-default(关闭和开启图形化界面):</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230424101610834.png" alt="image-20230424101610834"></p>
<h2 id="tmp目录被清空实现"><a href="#tmp目录被清空实现" class="headerlink" title="&#x2F;tmp目录被清空实现"></a>&#x2F;tmp目录被清空实现</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230424102102208.png" alt="image-20230424102102208"></p>
<p>把这一行注释掉&#x2F;tmp下的内容就不会删除</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230424102117921.png" alt="image-20230424102117921"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230803071713337.png" alt="image-20230803071713337"></p>
<h2 id="kms激活码："><a href="#kms激活码：" class="headerlink" title="kms激活码："></a>kms激活码：</h2><p>kms.uniontech.com:8900:nqYvXZXdNPKNn335</p>
<h2 id="sd-bus-add-match-async-函数"><a href="#sd-bus-add-match-async-函数" class="headerlink" title="sd_bus_add_match_async 函数"></a>sd_bus_add_match_async 函数</h2><p><strong>sd_bus_add_match_async 函数的作用？“sd_bus_add_match_async(track-&gt;bus, &amp;n-&gt;slot, match, on_name_owner_changed, NULL, track);”这个的含义是什么？</strong></p>
<p><code>sd_bus_add_match_async</code>函数用于向DBus系统总线注册一个过滤规则，当满足该规则的消息到达总线时，DBus将会通知应用程序。该函数的原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sd_bus_add_match_async(sd_bus *bus, sd_bus_slot **slot, const <span class="built_in">char</span> *match, sd_bus_message_handler_t callback, void *userdata, sd_bus_slot **ret_slot);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bus</code>参数指向DBus系统总线。</li>
<li><code>slot</code>参数是一个指向 <code>sd_bus_slot</code>类型指针的指针，用于返回DBus总线的插槽。</li>
<li><code>match</code>参数是一个DBus过滤规则，用于匹配总线上的消息。具体规则可以参考DBus文档中的描述。</li>
<li><code>callback</code>参数是当DBus总线上有符合过滤规则的消息到达时应该调用的回调函数。</li>
<li><code>userdata</code>参数是传递给回调函数的用户数据指针。</li>
<li><code>ret_slot</code>参数是一个指向 <code>sd_bus_slot</code>类型指针的指针，用于返回DBus总线的插槽。</li>
</ul>
<p>所以，<code>sd_bus_add_match_async(track-&gt;bus, &amp;n-&gt;slot, match, on_name_owner_changed, NULL, track);</code>的含义是：向DBus系统总线注册一个过滤规则（<code>match</code>），当DBus总线上有符合该规则的消息到达时，调用 <code>on_name_owner_changed</code>函数，回调函数的用户数据指针为 <code>track</code>，并返回DBus总线的插槽。</p>
<h2 id="session-c1-device-226-0代表什么意思"><a href="#session-c1-device-226-0代表什么意思" class="headerlink" title="session-c1-device-226-0代表什么意思:"></a>session-c1-device-226-0代表什么意思:</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230428162455823.png" alt="image-20230428162455823"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230428161449272.png" alt="image-20230428161449272"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;4月 28 13:44:50 uos-PC systemd[1]: systemd-logind.service: Got notification message from PID 1239 (FDSTORE=1, FDNAME=session-4-device-226-0)</span><br><span class="line">4月 28 13:44:50 uos-PC systemd[1]: systemd-logind.service: Added fd 123 (session-4-device-226-0) to fd store.&quot; 这个日志是什么意思</span><br></pre></td></tr></table></figure>

<p>这个日志是系统的 <code>systemd-logind.service</code> 服务收到了一个来自进程 ID 为 1239 的进程的通知消息，该消息的内容是将一个名为 <code>session-4-device-226-0</code> 的文件描述符添加到文件描述符存储中。</p>
<p>具体来说，这个日志包含了以下两条系统日志信息：</p>
<p>第一条信息： <code>systemd-logind.service: Got notification message from PID 1239 (FDSTORE=1, FDNAME=session-4-device-226-0)</code>。其中：</p>
<ul>
<li><code>systemd-logind.service</code> 是系统中用于控制用户登录和登出的服务。</li>
<li><code>Got notification message</code> 表示该服务收到了一个通知消息。</li>
<li><code>PID 1239</code> 表示发送该通知消息的进程 ID 是 1239。</li>
<li><code>(FDSTORE=1, FDNAME=session-4-device-226-0)</code> 表示通知消息的内容，其中 <code>FDSTORE=1</code> 表示将该文件描述符存储，<code>FDNAME=session-4-device-226-0</code> 表示文件描述符名为 <code>session-4-device-226-0</code>。</li>
</ul>
<p>第二条信息：<code>systemd-logind.service: Added fd 123 (session-4-device-226-0) to fd store.</code>。其中：</p>
<ul>
<li><code>Added fd 123</code> 表示成功将文件描述符添加到文件描述符存储中，并获得了一个文件描述符编号 123。</li>
<li><code>(session-4-device-226-0)</code> 表示被添加的文件描述符的名字。</li>
</ul>
<p>综上，这个日志记录了系统中一个进程向 <code>systemd-logind.service</code> 发送了一个消息，通知该服务将一个名为 <code>session-4-device-226-0</code> 的文件描述符存储到系统的文件描述符存储中。</p>
<h2 id="查看deb包dbg调试信息："><a href="#查看deb包dbg调试信息：" class="headerlink" title="查看deb包dbg调试信息："></a>查看deb包dbg调试信息：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230428174919715.png" alt="image-20230428174919715"></p>
<h3 id="判断一个包是否已安装的代码："><a href="#判断一个包是否已安装的代码：" class="headerlink" title="判断一个包是否已安装的代码："></a>判断一个包是否已安装的代码：</h3><p>原理是遍历&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;packagename.list</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line">    ret = get_dpkg_file_count(packagename, &amp;num_pkg_files,&amp;package_dir_list); //获取应用相关的所有文件</span><br><span class="line"></span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        g_list_foreach(package_dir_list, (GFunc)free_glist_enum_memory, NULL);</span><br><span class="line"></span><br><span class="line">        g_list_free(package_dir_list);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果获取到与包相关的文件数为0,则认为该包名不正确，返回参数异常错误</span><br><span class="line"></span><br><span class="line">    SPM_LOG_ERR(&quot;#package:%s,num_pkg_files:%d&quot;, packagename, num_pkg_files);</span><br><span class="line"></span><br><span class="line">    if (num_pkg_files &lt;= 0)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">        g_list_foreach(package_dir_list, (GFunc)free_glist_enum_memory, NULL);</span><br><span class="line"></span><br><span class="line">        g_list_free(package_dir_list);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int get_dpkg_file_count(const char *packagename, int *num_pkg_files,GList **package_dir_list)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    char info_file_name[MAX_PACKAGENAME_LEN] = &#123;0&#125;; //.list文件</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    char *buf = NULL;</span><br><span class="line"></span><br><span class="line">    buf = (char *)malloc(MAX_LINE_LEN);</span><br><span class="line"></span><br><span class="line">    if (buf == NULL)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        SPM_LOG_ERR(&quot;NOMEMORY:%m&quot;);</span><br><span class="line"></span><br><span class="line">        return SPM_RET_NOMEMORY;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(buf, 0, MAX_LINE_LEN);</span><br><span class="line"></span><br><span class="line">    char *buf_long = NULL;</span><br><span class="line"></span><br><span class="line">    int readsize = MAX_LINE_LEN;</span><br><span class="line"></span><br><span class="line">    int len = 0;</span><br><span class="line"></span><br><span class="line">    int attr = 0;</span><br><span class="line"></span><br><span class="line">    struct stat sbuf;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    char script_file_name[MAX_PACKAGENAME_LEN]; //  dpkg/info目录中的脚本文件</span><br><span class="line"></span><br><span class="line">    int len_suffix_array = (sizeof(aux_files_suffix) / sizeof(aux_files_suffix[0]));</span><br><span class="line"></span><br><span class="line">    snprintf(info_file_name, MAX_PACKAGENAME_LEN, &quot;%s/%s.%s&quot;, PKG_INFO_PATH, packagename, LISTFILE);</span><br><span class="line"></span><br><span class="line">    fp = fopen(info_file_name, &quot;r&quot;);</span><br><span class="line"></span><br><span class="line">    if (fp == NULL)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        ret = -errno;</span><br><span class="line"></span><br><span class="line">        free(buf);</span><br><span class="line"></span><br><span class="line">        buf = NULL;</span><br><span class="line"></span><br><span class="line">        SPM_LOG_ERR(&quot;%s,failed :%m&quot;, info_file_name);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (fgets(&amp;buf[attr], readsize - len, fp) != NULL)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (!newline_terminated(&amp;buf[attr], readsize - len))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            len = readsize;</span><br><span class="line"></span><br><span class="line">            attr = strlen(buf);</span><br><span class="line"></span><br><span class="line">            readsize = readsize * 2;</span><br><span class="line"></span><br><span class="line">            buf_long = (char *)malloc(readsize);</span><br><span class="line"></span><br><span class="line">            if (buf_long == NULL)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                free(buf);</span><br><span class="line"></span><br><span class="line">                fclose(fp);</span><br><span class="line"></span><br><span class="line">                SPM_LOG_ERR(&quot;NOMEMORY:%m&quot;);</span><br><span class="line"></span><br><span class="line">                return SPM_RET_NOMEMORY;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memset(buf_long, 0, readsize);</span><br><span class="line"></span><br><span class="line">            strncpy(buf_long, buf, len);</span><br><span class="line"></span><br><span class="line">            free(buf);</span><br><span class="line"></span><br><span class="line">            buf = NULL;</span><br><span class="line"></span><br><span class="line">            buf = buf_long;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            char *find = strchr(buf, &#x27;\n&#x27;); //末尾的&quot;\n&quot;</span><br><span class="line"></span><br><span class="line">            if (find)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                *find = &#x27;\0&#x27;; //替换</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = stat(buf, &amp;sbuf);</span><br><span class="line"></span><br><span class="line">            if (ret &lt; 0) //针对文件或目录不存在的容错处理</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 2022-11-09 添加 对目录设置保护</span><br><span class="line"></span><br><span class="line">            if (!S_ISDIR(sbuf.st_mode) || check_package_dirname_and_addtolist(buf, packagename, package_dir_list))</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                *num_pkg_files = *num_pkg_files + 1;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            len = 0;</span><br><span class="line"></span><br><span class="line">            attr = 0;</span><br><span class="line"></span><br><span class="line">            readsize = MAX_LINE_LEN;</span><br><span class="line"></span><br><span class="line">            free(buf);</span><br><span class="line"></span><br><span class="line">            buf = NULL;</span><br><span class="line"></span><br><span class="line">            buf = (char *)malloc(readsize);</span><br><span class="line"></span><br><span class="line">            if (buf == NULL)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                fclose(fp);</span><br><span class="line"></span><br><span class="line">                SPM_LOG_ERR(&quot;NOMEMORY:%m&quot;);</span><br><span class="line"></span><br><span class="line">                return SPM_RET_NOMEMORY;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memset(buf, 0, readsize);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    free(buf);</span><br><span class="line"></span><br><span class="line">    buf = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len_suffix_array; i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        snprintf(script_file_name, MAX_PACKAGENAME_LEN, &quot;%s/%s.%s&quot;, PKG_INFO_PATH, packagename, aux_files_suffix[i]);</span><br><span class="line"></span><br><span class="line">        if (access(script_file_name, F_OK) != -1)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            *num_pkg_files = *num_pkg_files + 1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\#define PKG_INFO_PATH &quot;/var/lib/dpkg/info&quot;</span><br><span class="line"></span><br><span class="line">\#define LISTFILE &quot;list&quot;</span><br><span class="line">// 判断一行是否读取完整</span><br><span class="line">static int newline_terminated(char *buf, size_t buflen)</span><br><span class="line">&#123;</span><br><span class="line">    size_t len = strlen(buf);</span><br><span class="line">    if (len == buflen - 1 &amp;&amp; buf[len - 1] != &#x27;\r&#x27; &amp;&amp;</span><br><span class="line">        buf[len - 1] != &#x27;\n&#x27;)</span><br><span class="line">        return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shell替换软件包版本号的shell命令"><a href="#shell替换软件包版本号的shell命令" class="headerlink" title="shell替换软件包版本号的shell命令"></a>shell替换软件包版本号的shell命令</h3><p>dpkg -l|grep 2.28.23-deepin1|cut -d ‘ ‘ -f 3|cut -d ‘:’ -f 1|sed ‘s&#x2F;(.*)&#x2F;\1&#x3D;2.28.21-deepin1&#x2F;g’ | tr ‘\n’ ‘ ‘</p>
<h3 id="echo-e-“aaaa-nbbbb”-sed-‘s-1-xx-g’-tr-‘-n’-‘-‘"><a href="#echo-e-“aaaa-nbbbb”-sed-‘s-1-xx-g’-tr-‘-n’-‘-‘" class="headerlink" title="echo -e “aaaa\nbbbb” | sed ‘s&#x2F;(.*)&#x2F;\1&#x3D;xx&#x2F;g’ | tr ‘\n’ ‘ ‘"></a>echo -e “aaaa\nbbbb” | sed ‘s&#x2F;(.*)&#x2F;\1&#x3D;xx&#x2F;g’ | tr ‘\n’ ‘ ‘</h3><p>&#96;&#96;解释：</p>
<p>\1. <code>echo -e &quot;aaaa\nbbbb&quot;</code>：使用 <code>echo</code> 命令输出两行文本，<code>aaaa</code> 和 <code>bbbb</code>。<br>2 <code>sed &#39;s/\(.*\)/\1=xx/g&#39;</code>：使用 <code>sed</code> 命令在每个单词后面添加 <code>=xx</code>。<br>\3. <code>tr &#39;\n&#39; &#39; &#39;</code>：使用 <code>tr</code> 命令将换行符替换为空格。</p>
<p>运行此命令后，您将得到以下输出：</p>
<p>&#96;&#96;aaaa&#x3D;xx bbbb&#x3D;xx</p>
<h2 id="usbip设置u盘重定向："><a href="#usbip设置u盘重定向：" class="headerlink" title="usbip设置u盘重定向："></a>usbip设置u盘重定向：</h2><p>1、可复现问题的机型：</p>
<p>任何两台x86或arm架构uos机器</p>
<p>2、设备详细信息（启动器-设备管理器-右键-导出）：</p>
<p><strong>如果事件单中已提供，可备注事件单中已提供。</strong></p>
<p>3、复现问题的镜像链接：</p>
<p>105x公版镜像</p>
<p>4、安装第3条中的镜像后，客户另外自行安装的应用列表（如果事定制版应用，请提供下载链接）：</p>
<p>从系统仓库安装usbip工具</p>
<p>5、故障发生时正在运行的应用列表（系统监视器-程序进程截屏）：</p>
<p><strong>eg.</strong></p>
<p>6、详细的复现步骤：</p>
<p><strong>uos1和uos2需要安装usbip<strong><strong>工具，分别</strong></strong>加载驱动****，设置网卡延迟。</strong></p>
<p><strong>1、系统仓库安装usbip  sudo apt install usbip</strong></p>
<p><strong>2、执行sudo modprobe vhci_hcd和sudo modprobe usbip-host</strong></p>
<p><strong>3、执行sudo tc qdisc add dev  enp2s0  root netem delay 30ms</strong></p>
<p><strong>备注：云厂商适配适配场景，主机和虚拟机环境一般会存在网络延迟，所有本地复现时需要将网络延迟设置30ms左右</strong></p>
<p><strong>Uos1</strong></p>
<p><strong>1、系统仓库安装usbip  sudo apt install usbip</strong></p>
<p><strong>2、执行sudo modprobe vhci_hcd和sudo modprobe usbip-host</strong></p>
<p><strong>3、执行sudo tc qdisc add dev  网卡名称1  root netem delay 30ms</strong></p>
<p><strong>4、****物理设备端插入USB设备</strong></p>
<p><strong>5、****物理设备端执行sudo usbip list -l 查询USB设备的busid</strong></p>
<p><strong>6、****物理设备端执行sudo usbip bind -b <code>&lt;busid&gt;</code> 进行绑定</strong></p>
<p><strong>7、****物理设备端执行sudo usbipd -d -4 开启服务</strong></p>
<p><strong>U****os2</strong></p>
<p><strong>1、系统仓库安装usbip  sudo apt install usbip</strong></p>
<p><strong>2、执行sudo modprobe vhci_hcd和sudo modprobe usbip-host</strong></p>
<p><strong>3、执行sudo tc qdisc add dev 网卡名称2  root netem delay 30ms</strong></p>
<p>*<em>4、</em>***虚拟设备端执行sudo usbip attach -r  <strong><uos1_ip></uos1_ip></strong> <strong>-b</strong> <strong><code>&lt;busid&gt;</code> 进行连接</strong></p>
<p><strong>5、打开文件管理，可以查看插入uos1的u盘数据</strong></p>
<p>虚拟设备执行usbip detach -p 0进行断开连接</p>
<p> 物理设备端执行usbip unbind -b <code>&lt;busid&gt;</code>进行解绑</p>
<h2 id="调试dde-daemon："><a href="#调试dde-daemon：" class="headerlink" title="调试dde-daemon："></a>调试dde-daemon：</h2><p>pkill dde-session-dae ;&#x2F;usr&#x2F;lib&#x2F;deepin-daaemon&#x2F;dde-session-daemon</p>
<p>或者</p>
<p>killall dde-session-daemon;DDE_DEBUG_LEVEL&#x3D;debug &#x2F;usr&#x2F;lib&#x2F;deepin-daemon&#x2F;dde-session-daemon</p>
<h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p>git clone<br>&#x2F;*<br>如果目录上级没有源码文件<br>debuild -us -uc 然后取消<br>mv 代码目录 代码目录-版本号<br>dh_make –createorig -s  产生orig源码文件*&#x2F; 这些有源代码不需要<br>dpkg-source -b .&#x2F; 或<br>dpkg-source –before-build . 应用补丁<br>ln -s debian&#x2F;patches&#x2F; patches<br>quilt new 补丁名 例如add-uos-support.patch<br>quilt add 要修改的文件 例如Makefile<br>修改文件<br>quilt refresh     补丁就生成出来了 在debian&#x2F;patches目录下<br>cd ..&#x2F;..&#x2F; 退到代码根目录<br>dch -i 改changelog<br>git add debian&#x2F;changelog<br>git add debian&#x2F;patches&#x2F;series<br>git add debian&#x2F;patches&#x2F;生成的补丁<br>git commit<br>这里可以 debuild -b 编译进行测试；或者<br>dpkg-source –after-build .<br>dpkg-source –before-build . 测试补丁应用<br>最后 git reset –hard<br>git clean -df 将临时文件清除<br>git review -r origin uos提交，最后面是要提交的分支名</p>
<p>debian目录不打patch，直接修改</p>
<p>quilt rename -P 给补丁改名字<br>quilt remove files 和add相反<br>必须先add 再改</p>
<h2 id="git撤销amend"><a href="#git撤销amend" class="headerlink" title="git撤销amend:"></a>git撤销amend:</h2><p>首先使用 <code>git reflog</code> 命令查看操作记录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">c1c1b21 HEAD@&#123;0&#125;: commit (amend): add blank line to index.html</span><br><span class="line">9ff821d HEAD@&#123;1&#125;: commit: add blank line to index.html</span><br><span class="line">b078331 HEAD@&#123;2&#125;: commit: no more commit!</span><br><span class="line">b86e902 HEAD@&#123;3&#125;: commit: so many commit</span><br><span class="line">77e6ce9 HEAD@&#123;4&#125;: commit: this is another commit</span><br><span class="line">ccde039 HEAD@&#123;5&#125;: commit: this is a commit</span><br><span class="line">a49dcf4 HEAD@&#123;6&#125;: <span class="built_in">clone</span>: from ssh://liux@xxx.xx.xx.xxx:29418/git_test.git</span><br></pre></td></tr></table></figure>

<p>看到 amend 操作之前的最后一个操作就是 <code>HEAD@&#123;1&#125;</code>.<br>现在可以用 <code>git reset</code> 将当前分支的 HEAD 指向 <code>HEAD@&#123;1&#125;</code>, 即可达到撤销 amend 的目的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD@&#123;1&#125;</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 5 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure>

<h2 id="找socket对应的文件："><a href="#找socket对应的文件：" class="headerlink" title="找socket对应的文件："></a>找socket对应的文件：</h2><p>ls -l &#x2F;proc&#x2F;2546&#x2F;fd&#x2F;12  -&gt; socket:[52845]</p>
<p>cat &#x2F;proc&#x2F;net&#x2F;unix | grep 52845 -&gt; &#x2F;run&#x2F;user&#x2F;1000&#x2F;systemd&#x2F;private</p>
<p>cat &#x2F;proc&#x2F;net&#x2F;netlink| grep sockid</p>
<h2 id="lightdm到startdde的整个流程："><a href="#lightdm到startdde的整个流程：" class="headerlink" title="lightdm到startdde的整个流程："></a>lightdm到startdde的整个流程：</h2><p>lightdm启动greeter:</p>
<p>日志在&#x2F;var&#x2F;log&#x2F;lightdm&#x2F;lightdm.log</p>
<p>greeter 16:55:29创建会话（&#x2F;var&#x2F;log&#x2F;lightdm&#x2F;seat0-greater.log ）</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-675667.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-675667.png" alt="img"></a></p>
<p>kwin 16:55:33启动（~&#x2F;.kwin.log）</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-675669.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-675669.png" alt="img"></a></p>
<p>startdde 16:55:50启动(journalctl &#x2F;usr&#x2F;bin&#x2F;lightdm -b0)</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-675671.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-675671.png" alt="img"></a></p>
<p>代码：</p>
<p>lightdm-&gt;&#x2F;usr&#x2F;bin&#x2F;deepin-greeter-&gt;&#x2F;usr&#x2F;share&#x2F;dde-session-shell&#x2F;greeters.d&#x2F;x&#x2F;*或者&#x2F;usr&#x2F;share&#x2F;dde-session-shell&#x2F;greeters.d&#x2F;wayland&#x2F;launch-kwin-wayland-&gt;&#x2F;usr&#x2F;bin&#x2F;kwin_wayland –drm –no-lockscreent &#x2F;usr&#x2F;share&#x2F;dde-session-shell&#x2F;greeters.d&#x2F;wayland&#x2F;lightdm-deepin-greeter-wayland</p>
<h2 id="打印枚举值："><a href="#打印枚举值：" class="headerlink" title="打印枚举值："></a>打印枚举值：</h2><p>enum tp_gesture_state {</p>
<pre><code>GESTURE_STATE_NONE,

GESTURE_STATE_UNKNOWN,

GESTURE_STATE_SCROLL,

GESTURE_STATE_PINCH,

GESTURE_STATE_SWIPE,

GESTURE_STATE_TAP,
</code></pre>
<p>};</p>
<p>#define CASE_RETURN_STRING(a) case a: return #a</p>
<p>static inline const char*</p>
<p>gesture_state_to_str(enum tp_gesture_state state)</p>
<p>{</p>
<pre><code>switch (state) &#123;

CASE_RETURN_STRING(GESTURE_STATE_NONE);

CASE_RETURN_STRING(GESTURE_STATE_UNKNOWN);

CASE_RETURN_STRING(GESTURE_STATE_SCROLL);

CASE_RETURN_STRING(GESTURE_STATE_PINCH);

CASE_RETURN_STRING(GESTURE_STATE_SWIPE);

CASE_RETURN_STRING(GESTURE_STATE_TAP);

&#125;

return NULL;
</code></pre>
<p>}</p>
<h2 id="编译kwin遇到如下问题："><a href="#编译kwin遇到如下问题：" class="headerlink" title="编译kwin遇到如下问题："></a>编译kwin遇到如下问题：</h2><p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;override_dh_shlibdeps:\n\tdh_shlibdeps --dpkg-shlibdeps-params=--ignore-missing-info&quot;|tee -a debian/rules</span><br></pre></td></tr></table></figure>

<h2 id="gdb-set-substitute-path命令用法"><a href="#gdb-set-substitute-path命令用法" class="headerlink" title="gdb set substitute-path命令用法"></a>gdb set substitute-path命令用法</h2><p><code>set substitute-path</code> 是 GDB 中的一个命令，用于设置源代码路径的替换规则。它可以帮助 GDB 在调试过程中正确地找到源代码文件。</p>
<p>该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phpCopy code</span><br><span class="line">set substitute-path &lt;原始路径&gt; &lt;替换路径&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;原始路径&gt;</code> 是要被替换的源代码路径，<code>&lt;替换路径&gt;</code> 是替换后的路径。</p>
<p>例如，假设源代码路径为 <code>/home/user/project/src</code>，而实际代码所在的路径是 <code>/mnt/external_drive/project/src</code>，你可以使用以下命令进行路径替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">set substitute-path /home/user/project/src /mnt/external_drive/project/src</span><br></pre></td></tr></table></figure>

<p>这样，当 GDB 在调试过程中遇到源代码文件路径为 <code>/home/user/project/src/foo.c</code> 时，会自动将其替换为 <code>/mnt/external_drive/project/src/foo.c</code>。</p>
<p>你可以使用 <code>show substitute-path</code> 命令来查看当前设置的替换规则。如果需要取消替换规则，可以使用 <code>unset substitute-path</code> 命令。</p>
<p>请注意，<code>set substitute-path</code> 命令通常在调试会话开始之前使用，因为它会影响到后续的源代码查找和断点设置。</p>
<h2 id="查看一个文件夹占了哪个磁盘的-空间以及磁盘所占空间"><a href="#查看一个文件夹占了哪个磁盘的-空间以及磁盘所占空间" class="headerlink" title="查看一个文件夹占了哪个磁盘的 空间以及磁盘所占空间"></a>查看一个文件夹占了哪个磁盘的 空间以及磁盘所占空间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h /path/to/folder</span><br><span class="line">df -h /dev/sda</span><br></pre></td></tr></table></figure>

<h2 id="查看一个文件夹下各文件所占空间大小，只算一层"><a href="#查看一个文件夹下各文件所占空间大小，只算一层" class="headerlink" title="查看一个文件夹下各文件所占空间大小，只算一层"></a>查看一个文件夹下各文件所占空间大小，只算一层</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>

<h2 id="查看journal某次启动的日志："><a href="#查看journal某次启动的日志：" class="headerlink" title="查看journal某次启动的日志："></a>查看journal某次启动的日志：</h2><p>journalctl –directory logsall&#x2F;logs&#x2F;var&#x2F;log&#x2F;journal&#x2F;75ac2718a7824e04aca173da6d3c0277&#x2F; –list-boots</p>
<p>journalctl –directory logsall&#x2F;logs&#x2F;var&#x2F;log&#x2F;journal&#x2F;75ac2718a7824e04aca173da6d3c0277&#x2F; –list-boots | grep “2023-07-11 01:14:”</p>
<p>journalctl –directory logsall&#x2F;logs&#x2F;var&#x2F;log&#x2F;journal&#x2F;75ac2718a7824e04aca173da6d3c0277&#x2F; -b -90</p>
<p> vim logsall&#x2F;logs&#x2F;var&#x2F;log&#x2F;deepin&#x2F;dde-dconfig-daemon&#x2F;dde-dconfig-daemon.log</p>
<h2 id="开启dbus日志："><a href="#开启dbus日志：" class="headerlink" title="开启dbus日志："></a>开启dbus日志：</h2><p>dbus-damon里有很多调试log是 通过_dbus_verbose 打印的，这个打印必须打开DBUS_ENABLE_VERBOSE_MODE 才会打印。<br>而这个宏在 debian&#x2F;rules 通过参数–enable-verbose-mode打开，dbus默认有个debug_configure_flags打开了这个宏，但是没有编译到包里，是在 dbus&#x2F;debian&#x2F;build-debug&#x2F;bus&#x2F;目录下。<br>必须用这个编译出来的debug版本，加上 DBUS_VERBOSE&#x3D;1参数才能打开verbose log，log是直接fprintf(stderr方式打印，所以要用nofork方式启动。<br>log非常多，为了不影响正常业务，可以单独的起一个dbus-daemon，然后对要调试的程序，通过环境变量 DBUS_SYSTEM_BUS_ADDRESS 或者DBUS_SESSION_BUS_ADDRESS指定地址的方式 让调试程序将dbus消息发到我们这个debug版本上，系统其他的进程还是发到原来的dbus-daemon上，这样对正常业务没有影响。</p>
<h2 id="如何用BPFtrace跟踪ioctl调用"><a href="#如何用BPFtrace跟踪ioctl调用" class="headerlink" title="如何用BPFtrace跟踪ioctl调用"></a>如何用BPFtrace跟踪ioctl调用</h2><p>要使用 BPFtrace 跟踪 <code>ioctl</code> 调用，你可以编写一个 BPFtrace 脚本，使用 <code>tracepoint:syscalls:sys_enter_ioctl</code> 事件来捕获 <code>ioctl</code> 系统调用的进入。</p>
<p>以下是一个简单的示例脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/bpftrace</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_ioctl</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;ioctl called: fd=%d, request=%lx\n&quot;, arg1, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存脚本为 <code>ioctl_trace.bt</code>，然后在终端中运行以下命令启动 BPFtrace：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">sudo bpftrace ioctl_trace.bt</span><br></pre></td></tr></table></figure>

<p>这将以超级用户权限运行 BPFtrace，并开始跟踪 <code>ioctl</code> 调用。每当有进程调用 <code>ioctl</code> 时，将打印相应的信息，包括文件描述符和请求参数。</p>
<p>请注意，运行 BPFtrace 需要具有适当的权限。在某些系统上，可能需要以超级用户身份运行 BPFtrace。另外，BPFtrace 的可用性和功能可能会因操作系统和内核版本的不同而有所差异。请确保你的系统满足 BPFtrace 的要求，并在运行脚本之前进行适当的测试和验证。</p>
<h2 id="tracepoint-syscalls-sys-enter-ioctl这个tracepoint是什么意思？"><a href="#tracepoint-syscalls-sys-enter-ioctl这个tracepoint是什么意思？" class="headerlink" title="tracepoint:syscalls:sys_enter_ioctl这个tracepoint是什么意思？"></a>tracepoint:syscalls:sys_enter_ioctl这个tracepoint是什么意思？</h2><p>这个tracepoint定义了一个名为 <code>syscalls:sys_enter_ioctl</code>的跟踪事件。在内核中，tracepoint是用于跟踪和观察特定代码路径或系统调用的工具。</p>
<p>该tracepoint用于跟踪 <code>ioctl</code>系统调用的进入点。当应用程序调用 <code>ioctl</code>函数时，该tracepoint会被触发，并执行其中的代码块。代码块中的内容会被打印到控制台上，显示相关的信息，如文件描述符（fd）和ioctl请求（request）。</p>
<p>通过定义和使用tracepoint，可以在内核中注入自定义的代码逻辑，用于跟踪和监视系统的运行时行为。这对于调试、性能分析和问题排查非常有用。通过tracepoint，您可以观察特定的系统调用、函数调用或事件，并在它们发生时执行自定义的操作。</p>
<p>tracepoint和uprobe的区别？</p>
<p>Tracepoint和Uprobe都是Linux内核中的跟踪工具，但它们的实现和使用方式有所不同。</p>
<p>Tracepoint是内核中预定义的静态跟踪事件，用于跟踪和监视特定的代码路径、系统调用或事件。Tracepoint在内核代码中显式定义，并在运行时触发相应的事件。可以使用trace-cmd等工具捕获和分析这些事件，以了解系统的行为和性能。</p>
<p>Uprobe（User Probe）是一种动态的用户空间探测工具，用于在用户空间代码中插入探针。Uprobe允许您在用户程序的指定位置设置探针，当程序执行到该位置时，探针会触发并执行相应的动作。通过Uprobe，您可以监视和分析用户空间代码的执行，收集关键指标和信息。</p>
<p>关键区别如下：</p>
<ol>
<li>Tracepoint是内核中静态定义的事件，而Uprobe是在用户空间动态设置的探针。</li>
<li>Tracepoint用于跟踪和监视内核中的代码路径和事件，而Uprobe用于跟踪和监视用户空间程序的执行。</li>
<li>Tracepoint由内核开发人员定义和维护，而Uprobe由用户或开发人员在运行时设置和使用。</li>
<li>Tracepoint的触发是由内核事件驱动的，而Uprobe的触发是由用户空间程序的执行驱动的。</li>
</ol>
<p>总的来说，Tracepoint更适用于内核级别的跟踪和分析，而Uprobe更适用于用户空间程序的动态监测和调试。</p>
<p>objdump  -tT &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 | grep nptl_setxid</p>
<p>objdump  -tT &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 | grep setgid</p>
<p>bpftrace  -e ‘kprobe:__sys_setresgid { @[ustack] &#x3D; count(); }’</p>
<p>bpftrace  -e ‘kprobe:__sys_setresgid { printf(“%s\n”,stack) }’</p>
<p>bpftrace  -e ‘kprobe:__sys_setresgid { printf(“%s\n”,ustack) }’</p>
<p>bpftrace  -e ‘kprobe:__sys_setresgid { printf(“%s\n”,ustack) }’</p>
<h2 id="pkexec提权"><a href="#pkexec提权" class="headerlink" title="pkexec提权"></a>pkexec提权</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230719134624308.png" alt="image-20230719134624308"></p>
<p>dconfig</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230721134554563.png" alt="image-20230721134554563"></p>
<p>显卡驱动位置：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230725115356234.png" alt="image-20230725115356234"></p>
<p>drm调试等级设定：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230725115602949.png" alt="image-20230725115602949"></p>
<h2 id="查看某个服务为什么退出："><a href="#查看某个服务为什么退出：" class="headerlink" title="查看某个服务为什么退出："></a>查看某个服务为什么退出：</h2><p>stopping %s ….</p>
<p>gdb -p 1</p>
<p>b job_add_to_gc_queue  即可，放心，调的次数不算太多</p>
<h2 id="获取USB设备的idVendor和idProduct信息。以下是几种常用的方法："><a href="#获取USB设备的idVendor和idProduct信息。以下是几种常用的方法：" class="headerlink" title="获取USB设备的idVendor和idProduct信息。以下是几种常用的方法："></a>获取USB设备的idVendor和idProduct信息。以下是几种常用的方法：</h2><ol>
<li><p>使用lsusb命令： 在终端中运行 <code>lsusb</code>命令，它会列出当前连接到计算机的所有USB设备及其相应的idVendor和idProduct信息。示例输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yamlCopy codeBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 003: ID 0c45:670c Microdia </span><br><span class="line">Bus 001 Device 002: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader Controller</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>

<p>在这个输出中，”0c45”表示idVendor，”670c”表示idProduct。</p>
</li>
<li><p>使用udevadm命令： 在终端中运行 <code>udevadm info -a -n /dev/usbX</code>（将”usbX”替换为您要检查的USB设备路径，如”&#x2F;dev&#x2F;usb1”）。该命令将显示有关USB设备的详细信息，包括idVendor和idProduct。</p>
</li>
<li><p>使用dmesg命令： 在终端中运行 <code>dmesg</code>命令，它会显示Linux内核日志，其中包含有关连接的USB设备的信息，包括idVendor和idProduct。</p>
</li>
</ol>
<h2 id="检查二进制程序是否存在内存泄露"><a href="#检查二进制程序是否存在内存泄露" class="headerlink" title="检查二进制程序是否存在内存泄露"></a>检查二进制程序是否存在内存泄露</h2><p>valgrind –leak-check&#x3D;summary df</p>
<h2 id="查看安装器的日志："><a href="#查看安装器的日志：" class="headerlink" title="查看安装器的日志："></a>查看安装器的日志：</h2><p>cat &#x2F;var&#x2F;log&#x2F;deepin-installer.log | base64 -d</p>
<h2 id="禁用-SELinux-的强制执行"><a href="#禁用-SELinux-的强制执行" class="headerlink" title="禁用 SELinux 的强制执行"></a>禁用 SELinux 的强制执行</h2><p>将启动参数 <code>enforcing=0</code> 添加到启动选项中，可以将 SELinux 安全政策设置为 “Permissive” 模式，从而禁用 SELinux 的强制执行</p>
<ol>
<li><strong>Permissive 模式下的 SELinux 仅记录问题，但不阻止任何操作</strong>：在 Permissive 模式下，SELinux 仍会分析和评估进程的安全上下文，但不会阻止违反规则的操作。相反，它会生成警告和错误日志来记录安全问题，以帮助系统管理员进行故障排除和调试。</li>
<li><strong>Permissive 模式允许你查看 SELinux 引起的潜在问题</strong>：通过将 SELinux 设置为 Permissive 模式，你可以查看与 SELinux 相关的潜在问题，例如哪些操作违反了 SELinux 的规则或策略。这有助于确定哪些过程可能会受到 SELinux 的限制，并可以帮助你识别和调整相应的 SELinux 配置。</li>
</ol>
<p>其他方法：</p>
<ol>
<li><p>打开终端以进入命令行界面。</p>
</li>
<li><p>以 root 用户或具有 sudo 权限的用户身份执行以下命令以编辑 SELinux 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux.conf</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/selinux/config</span><br></pre></td></tr></table></figure></li>
<li><p>找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX</span><br></pre></td></tr></table></figure>

<p>行，并将其值修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permissive</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p>。请注意，这将根据你的需求来决定如何配置 SELinux。</p>
<ul>
<li>如果将值设置为 <code>permissive</code>，SELinux 将记录异常但不阻止任何操作。</li>
<li>如果将值设置为 <code>disabled</code>，SELinux 将完全禁用。</li>
</ul>
</li>
<li><p>添加下面的行，以启用调试日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELINUX_LOGGING=all</span><br><span class="line">SELINUX_DEBUG=1</span><br></pre></td></tr></table></figure>

<p>这将开启 SELinux 的调试日志记录功能。</p>
</li>
<li><p>保存并关闭文件，退出编辑器。</p>
</li>
<li><p>重新启动系统或重新加载 SELinux 配置，使更改生效。</p>
</li>
</ol>
<h2 id="开启wine应用日志"><a href="#开启wine应用日志" class="headerlink" title="开启wine应用日志:"></a>开启wine应用日志:</h2><p>&#x2F;opt&#x2F;deepinwine&#x2F;tools&#x2F;log.sh &lt;Wine 应用包名&gt; +pid,+tid,+timestamp,+seh,+process,+module</p>
<h2 id="arecord录制音频："><a href="#arecord录制音频：" class="headerlink" title="arecord录制音频："></a>arecord录制音频：</h2><p>arecord -vv -f dat -d 120 -D pulse -r 48000 -c 2 1.wav</p>
<p>arecord -Dhw:0,1 -d 10 -f cd -t wav test.wav</p>
<p>此问题出现的原因是厂商主板设计适配声卡方面有缺陷。<br>1、通过以下步骤进行测试：<br>    (1)执行 mv &#x2F;usr&#x2F;bin&#x2F;pulseaudio &#x2F;usr&#x2F;bin&#x2F;pulseaudiobak, 重启让pulseaudio无法自启动<br>    (2)命令行 执行 arecord -Dhw:0,1 -d 10 -f cd -t wav test.wav通过alsa进行录音（hw:0,1为指定录音的设备，arecord命令的使用可以参考网上资料）<br>    (3) 将生成的test.wav用audacity软件进行播放，查看是否有杂音。<br>  此时依旧有杂音，基本可以确定是送上来的数据流有问题（中间音频驱动和alsa编解码的过程因为编解码过程都比较完善，一般不会出现问题）<br>2、此问题从现象上看就是将录制的音量提高到50%的时候，通过alsamixer查看此时Internal Mic boost开始有增强效果，导致噪音被放大。此问题在软件方面只能通过修改配置文件将Internal Mic boost设置为ignore来取消增强效果来减缓此问题，要根本解决还需要厂商进行适配。</p>
<h2 id="pulseaudio为什么不能以系统级运行："><a href="#pulseaudio为什么不能以系统级运行：" class="headerlink" title="pulseaudio为什么不能以系统级运行："></a>pulseaudio为什么不能以系统级运行：</h2><p><a target="_blank" rel="noopener" href="https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/WhatIsWrongWithSystemWide/">https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/WhatIsWrongWithSystemWide/</a></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230809110641829.png" alt="image-20230809110641829"></p>
<h2 id="i2c总线："><a href="#i2c总线：" class="headerlink" title="i2c总线："></a>i2c总线：</h2><p>i2c_designware FTI20001:01: timeout waiting for bus ready</p>
<p>你提到的错误信息 “i2c_designware FTI20001:01: timeout waiting for bus ready” 是关于 I2C 总线通信的错误。I2C 是一种常用的串行通信协议，用于连接各种外设和传感器。这个错误通常表示在等待 I2C 总线准备好时发生了超时。</p>
<p>这个错误可能由多种原因引起，以下是一些常见的可能性和解决方法：</p>
<ol>
<li><strong>硬件连接问题</strong>：确保你的硬件连接是正确的，包括正确连接了 SDA（数据线）和 SCL（时钟线），以及正确设置了总线上的电源和地线。</li>
<li><strong>电源问题</strong>：确保你的设备以及所连接的外设都有足够的电源供应，并且电源稳定。</li>
<li><strong>信号干扰</strong>：I2C 总线对信号的稳定性要求较高，如果有其他干扰源，可能会导致通信问题。确保周围环境的电磁干扰较小。</li>
<li><strong>外设故障</strong>：如果你连接了外设到 I2C 总线上，外设本身可能出现故障，导致通信问题。</li>
<li><strong>总线速率设置</strong>：检查你的代码或配置文件中设置的 I2C 总线速率是否正确。如果速率设置不正确，可能会导致通信超时。</li>
<li><strong>驱动程序问题</strong>：检查操作系统内核中的 I2C 驱动程序是否正常加载，并且是否适用于你的硬件。</li>
<li><strong>硬件故障</strong>：如果一切都正确设置而仍然出现问题，可能是硬件本身出现了故障。</li>
</ol>
<p>解决问题的步骤可能因你的具体硬件和情况而异。首先，确保硬件连接正确，然后检查电源和信号干扰等可能性。如果问题仍然存在，可以查阅硬件供应商的文档，或者查看操作系统的日志以获取更多信息。</p>
<h2 id="wget指定代理下载："><a href="#wget指定代理下载：" class="headerlink" title="wget指定代理下载："></a>wget指定代理下载：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -e use_proxy=yes -e http_proxy=http://127.0.0.1:9093 -e https_proxy=http://127.0.0.1:9093 https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.31/Clash.for.Windows-0.20.31-x64-linux.tar.gz</span><br><span class="line">带身份验证：</span><br><span class="line">wget -e use_proxy=yes -e http_proxy=http://username:password@proxy.example.com:8080 URL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DSDT-表"><a href="#DSDT-表" class="headerlink" title="DSDT 表"></a>DSDT 表</h2><p>DSDT 表是电脑硬件设备在 ACPI（高级配置和电源接口） 中的描述。ACPI 是一种高级电源管理和配置标准，旨在提供操作系统与计算机硬件之间的通信接口，以实现电源管理、硬件配置和设备控制等功能。</p>
<p>DSDT 是 “Differentiated System Description Table” 的缩写，它包含了一份以AML（ACPI机器语言）编写的二进制数据，描述了主板上各种硬件设备的层次结构、功能、资源配置和控制方法。这些硬件设备可以包括 CPU、内存、外部设备（如 USB、声卡、网卡等）、电源管理以及其他扩展功能。</p>
<p>操作系统在引导过程中会加载 DSDT 表，并根据其中的信息来实现对硬件设备的正确配置和管理。例如，操作系统可以根据 DSDT 表中的信息来决定如何正确地使用电源管理特性，如休眠、唤醒以及调整 CPU 频率等。</p>
<p>在某些情况下，硬件制造商可能提供了不完整或不准确的 DSDT 表，这可能导致一些硬件功能在操作系统中无法正常工作，或者导致电源管理等方面的问题。为了解决这些问题，技术爱好者和操作系统开发人员可能会尝试自行编写或修改 DSDT 表，以使其适配特定的硬件配置和操作系统需求。</p>
<p>需要注意的是，修改 DSDT 表需要深入了解 ACPI 和操作系统内核的工作原理，因此这通常是一个较为高级的任务，适用于对操作系统和硬件有深入了解的开发人员。</p>
<h2 id="修改-DSDT-表"><a href="#修改-DSDT-表" class="headerlink" title="修改 DSDT 表"></a>修改 DSDT 表</h2><p>修改 DSDT 表需要一些高级的技术知识和工具，以及对 ACPI 和操作系统内核的深入了解。以下是大致的步骤，但请注意这是一个复杂的任务，可能需要在特定的场景下进行，例如解决硬件兼容性问题。</p>
<ol>
<li><strong>了解 ACPI 和 DSDT 表：</strong> 在开始之前，确保您对 ACPI 和 DSDT 表的基本概念有一定的了解。阅读 ACPI 规范和相关文档可以帮助您理解 DSDT 表的结构和作用。</li>
<li><strong>获取 DSDT 表：</strong> 您可以从操作系统中获取当前系统使用的 DSDT 表。在 Linux 系统中，您可以使用 <code>acpidump</code> 工具来导出 DSDT 表。</li>
<li><strong>使用 AML 编辑器：</strong> DSDT 表是使用 AML（ACPI Machine Language）编写的。您需要使用 AML 编辑器来编辑二进制数据。常用的 AML 编辑器包括 iASL 和 SSDTTime。</li>
<li><strong>解码和分析 DSDT 表：</strong> 使用 AML 编辑器将 DSDT 表解码成易于阅读的源代码。这将使您能够分析 DSDT 表的内容，了解其中包含的硬件设备、资源配置和控制方法。</li>
<li><strong>修改 DSDT 表：</strong> 根据您的需求，您可以在源代码中修改设备描述、资源配置、控制方法等。这需要深入了解 ACPI 语法和设备的工作原理。</li>
<li><strong>编译和编译错误修复：</strong> 编辑完成后，您需要将修改后的源代码编译回二进制格式。AML 编辑器通常会提供编译工具。在此过程中可能会出现编译错误，您需要修复这些错误，确保编译通过。</li>
<li><strong>替换操作系统中的 DSDT 表：</strong> 一旦您编辑和编译好了 DSDT 表，您需要将修改后的 DSDT 表替换操作系统中的原始 DSDT 表。这可能涉及到操作系统的内核配置和加载过程。</li>
<li><strong>测试和验证：</strong> 修改 DSDT 表可能会影响硬件的行为和操作系统的稳定性。在进行实际部署之前，务必进行充分的测试和验证，确保修改不会导致系统出现问题。</li>
</ol>
<p>请注意，修改 DSDT 表是一项高风险的任务，可能会导致系统无法启动或出现其他严重问题。如果您没有足够的经验和知识，建议不要随意修改 DSDT 表。在特定的情况下，您也可以考虑与操作系统社区和硬件制造商合作，以获得更准确和可靠的解决方案。</p>
<p>替换操作系统中的 DSDT 表：</p>
<ol>
<li><strong>备份原始 DSDT 表：</strong> 在进行替换之前，务必备份原始的 DSDT 表，以防止出现问题时能够恢复系统。您可以将原始 DSDT 表保存到一个安全的位置。</li>
<li><strong>编辑和编译 DSDT 表：</strong> 使用 AML 编辑器进行编辑和编译您的修改后的 DSDT 表。</li>
<li><strong>将修改后的 DSDT 表嵌入到内核：</strong> 您需要将修改后的 DSDT 表嵌入到操作系统内核中，以便内核能够在启动时使用它。这可能涉及到编译操作系统内核时的一些配置选项。</li>
<li><strong>更新操作系统引导选项：</strong> 您可能需要更新操作系统的引导选项，以确保内核能够加载您修改后的 DSDT 表。这可能涉及到引导加载程序的配置文件（如 GRUB 或 UEFI 引导管理器）。</li>
<li><strong>重启系统：</strong> 在完成上述步骤后，重启计算机以应用修改后的 DSDT 表。</li>
<li><strong>验证和测试：</strong> 在系统重新启动后，务必进行充分的测试和验证，确保修改后的 DSDT 表不会导致系统出现问题。</li>
</ol>
<p>请注意，上述步骤可能因操作系统和硬件而有所不同。修改 DSDT 表是一个风险较高的操作，可能会导致系统无法启动或出现其他严重问题。在进行操作之前，请务必充分了解操作系统和硬件的工作原理，最好在实验环境中进行测试。</p>
<p>如果您不确定如何操作或缺乏相关经验，请考虑寻求专业人士的帮助，或在相关的技术社区寻求建议。</p>
<h2 id="比较文件或路径是否相同（抄systemd的代码）："><a href="#比较文件或路径是否相同（抄systemd的代码）：" class="headerlink" title="比较文件或路径是否相同（抄systemd的代码）："></a>比较文件或路径是否相同（抄systemd的代码）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 比较两个文件是否相同</span><br><span class="line">int files_same(const char *filea, const char *fileb, int flags) &#123;</span><br><span class="line">        struct stat a, b;</span><br><span class="line"></span><br><span class="line">        assert(filea);</span><br><span class="line">        assert(fileb);</span><br><span class="line"></span><br><span class="line">        if (fstatat(AT_FDCWD, filea, &amp;a, flags) &lt; 0)</span><br><span class="line">                return -errno;</span><br><span class="line"></span><br><span class="line">        if (fstatat(AT_FDCWD, fileb, &amp;b, flags) &lt; 0)</span><br><span class="line">                return -errno;</span><br><span class="line"></span><br><span class="line">        return a.st_dev == b.st_dev &amp;&amp;</span><br><span class="line">               a.st_ino == b.st_ino;</span><br><span class="line">&#125;</span><br><span class="line">// 实现了对两个路径字符串的&quot;排序比较&quot;</span><br><span class="line">int path_compare(const char *a, const char *b) &#123;</span><br><span class="line">        int d;</span><br><span class="line"></span><br><span class="line">        assert(a);</span><br><span class="line">        assert(b);</span><br><span class="line"></span><br><span class="line">        /* A relative path and an absolute path must not compare as equal.</span><br><span class="line">         * Which one is sorted before the other does not really matter.</span><br><span class="line">         * Here a relative path is ordered before an absolute path. */</span><br><span class="line">        d = (a[0] == &#x27;/&#x27;) - (b[0] == &#x27;/&#x27;);</span><br><span class="line">        if (d != 0)</span><br><span class="line">                return d;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">                size_t j, k;</span><br><span class="line"></span><br><span class="line">                // 将路径指针 a 和 b 前进到下一个非 / 字符。</span><br><span class="line">                a += strspn(a, &quot;/&quot;);</span><br><span class="line">                b += strspn(b, &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">                if (*a == 0 &amp;&amp; *b == 0)</span><br><span class="line">                        return 0;</span><br><span class="line"></span><br><span class="line">                /* Order prefixes first: &quot;/foo&quot; before &quot;/foo/bar&quot; */</span><br><span class="line">                if (*a == 0)</span><br><span class="line">                        return -1;</span><br><span class="line">                if (*b == 0)</span><br><span class="line">                        return 1;</span><br><span class="line">                // 这两行计算当前路径段的长度，即下一个 / 之前的字符数。</span><br><span class="line">                j = strcspn(a, &quot;/&quot;);</span><br><span class="line">                k = strcspn(b, &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">                /* Alphabetical sort: &quot;/foo/aaa&quot; before &quot;/foo/b&quot; */</span><br><span class="line">                // 这行使用 memcmp 函数比较两个路径段的字节内容，最多比较 j 和 k 个字节。</span><br><span class="line">                d = memcmp(a, b, MIN(j, k));</span><br><span class="line">                if (d != 0)</span><br><span class="line">                        return (d &gt; 0) - (d &lt; 0); /* sign of d */</span><br><span class="line"></span><br><span class="line">                /* Sort &quot;/foo/a&quot; before &quot;/foo/aaa&quot; */</span><br><span class="line">                d = (j &gt; k) - (j &lt; k);  /* sign of (j - k) */</span><br><span class="line">                if (d != 0)</span><br><span class="line">                        return d;</span><br><span class="line">                // 这两行将路径指针 a 和 b 前进到下一个 / 之后的位置，以准备比较下一个路径段。</span><br><span class="line">                a += j;</span><br><span class="line">                b += k;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//比较路径是否相同</span><br><span class="line">bool path_equal(const char *a, const char *b) &#123;</span><br><span class="line">        return path_compare(a, b) == 0;</span><br><span class="line">&#125;</span><br><span class="line">bool path_equal_or_files_same(const char *a, const char *b, int flags) &#123;</span><br><span class="line">        return path_equal(a, b) || files_same(a, b, flags) &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line">//判断是不是绝对路径</span><br><span class="line">bool path_is_absolute(const char *p) &#123;</span><br><span class="line">        return p[0] == &#x27;/&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="213277-grub菜单显示风格问题"><a href="#213277-grub菜单显示风格问题" class="headerlink" title="213277 grub菜单显示风格问题"></a>213277 grub菜单显示风格问题</h2><ul>
<li>主要原因: theme.txt为空.导致显示的实际是以图形界面显示字符菜单</li>
<li>有关theme.txt, 并没有控制菜单是否有边框的选项.<a target="_blank" rel="noopener" href="https://www.gnu.org/software/grub/manual/grub/html_node/Theme-file-format.html">https://www.gnu.org/software/grub/manual/grub/html_node/Theme-file-format.html</a></li>
</ul>
<h2 id="213181-安装时使用lvm分区第二系统无法正确引导"><a href="#213181-安装时使用lvm分区第二系统无法正确引导" class="headerlink" title="213181 安装时使用lvm分区第二系统无法正确引导"></a>213181 安装时使用lvm分区第二系统无法正确引导</h2><p>此问题关键在&#x2F;etc&#x2F;grub.d&#x2F;30_os-prober:292, 这里是在第二系统中尝试生成menu entry中包含root&#x3D;的那一行, 其中${LPARAMS}就是root&#x3D;参数</p>
<p>$LPARAMS获取主要通过linux-boot-prober, 这是一个shell脚本, 在46行会遍历所有&#x2F;usr&#x2F;lib&#x2F;linux-boot-probes&#x2F;mounted目录下的脚本并尝试搜索grub.cfg, LPARAMS其实就是linux那一行的运行参数</p>
<p>经过以上分析, 我们知道新生成的grub.cfg与原有的grub.cfg是有关联的. 那么问题的根因也就明了了.</p>
<h2 id="华为适配grub相关问题"><a href="#华为适配grub相关问题" class="headerlink" title="华为适配grub相关问题"></a>华为适配grub相关问题</h2><p>主要在&#x2F;etc&#x2F;grub.d&#x2F;00_header.in, 30_uefi-firmware.in<br>一般的arm设备是不支持背景图片的,华为除外.grub识别华为设备是通过dmidecode<br>一些调试手段:<br>其实grub.cfg可以看作是在grub命令行中的一个脚本, 其中所有条目都可以作为命令行在grub命令行中执行. 举例来说:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terminal_output gfxterm 设置图形界面</span><br><span class="line">terminal_output console 设置纯字符界面显示</span><br><span class="line">background_image /grub/themes/deepin/background.jpg 设置背景图片</span><br><span class="line">videoinfo 查看支持分辨率(有时候可能不准)</span><br><span class="line">loadfont ($root)/boot/grub/font.pf2 载入字体, 有时候字符界面出现异常字符可能会和字符集有关</span><br></pre></td></tr></table></figure>

<h2 id="systemd引导阶段出现问题的故障排查"><a href="#systemd引导阶段出现问题的故障排查" class="headerlink" title="systemd引导阶段出现问题的故障排查"></a>systemd引导阶段出现问题的故障排查</h2><ol>
<li><p>启用debug-shell, 此功能一般默认已被屏蔽, 参考<a target="_blank" rel="noopener" href="https://gerrit.uniontech.com/c/base/systemd/+/23900">https://gerrit.uniontech.com/c/base/systemd/+/23900</a></p>
<p>241.9-1+dde</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230816152845195.png" alt="image-20230816152845195"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230816152925334.png" alt="image-20230816152925334"></p>
</li>
<li><p>systemd.confirm_spawn&#x3D;1逐步调试<br>以212431为例进行展开.<br>此问题最终定位是由于laptop_mode引起, 我们可以尝试查看一下这个项目的代码, 全部由shell组成.</p>
</li>
</ol>
<p>问题关键点在于1234行, 此处由于使用了&amp;符号使得所有脚本同时执行. 我们可以去掉这个符号, 方便我们调试<br>需要注意的是, 启动阶段虽然开启了debug-shell, 但是由于启动的早期阶段本地磁盘并未挂载, 修改脚本操作需要在磁盘挂载后进行</p>
<h2 id="200217"><a href="#200217" class="headerlink" title="200217"></a>200217</h2><p>一个安全问题. 实际上只是因为合法文件损坏导致. 与其他文件格式相比, TIFF格式没有CRC校验和字段.<br>这里可以提出两个问题. CRC校验的内存占用进一步延伸出md5sum的内存占用是否比TIFF那种直接载入整个文件消耗要小</p>
<h2 id="locale-gen-命令"><a href="#locale-gen-命令" class="headerlink" title="locale-gen 命令"></a><code>locale-gen</code> 命令</h2><p>代码在glibc中</p>
<p><code>locale-gen</code> 命令主要的工作是根据 <code>/etc/locale.gen</code> 文件中的配置生成所需的本地化数据文件。这些数据文件包括区域设置相关的语言、字符集、货币符号等信息，供系统中的应用程序使用。</p>
<p>在执行 <code>locale-gen</code> 命令时，它会做以下事情：</p>
<ol>
<li><p>读取 <code>/etc/locale.gen</code> 文件，该文件包含了一系列的区域设置配置行，每行表示一种区域设置。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230817141603929.png" alt="image-20230817141603929"></p>
</li>
<li><p>对于每个配置行，如果未被注释掉，<code>locale-gen</code> 将根据配置生成对应的本地化数据文件。</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230817141634381.png" alt="image-20230817141634381"></p>
</li>
<li><p>生成的本地化数据文件通常保存在 <code>/usr/lib/locale</code> 或类似的目录中，不同发行版可能有所不同。</p>
</li>
<li><p>在生成数据文件后，<code>locale-gen</code> 命令可能会更新一些系统相关的缓存，以便系统中的应用程序能够快速访问这些本地化数据。</p>
</li>
</ol>
<h2 id="修改init进程"><a href="#修改init进程" class="headerlink" title="修改init进程"></a>修改init进程</h2><p>可以通过修改grub参数修改init进程,如init&#x3D;&#x2F;bin&#x2F;bash这样的参数</p>
<h2 id="systemd的inhibit机制："><a href="#systemd的inhibit机制：" class="headerlink" title="systemd的inhibit机制："></a>systemd的inhibit机制：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230821143614643.png" alt="image-20230821143614643"></p>
<h2 id="学习下lightdm获取给自己发送信号进程的机制："><a href="#学习下lightdm获取给自己发送信号进程的机制：" class="headerlink" title="学习下lightdm获取给自己发送信号进程的机制："></a>学习下lightdm获取给自己发送信号进程的机制：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static int signal_pipe[2];</span><br><span class="line"></span><br><span class="line">if (pipe (signal_pipe) != 0)</span><br><span class="line">        g_critical (&quot;Failed to create signal pipe&quot;);</span><br><span class="line">    fcntl (signal_pipe[0], F_SETFD, FD_CLOEXEC);</span><br><span class="line">    fcntl (signal_pipe[1], F_SETFD, FD_CLOEXEC);</span><br><span class="line">    g_io_add_watch (g_io_channel_unix_new (signal_pipe[0]), G_IO_IN, handle_signal, NULL);</span><br><span class="line">    action.sa_sigaction = signal_cb;</span><br><span class="line">    sigemptyset (&amp;action.sa_mask);</span><br><span class="line">    action.sa_flags = SA_SIGINFO | SA_RESTART;</span><br><span class="line">    sigaction (SIGTERM, &amp;action, NULL);</span><br><span class="line">    sigaction (SIGINT, &amp;action, NULL);</span><br><span class="line">    sigaction (SIGUSR1, &amp;action, NULL);</span><br><span class="line">    sigaction (SIGUSR2, &amp;action, NULL);</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">signal_cb (int signum, siginfo_t *info, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    /* Check if we are from a forked process that hasn&#x27;t updated the signal handlers or execed.</span><br><span class="line">       If so, then we should just quit */</span><br><span class="line">    if (getpid () != signal_pid)</span><br><span class="line">        _exit (EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    /* Write signal to main thread, if something goes wrong just close the pipe so it is detected on the other end */</span><br><span class="line">    if (write (signal_pipe[1], &amp;info-&gt;si_signo, sizeof (int)) &lt; 0 ||</span><br><span class="line">        write (signal_pipe[1], &amp;info-&gt;si_pid, sizeof (pid_t)) &lt; 0)</span><br><span class="line">        close (signal_pipe[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static gboolean</span><br><span class="line">handle_signal (GIOChannel *source, GIOCondition condition, gpointer data)</span><br><span class="line">&#123;</span><br><span class="line">    errno = 0;</span><br><span class="line">    int signo;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if (read (signal_pipe[0], &amp;signo, sizeof (int)) != sizeof (int) ||</span><br><span class="line">        read (signal_pipe[0], &amp;pid, sizeof (pid_t)) != sizeof (pid_t))</span><br><span class="line">    &#123;</span><br><span class="line">        g_warning (&quot;Error reading from signal pipe: %s&quot;, strerror (errno));</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_debug (&quot;Got signal %d from process %d&quot;, signo, pid);</span><br><span class="line"></span><br><span class="line">    Process *process = g_hash_table_lookup (processes, GINT_TO_POINTER (pid));</span><br><span class="line">    if (process == NULL)</span><br><span class="line">        process = process_get_current ();</span><br><span class="line">    if (process)</span><br><span class="line">        g_signal_emit (process, signals[GOT_SIGNAL], 0, signo);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="开启和关闭安全管控："><a href="#开启和关闭安全管控：" class="headerlink" title="开启和关闭安全管控："></a>开启和关闭安全管控：</h2><p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230823100312504.png" alt="image-20230823100312504"></p>
<h2 id="设置允许任意应用安装："><a href="#设置允许任意应用安装：" class="headerlink" title="设置允许任意应用安装："></a>设置允许任意应用安装：</h2><p>两种方法：</p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230823100448905.png" alt="image-20230823100448905"></p>
<p><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230823100410141.png" alt="image-20230823100410141"></p>
<h2 id="kill进程可以这么写函数："><a href="#kill进程可以这么写函数：" class="headerlink" title="kill进程可以这么写函数："></a>kill进程可以这么写函数：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int kill_and_sigcont(pid_t pid, int sig) &#123;</span><br><span class="line">        int r;</span><br><span class="line"></span><br><span class="line">        r = kill(pid, sig) &lt; 0 ? -errno : 0;</span><br><span class="line"></span><br><span class="line">        /* If this worked, also send SIGCONT, unless we already just sent a SIGCONT, or SIGKILL was sent which isn&#x27;t</span><br><span class="line">         * affected by a process being suspended anyway. </span><br><span class="line">         如果这有效，也发送 SIGCONT，除非我们刚刚发送了 SIGCONT，或者发送了 SIGKILL，而该 SIGKILL 无论如何都不受进程挂起的影响。*/</span><br><span class="line"></span><br><span class="line">        //  SIGTERM信号会通知进程终止，但进程并不一定会立即终止。进程可能会忽略SIGTERM信号，或者它可能会终止，</span><br><span class="line">        // 但需要一些时间。发送SIGCONT信号可以确保进程在收到SIGTERM信号后立即终止，即使进程正在暂停状态。</span><br><span class="line">        if (r &gt;= 0 &amp;&amp; !IN_SET(sig, SIGCONT, SIGKILL))</span><br><span class="line">                (void) kill(pid, SIGCONT);</span><br><span class="line"></span><br><span class="line">        return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://blog.705553939.xyz">ALTNT</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/">http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%B5%84%E6%96%99/">资料</a></div><div class="post_share"><div class="social-share" data-image="/img/altnt.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="机器学习相关概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">机器学习相关概念</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/" title="数据库系统概论笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据库系统概论笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/altnt.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ALTNT</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ALTNT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#hexo%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">hexo命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">docker 命令:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmacvlan%E7%BD%91%E7%BB%9C"><span class="toc-number">2.1.</span> <span class="toc-text">创建macvlan网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">制作docker镜像并创建容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%9B%98%E5%88%BB%E5%BD%95%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">光盘刻录：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">时区设置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86%E6%9F%90%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">查看谁执行了某条命令:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quilt%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">quilt配置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wpa-cli"><span class="toc-number">7.</span> <span class="toc-text">wpa_cli:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%94%B5%E8%84%91%E6%94%AF%E4%B8%8D%E6%94%AF%E6%8C%81wpa%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">查看电脑支不支持wpa：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BD%91%E7%BB%9C%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">删除已连接的网络：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AAsignal-fd"><span class="toc-number">10.</span> <span class="toc-text">跟踪signal_fd:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bpfcc%E5%9C%A85-10%E5%86%85%E6%A0%B8%E4%B8%8A%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3"><span class="toc-number">11.</span> <span class="toc-text">bpfcc在5.10内核上不可用解决:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">内核编译：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Whether-in-the-real-environment"><span class="toc-number"></span> <span class="toc-text">Whether in the real environment</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDwpa%E6%9C%80%E4%B8%8A%E6%B8%B8%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">下载wpa最上游源码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8wpa%E5%BC%80%E7%83%AD%E7%82%B9%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">使用wpa开热点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BD%91%E7%BB%9C%EF%BC%9A-1"><span class="toc-number">3.</span> <span class="toc-text">删除已连接的网络：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bvim%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%89%AA%E5%88%87%E6%9D%BF"><span class="toc-number">4.</span> <span class="toc-text">查看vim是否支持剪切板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E8%8B%B1%E4%BC%9F%E8%BE%BE%E9%A9%B1%E5%8A%A8%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">重新安装英伟达驱动：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nvidia%E5%BC%80%E5%90%AFdrm%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">nvidia开启drm的设置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dbus-send%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">dbus-send：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-D-Bus-%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%B7%9Fd-feet%E6%89%93%E5%8D%B0%E7%9A%84%E7%B1%BB%E4%BC%BC%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">通过 D-Bus 访问接口，跟d-feet打印的类似：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E6%89%93%E5%8D%B0%E9%9D%9E%E4%BB%A5%E2%80%99-0%E2%80%99%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">一种打印非以’\0’结尾的字符串的方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Libinput%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">Libinput：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libevdev%E4%B8%ADlibevdev-events-c%E6%96%87%E4%BB%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">libevdev中libevdev-events.c文件对应的命令是什么？怎么使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A-dev-input-eventx%E5%91%A2%EF%BC%9F%E6%AF%94%E5%A6%82%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E8%A7%A6%E6%91%B8%E6%9D%BF%E8%AE%BE%E5%A4%87%E5%AF%B9%E5%BA%94%E5%93%AA%E4%B8%AAevent%EF%BC%88%E5%AE%9E%E9%99%85%E4%B8%8A%E6%B2%A1%E8%BF%99%E4%B9%88%E9%BA%BB%E7%83%A6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8libinput-debug-events%E7%84%B6%E5%90%8E%E7%A7%BB%E5%8A%A8%E9%BC%A0%E6%A0%87%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">如何确定&#x2F;dev&#x2F;input&#x2F;eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput debug-events然后移动鼠标就行了）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldconfig"><span class="toc-number">10.</span> <span class="toc-text">ldconfig:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">安装双系统：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA%E6%9C%BA%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">12.</span> <span class="toc-text">华为机型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd-analyze%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%BC%80%E6%9C%BA%E6%97%B6%E9%97%B4%E7%9A%84"><span class="toc-number">13.</span> <span class="toc-text">systemd-analyze是如何统计开机时间的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#firmware%E5%92%8Cloader"><span class="toc-number">13.1.</span> <span class="toc-text">firmware和loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel"><span class="toc-number">13.2.</span> <span class="toc-text">kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMake%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="toc-number">14.</span> <span class="toc-text">CMake基础学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mount"><span class="toc-number">15.</span> <span class="toc-text">Mount:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB%E6%89%93%E5%8D%B0%E6%89%80%E6%9C%89%E5%A0%86%E6%A0%88%EF%BC%9A"><span class="toc-number">16.</span> <span class="toc-text">GDB打印所有堆栈：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B2%E7%8F%91%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%9A"><span class="toc-number">17.</span> <span class="toc-text">玲珑包工具：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trace-cmd"><span class="toc-number">18.</span> <span class="toc-text">trace-cmd:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apparmor%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A"><span class="toc-number">19.</span> <span class="toc-text">apparmor官方文档：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scsi%E8%AE%BE%E5%A4%87%E6%89%AB%E6%8F%8F%EF%BC%9A"><span class="toc-number">20.</span> <span class="toc-text">scsi设备扫描：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">21.</span> <span class="toc-text">休眠的实现：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openssl-%E8%B0%83%E8%AF%95"><span class="toc-number">22.</span> <span class="toc-text">openssl 调试:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8Crtc%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%82%E8%80%83190897%EF%BC%89%EF%BC%9A"><span class="toc-number">23.</span> <span class="toc-text">双rtc问题（参考190897）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shutdown-reboot"><span class="toc-number">24.</span> <span class="toc-text">Shutdown&#x2F;reboot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd%E5%B8%B8%E8%A7%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">25.</span> <span class="toc-text">systemd常规启动流程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initrd-Initial-RAM-Disk-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-%C2%B6-http-www-jinbuguo-com-systemd-bootup-html-initrd-Initial-RAM-Disk-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">initrd(Initial RAM Disk) 启动流程[¶](http:&#x2F;&#x2F;www.jinbuguo.com&#x2F;systemd&#x2F;bootup.html#initrd(Initial RAM Disk) 启动流程)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%9C%BA%E6%B5%81%E7%A8%8B%C2%B6"><span class="toc-number">27.</span> <span class="toc-text">关机流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0D%E7%8A%B6%E6%80%81%E7%A8%8B%E5%BA%8F%E5%90%8E%E6%89%93%E5%8D%B0%E5%86%85%E6%A0%B8%E5%A0%86%E6%A0%88%EF%BC%9A"><span class="toc-number">28.</span> <span class="toc-text">出现D状态程序后打印内核堆栈：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E5%8F%98%E9%87%8D%E5%90%AF%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">29.</span> <span class="toc-text">休眠变重启问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BA%EF%BC%9A"><span class="toc-number">30.</span> <span class="toc-text">虚拟机搭建：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%A1%A5%E6%8E%A5"><span class="toc-number">30.0.1.</span> <span class="toc-text">设置网络桥接</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A6%96%E5%85%88%EF%BC%9A%E8%A6%81%E5%81%9C%E6%AD%A2%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="toc-number">30.0.1.0.1.</span> <span class="toc-text">首先：要停止网络服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E6%AC%A1%EF%BC%9A%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">30.0.1.0.2.</span> <span class="toc-text">其次：修改网络配置文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AEip"><span class="toc-number">30.0.1.0.3.</span> <span class="toc-text">手动设置ip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E4%BB%8EDHCP%E8%8E%B7%E5%8F%96ip"><span class="toc-number">30.0.1.0.4.</span> <span class="toc-text">自动从DHCP获取ip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%EF%BC%9A%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E4%BE%BF%E5%8F%AF"><span class="toc-number">30.0.1.0.5.</span> <span class="toc-text">最后：重新启动网络服务便可</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C-%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%A5network%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF%E5%B0%B1%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">30.0.1.0.6.</span> <span class="toc-text">启用虚拟网络(每次启动虚拟机报network相关错误就执行命令)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#X11%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">31.</span> <span class="toc-text">X11获取设备信息:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-is-enabled-%E8%BF%94%E5%9B%9E-indirect-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">systemctl is-enabled 返回 indirect 是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-enable-A-service%E5%90%8E%EF%BC%8C%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%90%8E%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%90%AF%E5%8A%A8A-service%EF%BC%8C%E5%8F%AA%E6%98%AF%E8%B5%B7%E4%BA%86A-socket%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">systemctl enable A.service后，开机启动后并没有启动A.service，只是起了A.socket，这是为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%ADservice%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A2%AB%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8D%95%E5%85%83%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">怎么判断service是一个被动的服务单元？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%98%AF%E8%A2%AB%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%8D%95%E5%85%83%E5%90%97-%EF%BC%9F-%E4%BB%8E%E5%93%AA%E4%B8%AA%E5%9C%B0%E6%96%B9%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">这个服务是被动服务单元吗 ？ 从哪个地方可以看出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-enable-%E6%AD%A4%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F-enable%E4%B9%8B%E5%90%8E%E5%BC%80%E6%9C%BA%E5%AF%B9%E6%AD%A4%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">36.</span> <span class="toc-text">systemctl enable 此服务会做什么？ enable之后开机对此服务会做什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-enable%E4%B8%8A%E9%9D%A2%E8%BF%99%E4%B8%AAservice%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F-enable%E4%B9%8B%E5%90%8E%E5%BC%80%E6%9C%BA%E6%AD%A4%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%90%AF%E5%8A%A8%E5%90%97"><span class="toc-number">37.</span> <span class="toc-text">systemctl enable上面这个service会做什么？ enable之后开机此服务会启动吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#audit%E5%AE%A1%E8%AE%A1%EF%BC%9A"><span class="toc-number">38.</span> <span class="toc-text">audit审计：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9-etc-shadow%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">39.</span> <span class="toc-text">1.手动修改&#x2F;etc&#x2F;shadow中的用户密码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">gdb调试宏定义并显示宏定义的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-ACL-access-control-list-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">Linux ACL(access control list)访问控制权限列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%81%E6%98%8A%E7%9A%84%E7%AC%94%E8%AE%B0%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">丁昊的笔记：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ubuntu-Tmux-%E5%90%AF%E7%94%A8%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">Ubuntu Tmux 启用鼠标滚动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">qemu虚拟机的配置文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#my-log-info"><span class="toc-number">5.</span> <span class="toc-text">my_log_info:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">C语言打印函数堆栈方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E4%BB%93%E5%BA%93%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">内网仓库：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blkid-l-t-%E2%80%9CUUID-9cd72106-5e81-4860-a8e1-8285bc74a5ac%E2%80%9D-o-device"><span class="toc-number">2.</span> <span class="toc-text">blkid -l -t “UUID&#x3D;9cd72106-5e81-4860-a8e1-8285bc74a5ac” -o device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usr-lib-klibc-bin-fstype%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">&#x2F;usr&#x2F;lib&#x2F;klibc&#x2F;bin&#x2F;fstype原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E7%9A%84%E6%89%80%E4%BB%A5%E5%B7%B2%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">查看某个版本号对应的包的所以已安装包：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdpkg%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">查看dpkg安装过程的详细信息：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E8%BF%99%E4%B8%AA%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-PCIe-Bus-Error"><span class="toc-number">6.</span> <span class="toc-text">报这个错的解决方法(PCIe Bus Error):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFcoredump%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">开启coredump：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">设置格式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%AF%B9%E5%BA%94%E7%9A%84limit%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">查看某个运行中的进程对应的limit配置：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E7%94%9F%E6%88%90coredump%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">使用内核机制生成coredump的过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gvfs"><span class="toc-number">10.</span> <span class="toc-text">gvfs:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87syslog%E8%BF%87%E6%BB%A4%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%EF%BC%88%E5%8F%AF%E7%94%A8%E6%9D%A5%E7%A0%94%E7%A9%B6%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%EF%BC%89%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2java%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">切换java：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2iptable%EF%BC%9A"><span class="toc-number">13.</span> <span class="toc-text">切换iptable：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iptables"><span class="toc-number"></span> <span class="toc-text">iptables</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">基本参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9%E8%BE%93%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">命令选项输入顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.2.</span> <span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.3.</span> <span class="toc-text">防火墙的策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E5%BD%93%E5%89%8D%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%84%E5%88%99%E5%92%8C%E8%AE%A1%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">清空当前的所有规则和计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%85%81%E8%AE%B8ssh%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">配置允许ssh端口连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E6%9C%AC%E5%9C%B0%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">允许本地回环地址可以正常使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.4.</span> <span class="toc-text">设置默认的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%99%BD%E5%90%8D%E5%8D%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">配置白名单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E7%9B%B8%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">开启相应的服务端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E8%A7%84%E5%88%99%E5%88%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.1.7.</span> <span class="toc-text">保存规则到配置文件中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%B7%B2%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.8.</span> <span class="toc-text">列出已设置的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%B7%B2%E6%9C%89%E8%A7%84%E5%88%99"><span class="toc-number">1.1.9.</span> <span class="toc-text">清除已有规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.10.</span> <span class="toc-text">删除已添加的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.1.11.</span> <span class="toc-text">开放指定的端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E8%94%BDIP"><span class="toc-number">1.1.12.</span> <span class="toc-text">屏蔽IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%87%BA%E5%8E%BB%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.13.</span> <span class="toc-text">指定数据包出去的网络接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.14.</span> <span class="toc-text">查看已添加的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99"><span class="toc-number">1.1.15.</span> <span class="toc-text">启动网络转发规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.16.</span> <span class="toc-text">端口映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.17.</span> <span class="toc-text">字符串匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2Windows%E8%A0%95%E8%99%AB%E7%9A%84%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.18.</span> <span class="toc-text">阻止Windows蠕虫的攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2SYN%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.19.</span> <span class="toc-text">防止SYN洪水攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0SECMARK%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.20.</span> <span class="toc-text">添加SECMARK记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Biptables-%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99%E7%9A%84%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%A6%82%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">查看iptables 加入规则的流程大概是这样的：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">更多实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">使用场景实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iptables-legacy-%E4%B8%8E-iptables-nft-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">iptables-legacy 与 iptables-nft 的关系与区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-iptables-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.</span> <span class="toc-text">与 iptables 命令的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87wayland"><span class="toc-number">5.</span> <span class="toc-text">切wayland :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8Blive%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">解压live系统：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2socket"><span class="toc-number">7.</span> <span class="toc-text">查询socket:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AAso%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">调试使用某个so文件的进程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libinput%E9%98%B2%E8%AF%AF%E8%A7%A6%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">libinput防误触配置：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%9F%9F%E7%AE%A1%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">禁用域管：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%98%AF%E5%90%A6%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">获取是否是笔记本：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service%E6%96%87%E4%BB%B6%E6%8B%92%E7%BB%9D%E6%89%8B%E5%8A%A8%E5%90%AF%E5%8A%A8%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">service文件拒绝手动启动：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd-service-%E4%BE%9D%E8%B5%96"><span class="toc-number">12.</span> <span class="toc-text">systemd service 依赖:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96"><span class="toc-number">12.1.</span> <span class="toc-text">一、自动依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%9A%90%E5%90%AB%E4%BE%9D%E8%B5%96"><span class="toc-number">12.1.1.</span> <span class="toc-text">1、隐含依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%BB%98%E8%AE%A4%E4%BE%9D%E8%B5%96"><span class="toc-number">12.1.2.</span> <span class="toc-text">2、默认依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd-service%E4%B8%AD%E7%9A%84Before-%E5%92%8CAfter-%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.2.</span> <span class="toc-text">systemd service中的Before&#x3D; 和After&#x3D;代表的含义是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88systemd-machine-id-commit-service%E4%B8%AD%E6%98%8E%E6%98%8E%E8%AE%BE%E7%BD%AE%E4%BA%86Before-sysinit-target-shutdown-target%EF%BC%8C%E4%BD%86%E6%98%AFsystemctl-list-dependences%E5%8D%B4%E6%98%BE%E7%A4%BAsystemd-machine-id-commit-service%E4%BE%9D%E8%B5%96sysinit-target"><span class="toc-number">12.2.1.</span> <span class="toc-text">为什么systemd-machine-id-commit.service中明明设置了Before&#x3D;sysinit.target shutdown.target，但是systemctl list-dependences却显示systemd-machine-id-commit.service依赖sysinit.target</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#before-After%E5%92%8CWantedby%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="toc-number">12.3.</span> <span class="toc-text">before After和Wantedby的区别是什么：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd-%E5%8D%95%E5%85%83%E7%9A%84dependencies-UNIT-REFERENCED-BY-%E5%92%8Cdependencies-UNIT-REFERENCES-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">systemd 单元的dependencies[UNIT_REFERENCED_BY]和dependencies[UNIT_REFERENCES]的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-set-default-%E5%85%B3%E9%97%AD%E5%92%8C%E5%BC%80%E5%90%AF%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="toc-number">13.</span> <span class="toc-text">systemctl set-default(关闭和开启图形化界面):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tmp%E7%9B%AE%E5%BD%95%E8%A2%AB%E6%B8%85%E7%A9%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.</span> <span class="toc-text">&#x2F;tmp目录被清空实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kms%E6%BF%80%E6%B4%BB%E7%A0%81%EF%BC%9A"><span class="toc-number">15.</span> <span class="toc-text">kms激活码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sd-bus-add-match-async-%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">sd_bus_add_match_async 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session-c1-device-226-0%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">17.</span> <span class="toc-text">session-c1-device-226-0代表什么意思:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdeb%E5%8C%85dbg%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">18.</span> <span class="toc-text">查看deb包dbg调试信息：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8C%85%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">18.1.</span> <span class="toc-text">判断一个包是否已安装的代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E6%9B%BF%E6%8D%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84shell%E5%91%BD%E4%BB%A4"><span class="toc-number">18.2.</span> <span class="toc-text">shell替换软件包版本号的shell命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#echo-e-%E2%80%9Caaaa-nbbbb%E2%80%9D-sed-%E2%80%98s-1-xx-g%E2%80%99-tr-%E2%80%98-n%E2%80%99-%E2%80%98-%E2%80%98"><span class="toc-number">18.3.</span> <span class="toc-text">echo -e “aaaa\nbbbb” | sed ‘s&#x2F;(.*)&#x2F;\1&#x3D;xx&#x2F;g’ | tr ‘\n’ ‘ ‘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbip%E8%AE%BE%E7%BD%AEu%E7%9B%98%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9A"><span class="toc-number">19.</span> <span class="toc-text">usbip设置u盘重定向：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95dde-daemon%EF%BC%9A"><span class="toc-number">20.</span> <span class="toc-text">调试dde-daemon：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E8%A1%A5%E4%B8%81"><span class="toc-number">21.</span> <span class="toc-text">打补丁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E6%92%A4%E9%94%80amend"><span class="toc-number">22.</span> <span class="toc-text">git撤销amend:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BEsocket%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">23.</span> <span class="toc-text">找socket对应的文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lightdm%E5%88%B0startdde%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">24.</span> <span class="toc-text">lightdm到startdde的整个流程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%9E%9A%E4%B8%BE%E5%80%BC%EF%BC%9A"><span class="toc-number">25.</span> <span class="toc-text">打印枚举值：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91kwin%E9%81%87%E5%88%B0%E5%A6%82%E4%B8%8B%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">26.</span> <span class="toc-text">编译kwin遇到如下问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gdb-set-substitute-path%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95"><span class="toc-number">27.</span> <span class="toc-text">gdb set substitute-path命令用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%A0%E4%BA%86%E5%93%AA%E4%B8%AA%E7%A3%81%E7%9B%98%E7%9A%84-%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%8F%8A%E7%A3%81%E7%9B%98%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4"><span class="toc-number">28.</span> <span class="toc-text">查看一个文件夹占了哪个磁盘的 空间以及磁盘所占空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%8F%AA%E7%AE%97%E4%B8%80%E5%B1%82"><span class="toc-number">29.</span> <span class="toc-text">查看一个文件夹下各文件所占空间大小，只算一层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bjournal%E6%9F%90%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%A5%E5%BF%97%EF%BC%9A"><span class="toc-number">30.</span> <span class="toc-text">查看journal某次启动的日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFdbus%E6%97%A5%E5%BF%97%EF%BC%9A"><span class="toc-number">31.</span> <span class="toc-text">开启dbus日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8BPFtrace%E8%B7%9F%E8%B8%AAioctl%E8%B0%83%E7%94%A8"><span class="toc-number">32.</span> <span class="toc-text">如何用BPFtrace跟踪ioctl调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tracepoint-syscalls-sys-enter-ioctl%E8%BF%99%E4%B8%AAtracepoint%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">tracepoint:syscalls:sys_enter_ioctl这个tracepoint是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pkexec%E6%8F%90%E6%9D%83"><span class="toc-number">34.</span> <span class="toc-text">pkexec提权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%80%E5%87%BA%EF%BC%9A"><span class="toc-number">35.</span> <span class="toc-text">查看某个服务为什么退出：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96USB%E8%AE%BE%E5%A4%87%E7%9A%84idVendor%E5%92%8CidProduct%E4%BF%A1%E6%81%AF%E3%80%82%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">36.</span> <span class="toc-text">获取USB设备的idVendor和idProduct信息。以下是几种常用的方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">37.</span> <span class="toc-text">检查二进制程序是否存在内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E5%99%A8%E7%9A%84%E6%97%A5%E5%BF%97%EF%BC%9A"><span class="toc-number">38.</span> <span class="toc-text">查看安装器的日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8-SELinux-%E7%9A%84%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">39.</span> <span class="toc-text">禁用 SELinux 的强制执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFwine%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97"><span class="toc-number">40.</span> <span class="toc-text">开启wine应用日志:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arecord%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91%EF%BC%9A"><span class="toc-number">41.</span> <span class="toc-text">arecord录制音频：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pulseaudio%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BB%A5%E7%B3%BB%E7%BB%9F%E7%BA%A7%E8%BF%90%E8%A1%8C%EF%BC%9A"><span class="toc-number">42.</span> <span class="toc-text">pulseaudio为什么不能以系统级运行：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E6%80%BB%E7%BA%BF%EF%BC%9A"><span class="toc-number">43.</span> <span class="toc-text">i2c总线：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wget%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%90%86%E4%B8%8B%E8%BD%BD%EF%BC%9A"><span class="toc-number">44.</span> <span class="toc-text">wget指定代理下载：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSDT-%E8%A1%A8"><span class="toc-number">45.</span> <span class="toc-text">DSDT 表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-DSDT-%E8%A1%A8"><span class="toc-number">46.</span> <span class="toc-text">修改 DSDT 表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%88%E6%8A%84systemd%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%89%EF%BC%9A"><span class="toc-number">47.</span> <span class="toc-text">比较文件或路径是否相同（抄systemd的代码）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#213277-grub%E8%8F%9C%E5%8D%95%E6%98%BE%E7%A4%BA%E9%A3%8E%E6%A0%BC%E9%97%AE%E9%A2%98"><span class="toc-number">48.</span> <span class="toc-text">213277 grub菜单显示风格问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#213181-%E5%AE%89%E8%A3%85%E6%97%B6%E4%BD%BF%E7%94%A8lvm%E5%88%86%E5%8C%BA%E7%AC%AC%E4%BA%8C%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%BC%95%E5%AF%BC"><span class="toc-number">49.</span> <span class="toc-text">213181 安装时使用lvm分区第二系统无法正确引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA%E9%80%82%E9%85%8Dgrub%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">50.</span> <span class="toc-text">华为适配grub相关问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd%E5%BC%95%E5%AF%BC%E9%98%B6%E6%AE%B5%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5"><span class="toc-number">51.</span> <span class="toc-text">systemd引导阶段出现问题的故障排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200217"><span class="toc-number">52.</span> <span class="toc-text">200217</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locale-gen-%E5%91%BD%E4%BB%A4"><span class="toc-number">53.</span> <span class="toc-text">locale-gen 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9init%E8%BF%9B%E7%A8%8B"><span class="toc-number">54.</span> <span class="toc-text">修改init进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd%E7%9A%84inhibit%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">55.</span> <span class="toc-text">systemd的inhibit机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E4%B8%8Blightdm%E8%8E%B7%E5%8F%96%E7%BB%99%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">56.</span> <span class="toc-text">学习下lightdm获取给自己发送信号进程的机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E5%AE%89%E5%85%A8%E7%AE%A1%E6%8E%A7%EF%BC%9A"><span class="toc-number">57.</span> <span class="toc-text">开启和关闭安全管控：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%81%E8%AE%B8%E4%BB%BB%E6%84%8F%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%EF%BC%9A"><span class="toc-number">58.</span> <span class="toc-text">设置允许任意应用安装：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E5%86%99%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">59.</span> <span class="toc-text">kill进程可以这么写函数：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" title="vscode插件开发">vscode插件开发</a><time datetime="2024-06-28T06:47:30.251Z" title="Created 2024-06-28 14:47:30">2024-06-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5/" title="强化学习相关概念">强化学习相关概念</a><time datetime="2024-06-28T04:03:18.846Z" title="Created 2024-06-28 12:03:18">2024-06-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="机器学习相关概念">机器学习相关概念</a><time datetime="2024-06-26T09:09:56.000Z" title="Created 2024-06-26 17:09:56">2024-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/" title="命令">命令</a><time datetime="2024-06-22T03:44:40.000Z" title="Created 2024-06-22 11:44:40">2024-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/" title="数据库系统概论笔记">数据库系统概论笔记</a><time datetime="2024-06-05T15:46:23.990Z" title="Created 2024-06-05 23:46:23">2024-06-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ALTNT</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>