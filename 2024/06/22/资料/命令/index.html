<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>命令 | ALTNT's Hexo Blog</title><meta name="author" content="ALTNT"><meta name="copyright" content="ALTNT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hexo命令 clean: 1hexo clean 生成网页 1hexo g 部署: 1hexo d 在本机上部署 1hexo s hexo添加对数学公式的支持 安装hexo-filter-mathjax和hexo-renderer-pandoc渲染器, 教程可以参考hexo-filter-mathjax项目主页: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-filter">
<meta property="og:type" content="article">
<meta property="og:title" content="命令">
<meta property="og:url" content="http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="ALTNT&#39;s Hexo Blog">
<meta property="og:description" content="hexo命令 clean: 1hexo clean 生成网页 1hexo g 部署: 1hexo d 在本机上部署 1hexo s hexo添加对数学公式的支持 安装hexo-filter-mathjax和hexo-renderer-pandoc渲染器, 教程可以参考hexo-filter-mathjax项目主页: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-filter">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://blog.705553939.xyz/img/altnt.jpeg">
<meta property="article:published_time" content="2024-06-22T03:44:40.000Z">
<meta property="article:modified_time" content="2024-08-17T04:17:12.742Z">
<meta property="article:author" content="ALTNT">
<meta property="article:tag" content="资料">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.705553939.xyz/img/altnt.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '命令',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-17 12:17:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/altnt.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ALTNT's Hexo Blog"><span class="site-name">ALTNT's Hexo Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-22T03:44:40.000Z" title="Created 2024-06-22 11:44:40">2024-06-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-08-17T04:17:12.742Z" title="Updated 2024-08-17 12:17:12">2024-08-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="命令"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="hexo命令">hexo命令</h2>
<p>clean:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>生成网页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>部署:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>在本机上部署</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h3 id="hexo添加对数学公式的支持">hexo添加对数学公式的支持</h3>
<p>安装hexo-filter-mathjax和hexo-renderer-pandoc渲染器,</p>
<p>教程可以参考hexo-filter-mathjax项目主页:</p>
<p>https://github.com/next-theme/hexo-filter-mathjax</p>
<p>另外也可以参考下,里面有如何卸载原来的渲染器的过程,否则有冲突:
https://blog.csdn.net/weixin_45511189/article/details/115798563</p>
<p>还有安装hexo-renderer-pandoc记得安装pandoc,不然会报错:</p>
<p>https://github.com/jgm/pandoc/releases</p>
<p>项目上有注意事项,仔细看格式,不然可能打印不出来</p>
<h2 id="docker-命令">docker 命令:</h2>
<h3 id="创建macvlan网络">创建macvlan网络</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/ALTNT/clashindocker#%E5%88%9B%E5%BB%BAmacvlan%E7%BD%91%E7%BB%9C"></a></p>
<p>为了能够让docker启动的容器作为家庭网络中的旁路由，因此需要创建macvlan网络。
其中
<code>192.168.3.1</code>为你局域网的网关，<code>em1</code>为你机器的网卡名称，这两个请根据实际情况修改。</p>
<ol type="1">
<li>（可选）让docker监听ipv6。 编辑etc/docker/daemon.json文件</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span>  </span><br><span class="line">      <span class="attr">"ipv6"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">"fixed-cidr-v6"</span><span class="punctuation">:</span> <span class="string">"2409:DA8:8001:7B22:200::/80"</span>  </span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>创建macvlan 没有ipv6的版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan \  </span><br><span class="line">     --subnet=192.168.3.0/24 \  </span><br><span class="line">     --gateway=192.168.3.1 \  </span><br><span class="line">      -o parent=em1 \  </span><br><span class="line">      -o macvlan_mode=bridge macnet</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>我这边本地dockerinclash配置如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 -o macvlan_mode=bridge macnet</span><br></pre></td></tr></table></figure>
<p>有ipv6的版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --ipv6 \  </span><br><span class="line">    --subnet=192.168.3.0/24 \  </span><br><span class="line">    --gateway=192.168.3.1 \  </span><br><span class="line">    --subnet=2409:DA8:8001:7B22:200::/80 </span><br><span class="line">    --gateway=2409:DA8:8001:7B22:200::1 \  </span><br><span class="line">     -o parent=em1 \  </span><br><span class="line">     -o macvlan_mode=bridge macnet</span><br></pre></td></tr></table></figure>
<p>注意看含义，有的值需要变</p>
<p>查看网络:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<h3 id="制作docker镜像并创建容器">制作docker镜像并创建容器</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/ALTNT/clashindocker#%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"></a></p>
<ol type="1">
<li>获取代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/UntaggedRui/clashindocker</span><br><span class="line">cd clashindocker</span><br><span class="line">cp example.yml config.yml</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>更改地址 <code>docker-compose.yml</code>中的
<code>ipv4_address</code>为你的ip地址.</li>
<li>更改 <code>config.yml</code>中的 <code>proxy-provider</code>的
<code>url</code>为你的机场订阅地址.</li>
<li>启动容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>
<p>如果遇到无法访问或者启动的问题，可以查看一下日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure>
<p>或者</p>
<p>在有项目的Dockerfile的目录运行</p>
<p><code>docker build -t TARGET_NAME .</code></p>
<p><code>TARGET_NAME</code>为镜像名称和版本，可以自己起个名字</p>
<p>官方是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --tag name:tag . #如docker build . -t keynetworks/ztncui:latest</span><br></pre></td></tr></table></figure>
<h3 id="生成并运行容器">生成并运行容器</h3>
<p>docker pull ghcr.io/raywangqvq/bilibili_tool_pro docker run -d
--name="bili" -v /bili/Logs:/app/Logs -e Ray_DailyTaskConfig__Cron="0 15
* * *" -e Ray_LiveLotteryTaskConfig__Cron="0 22 * * *" -e
Ray_UnfollowBatchedTaskConfig__Cron="0 6 1 * *" -e
Ray_VipBigPointConfig__Cron="7 1 * * *"
ghcr.io/raywangqvq/bilibili_tool_pro</p>
<h3 id="查看实时日志">查看实时日志</h3>
<p>docker logs -f bili</p>
<h3 id="删除容器">删除容器</h3>
<p>docker rm bili</p>
<h3 id="进入容器">进入容器</h3>
<p>docker exec -it bili /bin/bash</p>
<h3 id="查看一下缓存情况">查看一下缓存情况：</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker system df </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image.png" alt="alt text">
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>可以发现，存在大量使用 docker build 命令时产生的镜像缓存 (Build
Cache) ，下面使用命令 prune 将其彻底清理。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker system prune --help</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line">Flag shorthand -h has been deprecated, please use --help</span><br><span class="line"></span><br><span class="line">Usage:  docker system prune [OPTIONS]</span><br><span class="line"></span><br><span class="line">Remove unused data</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Remove all unused images not just dangling ones</span><br><span class="line">      --filter filter   Provide filter values (e.g. 'label=&lt;key&gt;=&lt;value&gt;')</span><br><span class="line">  -f, --force           Do not prompt for confirmation</span><br><span class="line">      --volumes         Prune volumes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="docker国内镜像加速">docker国内镜像加速</h3>
<p>对于国内加速镜像，直接设置镜像地址就好了：
编辑/etc/docker/daemon.json添加</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"registry-mirrors"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"https://docker.mirrors.ustc.edu.cn"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>也可以用其它镜像比如阿里云 或者 daocloud 等等。</p>
<h3 id="docker-pull-拉取镜像时设置代理">docker pull
拉取镜像时设置代理</h3>
<p>docker
的代理设置是一件比较麻烦的事情，很容易出问题，但是弄懂了也还是比较清楚。</p>
<p>首先， docker pull 和 docker build/docker run
使用代理的方式不一样！</p>
<p>docker pull 的代理被 systemd 接管，所以需要设置 systemd…</p>
<p>sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment="HTTP_PROXY=http://127.0.0.1:8123"</span><br><span class="line">Environment="HTTPS_PROXY=http://127.0.0.1:8123"</span><br></pre></td></tr></table></figure>
<p>这里的127.0.0.1是直接用了本机的 http 代理，然后重启服务才能生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>可以通过sudo systemctl show --property=Environment
docker看到设置的环境变量。</p>
<p>然后docker pull就会使用代理啦！</p>
<p>这里 HTTP 代理可以通过你的代理软件开出来，如果你的代理软件只能开出来
socks5 代理的话，你可以用 polipo 开一个 http 代理使用</p>
<h3 id="build-镜像时使用代理">build 镜像时使用代理</h3>
<p>在 build 时添加 --build-arg 参数来设置生成镜像时使用的环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg http_proxy=http://172.17.0.1:8123 --build-arg https_proxy=http://172.17.0.1:8123 -t image_name .</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 ip 地址用了默认虚拟网卡docker0
的地址172.17.0.1，因为build的时候network参数默认为bridge，即docker内部会使用这个网段，因为要访问到宿主机的代理只能这样访问；
另外，也可以设置参数--network=host
来直接和宿主机共用网络，就能直接使用127.0.0.1来访问到宿主机了</p>
<h3 id="设置-docker-全局代理">设置 docker 全局代理</h3>
<p>设置方法参考官方文档： https://docs.docker.com/network/proxy/</p>
<p>注意新版和旧版本(17.07以前)设置方法不一样，比旧版更简单而且不需要重启服务,网上文章基本都是针对旧版本的,可能未来又变化了,所以多看官方文档~
以及这种设置方法只对 build 和 run 的容易有用， docker pull
要按照上面的方法设置。</p>
<p>vim ~/.docker/config.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line"> <span class="attr">"proxies"</span><span class="punctuation">:</span></span><br><span class="line"> <span class="punctuation">{</span></span><br><span class="line">   <span class="attr">"default"</span><span class="punctuation">:</span></span><br><span class="line">   <span class="punctuation">{</span></span><br><span class="line">     <span class="attr">"httpProxy"</span><span class="punctuation">:</span> <span class="string">"http://172.17.0.1:8123"</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">"httpsProxy"</span><span class="punctuation">:</span> <span class="string">"http://172.17.0.1:8123"</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">"noProxy"</span><span class="punctuation">:</span> <span class="string">"localhost,127.0.0.1,.daocloud.io"</span></span><br><span class="line">   <span class="punctuation">}</span></span><br><span class="line"> <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>这样设置后，build和run都会将http_proxy和https_proxy
ftp_proxy变量设置成对应的代理地址，如果你在容器里面不想使用这个代理了，需要export
http_proxy= 和 export https_proxy= 将两个变量设置为空</p>
<p>注意:</p>
<p>仅支持 http https ftp 协议，不支持 socks5
协议（2022.3.24，未来不一定，官方文档为准），可以使用polipo创建一个http代理服务，参考https://neucrack.com/p/275</p>
<p>这里使用了172.17.0.1(docker 虚拟网卡地址), 而不是127.0.0.1,
这是因为这是从容器内部的角度来看的,
容器内部要使用代理,默认情况下只能访问这个虚拟网卡的地址,
127.0.0.1是容器内部, 如果代理在宿主机, 要使用
虚拟网卡的地址才能访问到.</p>
<p>这个文件一旦存在, docker就会使用这里面的代理,
包括创建的容器都会使用它。 所以不需要代理了, 需要关闭代理,
就是把文件重命名一下就好了,
这点用起来确实挺麻烦，也许未来会优化体验吧。</p>
<p>注意， 一个容器一旦生成， 这些环境变量（http_proxy https_proxy
ftp_proxy no_proxy）就会被继承到容器中， 就算把config.json删除，
这个容器依然使用创建时的环境变量，可以手动在容器内重新设置这些环境变量，
这点也挺容易让人头疼的， 一定要注意。</p>
<p>比如 有个镜像叫 imageA, 现在设置~/.docker/config.json也就是有代理，
然后docker run创建容器 A, 然后再重命名config.json， 创建容器B，
然后会发现无论现在怎么修改config.json， 容器A
B都会使用它被创建时的代理设置，即容器A使用代理， 容器B不使用代理</p>
<h3 id="容器使用宿主机的代理的几种方法总结">容器使用宿主机的代理的几种方法总结</h3>
<p>和 build 时类似，只需要在 生成容器时（run -e http_proxy=...） 或者
容器中
设置环境变量http_proxy和https_proxy变量即可，同样需要注意容易使用的网络类型是bridge还是host，根据类别设置正确的代理
ip 地址</p>
<p>方法一： 直接在容器内使用（推荐</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY='socks5://172.17.0.1:1080'</span><br></pre></td></tr></table></figure>
<p>这里ip地址使用的是宿主机的ip</p>
<p>方法二： 与宿主机共享网络时直接在容器内使用
创建容器时使用--network=host参数</p>
<p>然后在docker内设置代理，比如全局代理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY='socks5://127.0.0.1:1080'</span><br></pre></td></tr></table></figure>
<p>这样就可以使用宿主机的代理了</p>
<p>但是要注意， 如果是用--network=host，这样的话使用 -p
参数映射端口就没用了， 即所有端口都是开放和宿主机共享的</p>
<p>方法三： 映射代理端口后直接在容器内使用 docker
run时带参数-p映射代理的端口到容器， 在容器里面使用即可，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run  -p 1080:1080 .....</span><br><span class="line">export ALL_PROXY='socks5://127.0.0.1:1080'</span><br></pre></td></tr></table></figure>
<p>方法四： docker配置全局代理，以在生成容器时自动设置代理变量 设置
docker 全局代理，比如设置了http://172.17.0.1:8123，
容器内全都会走这个代理，除了配置文件中的白名单里面的地址以外</p>
<p>注意： 全局代理和 --network=host 参数只能用一个，不然就容易混乱</p>
<h2 id="git配置和取消代理">git配置和取消代理</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br><span class="line">或者</span><br><span class="line">git config --global http.proxy http://localhost:7890</span><br><span class="line">git config --global https.proxy https://localhost:7890</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line">确认Mac上git的配置</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<p>或者直接修改 <code>~/.gitconfig</code></p>
<p><strong>仅为github.com设置socks5代理(推荐这种方式,
公司内网就不用设代理了, 多此一举):</strong>
<code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</code>
其中1086是socks5的监听端口, 这个可以配置的, 每个人不同,
在macOS上一般为1086. 设置完成后, ~/.gitconfig文件中会增加以下条目:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[http "https://github.com"]</span><br><span class="line">    proxy = socks5://127.0.0.1:1086</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>ssh访问 需要修改~/.ssh/config文件, 没有的话新建一个.
同样仅为github.com设置代理:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -v -x 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure>
<p>如果是在Windows下, 则需要个性%home%.ssh, 其中内容类似于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -S 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure>
<p>这里-S表示使用socks5代理, 如果是http代理则为-H. connect工具git自带,
在.</p></li>
</ol>
<h2 id="clash配置代理">clash配置代理</h2>
<p>要想让其他设备通过设置网关的方式将clash所在的设备设置为网关有三种方法:</p>
<p>开启ip转发功能。 mac: sudo sysctl -e net.inet.ip.forwarding=1 ubuntu:
sudo sysctl -w net.ipv4.ip_forward=1</p>
<p>方法一:</p>
<p>安装官方提供的方法,将下面的内容添加到config.yml中,好像只支持linux,这个方法应该也相当于方法三,只不过是官方实现了,我后面才发现的:</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722848548632.png" alt="1722848548632">
<figcaption aria-hidden="true">1722848548632</figcaption>
</figure>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the TPROXY listener</span></span><br><span class="line"><span class="attr">tproxy-port:</span> <span class="number">9898</span></span><br><span class="line"></span><br><span class="line"><span class="attr">iptables:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># default is false</span></span><br><span class="line">  <span class="attr">inbound-interface:</span> <span class="string">eth0</span> <span class="comment"># detect the inbound interface, default is 'lo'</span></span><br></pre></td></tr></table></figure>
<p>这种方式不能开tun模式,会报错如下:</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722848865964.png" alt="1722848865964">
<figcaption aria-hidden="true">1722848865964</figcaption>
</figure>
<p>方法二:</p>
<p>在config.yml开启tun模式.但是测试tun模式下我的该设备通过ddns配置的域名,域名能正确获取到公网ip,但是无法访问(我还没找到原因,网上没有相关的资料,感觉还是tun模式的实现原理的问题,或者说tun模式新增这个tun设备,在使用iptable将流量转发给这个设备再返回时出现了问题,唉不想研究,如果想研究我感觉按照下面的思路应该很容易发现问题出现的原因:看看打开tun模式运行了哪些iptables命令),所以我不打算用这种方式</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722426239320.png" alt="1722426239320">
<figcaption aria-hidden="true">1722426239320</figcaption>
</figure>
<p>方法三(建议使用方法一):</p>
<p>配置iptables规则,接管流量,好处是不影响通过域名访问该设备(有可能这台机器导致docker无法正常pull镜像(我一开始开启tun模式然后运行下面的
脚本遇到了,国内源也不行),唉,不想找解决办法了,反正我后面没遇到,我估计是当时我同时开启了tun模式和下面的脚本,iptables规则冲突了,可能流量被一边劫持了,遇到了应该只要开机别运行这个脚本然后重启电脑就好了,反正我当时是这么解决的)</p>
<p>config_iptable.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在nat表中新建一个clash规则链</span></span><br><span class="line">iptables -t nat -N CLASH</span><br><span class="line">iptables -t nat -F CLASH</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">排除环形地址与保留地址，匹配之后直接RETURN</span></span><br><span class="line">iptables -t nat -A CLASH -d 0.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 10.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 127.0.0.0/8 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 169.254.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 172.16.0.0/12 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 192.168.0.0/16 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 224.0.0.0/4 -j RETURN</span><br><span class="line">iptables -t nat -A CLASH -d 240.0.0.0/4 -j RETURN</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重定向tcp流量到本机7892端口</span></span><br><span class="line">iptables -t nat -A CLASH -p tcp -j REDIRECT --to-port 7892</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拦截外部tcp数据并交给clash规则链处理</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -j CLASH</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在nat表中新建一个clash_dns规则链</span></span><br><span class="line">iptables -t nat -N CLASH_DNS</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清空clash_dns规则链</span></span><br><span class="line">iptables -t nat -F CLASH_DNS</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重定向udp流量到本机1053端口</span></span><br><span class="line">iptables -t nat -A CLASH_DNS -p udp -j REDIRECT --to-port 1053</span><br><span class="line">iptables -t nat -A CLASH_DNS -p tcp -j REDIRECT --to-port 1053</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓取本机产生的53端口流量交给clash_dns规则链处理</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iptables -t nat -I OUTPUT -p udp --dport 53 -j CLASH_DNS</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拦截外部upd的53端口流量交给clash_dns规则链处理</span></span><br><span class="line">iptables -t nat -I PREROUTING -p udp --dport 53 -j CLASH_DNS</span><br><span class="line">iptables -t nat -I PREROUTING -p tcp --dport 53 -j CLASH_DNS</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722426398285.png" alt="1722426398285">
<figcaption aria-hidden="true">1722426398285</figcaption>
</figure>
<p>docker
pull不了image(--------------------------------好吧,当我没说,只是adguard-home安装不了)</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722428771818.png" alt="1722428771818">
<figcaption aria-hidden="true">1722428771818</figcaption>
</figure>
<p>配置代理,反正我试了运行clash的机器上上面两种方式都还要执行这个步骤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/environment </span><br><span class="line">PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin"</span><br><span class="line">export http_proxy="http://127.0.0.1:7890"</span><br><span class="line">export https_proxy="http://127.0.0.1:7890"</span><br><span class="line">export no_proxy="localhost, 127.0.0.1"</span><br><span class="line"></span><br><span class="line">visudo:</span><br><span class="line">Defaults env_keep+="http_proxy https_proxy no_proxy"</span><br></pre></td></tr></table></figure>
<h3 id="常见问题">常见问题</h3>
<p>1、clash勾选了仅内网还是被跑流量</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722592336269.png" alt="1722592336269">
<figcaption aria-hidden="true">1722592336269</figcaption>
</figure>
<h2 id="nginx-proxy-manager输入账号密码点击登录却遇到bad-gateway"><a target="_blank" rel="noopener" href="http://192.168.1.5:9081/">Nginx Proxy
Manager</a>输入账号密码点击登录却遇到bad gateway</h2>
<p>解决办法:</p>
<p>等一会就行了,之后就发现能登录了,等一下是因为在初始化安装些东西</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722855105546.png" alt="1722855105546">
<figcaption aria-hidden="true">1722855105546</figcaption>
</figure>
<p>看日志发现报错如下:</p>
<p>certbot --version The
'certbot_dns_cloudflare._internal.dns_cloudflare' plugin errored while
loading: No module named 'CloudFlare'. You may need to remove or update
this plugin. The Certbot log will contain the full error details and
this should be reported to the plugin developer.</p>
<h2 id="光盘刻录">光盘刻录：</h2>
<p>过程：
开始刻录-&gt;卸载光盘-&gt;读取光盘内分段数据-&gt;数据打包-&gt;刻录。
系统刻录光盘日志 ~/.cache/deepin/discburn/uburn/xxxx/log</p>
<p>xorriso -dev /dev/sr0 -map /src/ /dest/ -volid 卷标 -close off
-commit -eject</p>
<h2 id="时区设置">时区设置：</h2>
<p>date -R #查看当期时区 tzselect #设置时区
systemd-timeryncd.service服务的配置文件位于“/etc/systemd”路径下，文件名称为“timesyncd.conf”，可以设置ntp服务器(deepin有
/etc/systemd/timesyncd.conf.d/deepin.conf如果某个Linux发行版和deepin一样具有/etc/systemd/system.d/timesyncd.conf文件夹，那么systemd-timesyncd.service服务将优先选择这个文件夹下的.conf文件作为自己的优先配置文件，而原有的/etc/systemd/timesyncd.conf将作为备用的配置文件，优先级相对较低。
4.3、典型故障——无论怎样修改时区，Linux系统始终都显示零区的格林尼治时间
出现这样的情况一般是因为/usr/share/zoneinfo目录遭到严重破坏造成的，针对这样的故障，最简单粗暴的方式就是将找到一套同版本、正常运行的Linux发行版，将其/usr/share/zoneinfo目录复制出来，对故障Linux系统的相关目录进行替换。</p>
<p>4.4、典型故障——安全软件在启动时强制打开操作系统时间同步功能，后因安全软件服务端时间错误导致时钟错误同步
在信创领域，Linux杀毒软件经常被安装在Linux电脑上，用于病毒查杀和违规外联等功能。而主流的Linux杀毒软件都具有审计功能，审计会产生大量的日志纪录，这些纪录需要有一个时间对应，因此这些杀毒软件的服务端会自带时钟同步，并且会在Linux终端启动完成后强制打开和配置操作系统的时钟同步功能，如果杀毒软件服务端的本地时间时错误的，或者说同一个局域网内有多个存在一定时间差的NTP服务器，将可能会对Linux终端带来时间上的错误。</p>
<p>sudo trace-bpfcc -tUK __alloc_pages_nodemask</p>
<p>systemctl set-property name parameter=value</p>
<p>pactl list short modules pacmd list-modules</p>
<p>设置systemdlog_level: /etc/systemd/daemon.log</p>
<p>查看进程的fd: ls -l /proc/xxx/fd</p>
<p>1、通过以下步骤进行测试： (1)执行 mv /usr/bin/pulseaudio
/usr/bin/pulseaudiobak, 重启让pulseaudio无法自启动 (2)命令行 执行
arecord -Dhw:0,1 -d 10 -f cd -t wav
test.wav通过alsa进行录音（hw:0,1为指定录音的设备，arecord命令的使用可以参考网上资料）
(3) 将生成的test.wav用audacity软件进行播放，查看是否有杂音。
此时依旧有杂音，基本可以确定是送上来的数据流有问题（中间音频驱动和alsa编解码的过程因为编解码过程都比较完善，一般不会出现问题）
2、此问题从现象上看就是将录制的音量提高到50%的时候，通过alsamixer查看此时Internal
Mic
boost开始有增强效果，导致噪音被放大。此问题在软件方面只能通过修改配置文件将Internal
Mic
boost设置为ignore来取消增强效果来减缓此问题，要根本解决还需要厂商进行适配。
https://blog.csdn.net/xiongtiancheng/article/details/80577478</p>
<h2 id="tensorboard">tensorboard</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir logs</span><br></pre></td></tr></table></figure>
<h2 id="查看谁执行了某条命令">查看谁执行了某条命令:</h2>
<p>重现bug，然后检查日志，sudo journalctl -b0 |grep SYSCALL 能看到有
date 命令调用 syscall 112 号 设置了系统时间。</p>
<p>sudo mv /usr/bin/date /usr/bin/date.real</p>
<p>编写文件 /usr/bin/date</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">echo &gt;&gt; /tmp/log</span><br><span class="line">pstree -p -A -l &gt;&gt; /tmp/log</span><br><span class="line">echo pid: $$ &gt;&gt; /tmp/log</span><br><span class="line">echo args: $@ &gt;&gt; /tmp/log</span><br><span class="line">logger -f /tmp/log</span><br><span class="line">/usr/bin/date.real "$@"</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行命令 sudo chmod +x /usr/bin/date</p>
<p>然后按照步骤重现bug，然后立即查看 /tmp/log 文件的内容。</p>
<p>比如看到文件底部有 pid: 12345, 然后去本文件上方找到
12345，看它的父进程是什么，我看到了一个父进程 AlarmThread，pid 为
3203。</p>
<p>然后切换到 root 用户，执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd /proc/3202</span><br><span class="line"></span><br><span class="line">cat comm</span><br><span class="line"></span><br><span class="line">readlink -f exe</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到结果是 AlarmThread 和
/opt/apps/cn.com.topsec.topdesk/files/bin/TDATX0，这就说明了是
cn.com.topsec.topdesk 软件包里的程序调用了 date 命令设置了时间。</p>
<h2 id="quilt配置">quilt配置：</h2>
<p>for where in ./ ../ ../../ ../../../ ../../../../ ../../../../../; do
if [ -e <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="26.728ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11813.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g><g data-mml-node="mi" transform="translate(716,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(1292,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1758,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2209,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g></g><g data-mml-node="mi" transform="translate(2675,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(3195,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(3661,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(4090,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(4435,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(4964,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5564,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(6064,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(6515,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(7087,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(7385,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(7851,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(8542.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(9542.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(10293.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(11293.9,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g></g></g></svg></mjx-container>{where}debian/patches ]; then export
QUILT_PATCHES=debian/patches break fi done</p>
<h2 id="wpa_cli">wpa_cli:</h2>
<p>wpa_cli -i wlan0 scan scan_results nmcli con show nmcli dev wifi
connect ASXXX 查看连接情况wpa_cli -i wlan0 scan_results | grep ASXXX</p>
<h2 id="查看电脑支不支持wpa">查看电脑支不支持wpa：</h2>
<p>gdb wpa 在这个函数里， wpa_supplicant_set_suites</p>
<p>然后p一下这个值。</p>
<p>wpa_s-&gt;drv_flags</p>
<p>gdb 他的电脑。</p>
<h2 id="删除已连接的网络">删除已连接的网络：</h2>
<p>rm /etc/NetworkManager/systemd-connections/*** systemctl restart
network-manager.service</p>
<h2 id="跟踪signal_fd">跟踪signal_fd:</h2>
<p>sudo trace-bpfcc -tK 'do_send_sig_info(int sig, struct siginfo
<em>info, struct task_struct </em>p) "sig=%d,recv_pid=%d,send_pid=%d",
sig,p-&gt;pid,info-&gt;si_pid'</p>
<p>trace-bpfcc指定头文件：加-I</p>
<p>trace-bpfcc: sudo trace-bpfcc -t 'do_filp_open(int dfd, struct
filename *pathname) "name=%s", pathname-&gt;name' | grep "/dev/rtc"</p>
<p>sudo trace-bpfcc -tK 'btrfs_mount_root(void* f, int flags, char*
name) "flags=0x%lx name=%s", flags, name'</p>
<p>sudo trace-bpfcc -t 'group_send_sig_info(int sig, void <em>info,
struct task_struct </em>p)"sig=%d, task_pid=%d, task_name=%s",sig,
p-&gt;pid, p-&gt;comm' &gt;&gt; 1.log</p>
<p>sudo dbus-monitor --system interface=org.freedesktop.login1.Manager
path=/org/freedesktop/login1</p>
<p>316 trace-bpfcc -t 'generic_file_direct_write(struct kiocb *iocb)
"func=0x%lx", iocb-&gt;ki_filp-&gt;f_mapping-&gt;a_ops-&gt;direct_IO' -p
28942</p>
<p>sudo trace-bpfcc -t 'group_send_sig_info(int sig, void <em>info,
struct task_struct </em>p)"sig=%d, task_pid=%d, task_name=%s",sig,
p-&gt;pid, p-&gt;comm' &gt;&gt; 1.log</p>
<h2 id="查找被隐藏的进程">查找被隐藏的进程</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysdig -c topprocs_cpu # 该命令可以输出cpu占用的排行，经测试可以显示出被隐藏的进程</span><br><span class="line">unhide proc # 自助搜索隐藏进程，linux系统中一切皆文件，proc目录下保存的就是所有正在运行程序的进程ID，即PID</span><br></pre></td></tr></table></figure>
<p>以上两个命令需要额外安装，不是系统自带命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sysdig可用如下命令安装，curl是类似wget的下载命令，这里下载的是一个bash脚本，下载后再通过bash执行安装</span></span><br><span class="line">curl -s https://s3.amazonaws.com/download.draios.com/stable/install-sysdig | bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unhide 可以通过如下命令进行安装</span></span><br><span class="line">yum install unhide # 中毒的是Centos7系统，所以用的是yum</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挖矿病毒都会有定时的网络发送信息，所以可用如下命令查看在病毒运行期间，是否存在异常IP地址</span></span><br><span class="line">netstat -natp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">知道这些后，我们可以用防火墙firewalld或iptables对这些IP进行封禁</span></span><br><span class="line">iptables -I INPUT -s IP -j DROP</span><br><span class="line">firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="IP" reject'</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中IP字段替换为真实的黑客IP</span></span><br></pre></td></tr></table></figure>
<h2 id="配置ssh免密登录">配置ssh免密登录</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<p>自动把公钥复制到虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id ubuntu@192.168.105.10)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ssh设置别名">ssh设置别名</h2>
<p>vim编辑~/.ssh/config文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host jhd</span><br><span class="line">HostName 1xx.1xx.1xx.67</span><br><span class="line">User root</span><br><span class="line">IdentitiesOnly yes</span><br></pre></td></tr></table></figure>
<h2 id="禁用root-ssh登录">禁用root ssh登录</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一方面是ssh远程登录没有禁用root的远程登录，此时需要在/etc/ssh/sshd_config中添加</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存后，对ssh服务进行重启</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<p>有条件的可以将服务器中ssh登录都设置为rsa免密登录，这样可以避免绝大多数问题</p>
<p>一般是通过尝试用户名和密码对服务器进行攻击，但是每台服务器中用户名都不同，所以很难攻击，但是root名称一般不会变，所以一般是先攻击这个名称。</p>
<h2 id="pnpm和npm以及yarn">pnpm和npm以及yarn</h2>
<h3 id="pnpm和npm的区别是什么">pnpm和npm的区别是什么?</h3>
<p>pnpm 和 npm 有以下一些区别：</p>
<ul>
<li><strong>安装方式和存储结构</strong>：npm 会将依赖包安装到项目中的
node_modules
文件夹中，它为每个依赖包创建一个软链接指向该文件夹，可能存在大量软链接导致存储占用较大；而
pnpm 将依赖包安装到.pnpm
文件夹中，使用硬链接将依赖包链接到项目中，这样可以减少存储占用和安装时间。</li>
<li><strong>安装速度</strong>：npm
每个项目都需要安装和下载依赖包，速度相对较慢；pnpm
使用硬链接，相同的依赖包可以被多个项目共享，能够更快地安装依赖包，在大多数场景下其安装速度比
npm 快 2-3 倍。</li>
<li><strong>依赖管理</strong>：npm
采用嵌套或扁平化的依赖管理方式，可能存在幽灵依赖（未在 package.json
中定义但项目中可引用的依赖）和依赖分身（同一依赖的不同版本被重复安装）等问题；pnpm
引入了内容寻址存储策略，只有直接依赖会平铺在 node_modules
下，子依赖不会被提升，解决了幽灵依赖问题，且相同的依赖只会在全局 store
中安装一次，避免了依赖分身，其创建的 node_modules 是非扁平化结构。</li>
<li><strong>兼容性</strong>：npm 是默认的 JavaScript
包管理器，广泛使用于大多数项目；pnpm 是新兴的包管理工具，可以与 npm
兼容，并与多个 npm 生态系统工具协同工作，但可能存在与一些 npm
插件和工具的不兼容问题。</li>
<li><strong>磁盘空间利用</strong>：使用 npm/yarn
时，如果多个项目都依赖同一个包，该包可能会被多次安装，磁盘中存在多个相同代码的副本；而
pnpm
内部使用基于内容寻址的文件系统，不会重复安装同一个包，对于同一个包的不同版本，也会极大程度地复用之前版本的代码，能更高效地利用磁盘空间。</li>
</ul>
<h3 id="pnpm"><strong>pnpm</strong></h3>
<p><code>pnpm</code> 是一个快速、节省磁盘空间的包管理工具。</p>
<p>它具有以下一些特点和优势：</p>
<ul>
<li>高效的磁盘空间利用：通过硬链接和内容寻址存储，避免了多个项目中重复安装相同依赖的冗余存储。</li>
<li>快速的安装速度：得益于其优化的依赖处理机制。</li>
</ul>
<p>例如，当您有多个使用相同依赖版本的项目时，<code>pnpm</code>
可以共享这些依赖，而不是每个项目都单独安装一份。</p>
<h4 id="安装pnpm">安装pnpm</h4>
<p><code>npm install -g pnpm</code></p>
<h4 id="pnpm安装依赖">pnpm安装依赖</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install</span><br></pre></td></tr></table></figure>
<p>执行 <code>pnpm install</code>时，它会读取项目根目录下的
<code>package.json</code>文件来配置依赖包列表。</p>
<p><code>package.json</code>是一个 JSON
格式的文件，用于描述项目的相关信息，包括项目名称、版本、描述以及项目所依赖的其他包及其版本等。</p>
<p><code>pnpm</code>使用一个称为
<code>pnpm-lock.yaml</code>的文件来记录项目的依赖关系和版本，类似于
<code>npm</code>的
<code>package-lock.json</code>文件，它可以确保项目在不同环境中得到相同的依赖版本。</p>
<p>当执行 <code>pnpm install</code>命令时，如果存在
<code>pnpm-lock.yaml</code>文件，并且其中记录的依赖版本与
<code>package.json</code>中指定的兼容，<code>pnpm</code>将根据
<code>pnpm-lock.yaml</code>安装确切的依赖版本。如果
<code>pnpm-lock.yaml</code>不存在或与
<code>package.json</code>不兼容，<code>pnpm</code>将重新生成
<code>pnpm-lock.yaml</code>文件，并根据
<code>package.json</code>中的依赖信息安装相应的包。</p>
<p>在 macOS 系统中，执行 <code>pnpm install</code>
后，依赖包的默认安装位置是用户主目录下的 <code>.pnpm</code> 文件夹。</p>
<p>不过，你可以通过配置来修改依赖包的安装路径。例如，使用以下命令可以设置全局安装包的
bin 文件的目标目录、包元数据缓存的位置等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pnpm config set global-bin-dir "你期望的全局 bin 文件目录"</span><br><span class="line">pnpm config set cache-dir "你期望的缓存目录"</span><br><span class="line">pnpm config set state-dir "你期望的 pnpm-state.json 文件目录"</span><br><span class="line">pnpm config set global-dir "你期望的全局依赖目录"</span><br></pre></td></tr></table></figure>
<p>需注意，修改安装路径后，需要重新打开终端以使更改生效。</p>
<p>另外，<code>pnpm</code> 还会创建一个 <code>pnpm-lock.yaml</code>
文件来记录项目的依赖关系和版本。这个文件类似于 <code>npm</code> 的
<code>package-lock.json</code>，用于确保在不同环境中能够安装相同版本的依赖包。</p>
<p>如果你在安装过程中遇到问题或需要更详细的信息，可以参考<a target="_blank" rel="noopener" href="https://pnpm.io/">pnpm 的官方文档</a>。</p>
<p>或者，你也可以参考如下步骤进行配置（假设你想将相关文件安装到“/users/xxx/my_pnpm”目录下）：</p>
<ol type="1">
<li>终端运行 <code>pnpmsetup</code> 命令；</li>
<li>找到用户的主目录下的 <code>.zshrc</code>
文件（注意：该文件默认隐藏，可以用 <code>cmd+shift+.</code>
查看），初始内容可能类似于：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export pnpm_home="/users/xxx/library/pnpm"</span><br><span class="line">case ":$path:" in</span><br><span class="line">  *):$pnpm_home:"*</span><br><span class="line">  );;</span><br><span class="line">*)</span><br><span class="line">  export path="$pnpm_home/bin:$path"</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>在原来的基础上文件底部加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export path="/users/xxx/my_pnpm/bin:$path"</span><br></pre></td></tr></table></figure>
<p>（请将“xxx”替换为自己的用户主目录）</p>
<ol start="3" type="1">
<li>终端运行 <code>source ~/.zshrc</code> 命令，就可以使用
<code>pnpm</code> 安装的全局依赖啦。</li>
</ol>
<h4 id="pnpm-tauri-dev"><code>pnpm tauri dev</code></h4>
<p>“pnpm tauri dev”的作用是启动 Tauri 应用的开发模式。</p>
<p>Tauri 是一个基于 Rust
实现的跨端桌面应用开发工具，应用的界面可以使用前端技术进行开发，如原生的
HTML、CSS、JS，或者使用 React、Vue 等前端框架。</p>
<p>执行“pnpm tauri dev”命令后，它<strong>首先会执行“pnpm
dev”</strong>，启动一个 Vite
脚手架来运行前端页面。<strong>经过一段时间的编译（大概 3
分钟左右）</strong>，Rust 后端程序也会启动，随后会<strong>自动弹出 Tauri
应用</strong>。</p>
<p>在实际使用中，为了更方便开发，可以在“package.json”的“scripts”里加入一行
<code>"tauri:dev":"tauri dev"</code>，之后就可以使用
<code>pnpm run tauri:dev</code>来启动开发窗口。</p>
<p>该命令中的<strong>“tauri dev”具体做的事情可能包括启动 Tauri
应用的后端服务、监测项目中的文件变化并自动重新编译和加载等</strong>，以便开发者能够实时看到代码修改后的效果，方便进行前端界面和
Rust 后端逻辑的开发调试工作。</p>
<p><code>b</code></p>
<p>如果需要打包后进行调试，请在以下命令后面加上 <code>--debug</code></p>
<p>“pnpm tauri build”命令用于构建 Tauri 应用。它会将你的前端资源（如
HTML、CSS、JavaScript 等）与 Rust
代码一起嵌入到一个单独的二进制文件中。</p>
<p>第一次运行该命令时，需要一些时间来收集 Rust
包并构建所有内容，但在随后的运行中，它只需重新构建应用程序代码，速度会快很多。</p>
<p>二进制文件本身将位于
<code>src-tauri/target/release/(应用程序名称)</code>，而安装程序将位于
<code>src-tauri/target/release/bundle/</code>。</p>
<p>然而，在新创建的项目中第一次打包时，可能会报“<code>error: you must change the bundle identifier in tauri.conf.json &gt; tauri &gt; bundle &gt; identifier. the default value com.tauri.dev is not allowed as it must be unique across applications.</code>”错误。这是因为第一次打包需要修改
<code>src-tauri/tauri.conf.json</code>
文件里的配置项“<code>identifier</code>”，将其值由“<code>com.tauri.dev</code>”改成“<code>com.tauri.build</code>”，然后再运行打包命令。</p>
<p>如果你需要为特定的操作系统或架构进行构建，例如 32 位或
arm64，可以添加相应的 <code>--target</code> 标志。例如，要编译 32 位
Windows 应用，可以使用
<code>tauri build --target i686-pc-windows-msvc</code>；要编译 arm64
应用，需要先安装额外的构建工具（如在 Visual Studio Installer 中安装“C++
arm64 构建工具”），然后使用
<code>rustup target add aarch64-pc-windows-msvc</code> 添加目标，并执行
<code>tauri build --target aarch64-pc-windows-msvc --bundle nsis</code>（注意，只有
nsis 目标支持 arm64 目标，且安装程序本身仍是 x86 的，将在 arm
机器上通过模拟运行，而应用本身是原生的 arm64 二进制）。</p>
<p>对于其他操作系统的详细构建信息和注意事项，可以参考 Tauri
的官方文档（<a target="_blank" rel="noopener" href="https://tauri.app/">https://tauri.app/</a>
）以获取更准确和最新的指导。</p>
<h4 id="pnpm命令">pnpm命令:</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm store path #查看 pnpm 整体的缓存路径</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1722067669618.png" alt="1722067669618">
<figcaption aria-hidden="true">1722067669618</figcaption>
</figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm store prune #清理 pnpm 的缓存</span><br></pre></td></tr></table></figure>
<h2 id="tauri">tauri</h2>
<p><code>tauri init</code> 命令(或者说npm run tauri init)将生成
<code>src-tauri</code> 文件夹。 传统上，Tauri
应用会将其核心相关的文件放置于此文件夹中。
让我们快速过一下此文件夹中的内容：</p>
<ul>
<li><p><strong><code>Cargo.toml</code></strong> Cargo 的清单文件。
您可以声明您应用所依赖的 Rust 包和应用的元数据等等。
要查看所有可修改的值，请参阅 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/manifest.html">Cargo
清单格式</a>。</p></li>
<li><p><strong><code>tauri.conf.json</code></strong> 此文件可让您自定义
Tauri 应用的各方各面，包括应用名称到允许的 API 列表。 请参阅 <a target="_blank" rel="noopener" href="https://tauri.app/zh-cn/v1/api/config">Tauri 的 API
配置</a>来深入了解每个支持的选项。</p></li>
<li><p><strong><code>src/main.rs</code></strong> 这是你的 Rust
程序的入口，也是我们启动 Tauri 的地方。 您可以发现它由两个部分组成：
src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![cfg_attr(not(debug_assertions), windows_subsystem = <span class="string">"windows"</span>)]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">fnmain</span>(){</span><br><span class="line">tauri::Builder::<span class="title function_ invoke__">default</span>()</span><br><span class="line">.<span class="title function_ invoke__">run</span>(tauri::generate_context!())</span><br><span class="line">.<span class="title function_ invoke__">expect</span>(<span class="string">"error while running tauri application"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>The line beginning with the <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html"><code>cfg! 宏</code></a>所开始的一行仅有一个目的：关闭构建好的应用在
Windows 上运行时一般会出现的控制台窗口。 若您是 Windows
用户，您可以试试去掉这行看看会发生什么。 <code>main</code>
函数是您程序的入口点，也是运行时调用的第一个函数。</p></li>
<li><p><strong><code>icons</code></strong>
您可能想为自己的应用整一个漂亮的图标！
为了帮助您快速开发，我们为您提供了一套默认图标。
您应该在发布前把这些图标换成您自己的图标。 您可以在 Tauri 的<a target="_blank" rel="noopener" href="https://tauri.app/zh-cn/v1/guides/features/icons">图标功能指南</a>中了解有关多种图标格式的信息。</p></li>
</ul>
<p>就是这样！
现在您可以在您的终端中运行接下来的命令来开始您的应用程序的开发构建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run tauri dev</span><br></pre></td></tr></table></figure>
<p>应用预览 <img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-1.png" alt="alt text"></p>
<h3 id="npm"><strong>npm</strong></h3>
<p><code>npm</code> 即 <code>Node Package Manager</code> ，是 Node.js
的默认包管理工具。</p>
<p>它允许开发者轻松地安装、共享、分发和管理代码模块（包）。</p>
<p><code>npm</code> 拥有庞大的包仓库，涵盖了各种各样的功能和库。</p>
<p>例如，您可以使用 <code>npm install express</code> 命令来安装
<code>Express</code> 这个用于创建 Web 应用的框架。</p>
<p>许多前端和后端的项目都依赖 <code>npm</code>
来管理项目所需的各种依赖包，以提高开发效率和代码的可维护性。</p>
<h4 id="如何解决npm-err-request-to-httpsregistry.npm.taobao.orgpnpm-failed-reason-certificate-has-expired">如何解决npm
ERR! request to https://registry.npm.taobao.org/pnpm failed, reason:
certificate has expired</h4>
<p>原因:需注意原淘宝 npm 镜像站的域名（<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>）已不再使用，于
2022 年 05 月 31 日零时起停止服务</p>
<p>解决方法:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<h4 id="npm-cache-clean---force清理的是哪里的缓存">npm cache clean
--force清理的是哪里的缓存?</h4>
<p><code>npm cache clean --force</code> 清理的是 npm 本地缓存。</p>
<p>在大多数系统中，npm 缓存默认存储在以下路径：</p>
<ul>
<li>Windows：%appdata%-cache</li>
<li>macOS 和 Linux：~/.npm</li>
</ul>
<p>使用该命令会强制删除所有已有的缓存文件，包括已下载的依赖包和相关数据等。</p>
<p>需要注意的是，执行此操作后，npm
将需要重新下载所有依赖，这可能会增加安装时间。因此，在执行该命令之前，需确保了解其后果，并且确实需要清理缓存。例如，当怀疑缓存中的包损坏或过时，导致安装问题；或者需要确保安装的是包的最新版本；又或者缓存占用了大量磁盘空间时，可以考虑使用该命令。</p>
<p>另外，如果只是想查看 npm 缓存的位置，可以使用命令
<code>npm cache dir</code>或者 <code>npm config list --json</code>。对于
yarn，可以使用命令 <code>yarn cache dir</code>查看缓存位置。</p>
<h4 id="npm-fund">npm fund</h4>
<p><code>npm fund</code>是 npm
包管理工具中的一个命令。它的作用是列出项目中正在寻找资金的依赖包及其对应的捐赠平台和链接。</p>
<p>当运行 <code>npm install</code>安装依赖包后，使用
<code>npm fund</code>命令可以查看相关信息。在
<code>package.json</code>文件中，维护者可以添加一个“funding”字段，用于指定捐赠平台的元数据和链接，如
<code>patreon</code>、<code>opencollective</code>、<code>github sponsors</code>、<code>licensezero</code>或其他支付网站的
<code>url</code>。</p>
<p>运行
<code>npm fund</code>后，它会在用户的默认浏览器中打开指定的捐赠服务链接，以便进行信用卡捐赠等操作。</p>
<p>例如，运行 <code>npm fund</code>可能会得到类似以下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package-name@version</span><br><span class="line">+--dependency1@version1</span><br><span class="line">| +--type:opencollective</span><br><span class="line">| `--url:https://opencollective.com/dependency1</span><br><span class="line">+--dependency2@version2</span><br><span class="line">| +--type:github sponsors</span><br><span class="line">| `--url:https://github.com/sponsors/dependency2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这表示 <code>package-name</code>这个包及其依赖项
<code>dependency1</code>和
<code>dependency2</code>正在寻找资金支持，<code>dependency1</code>的捐赠平台是
<code>opencollective</code>，链接为
<code>https://opencollective.com/dependency1</code>；<code>dependency2</code>的捐赠平台是
<code>github sponsors</code>，链接为
<code>https://github.com/sponsors/dependency2</code>。</p>
<p>通过
<code>npm fund</code>命令，用户可以了解到所使用的开源包是否接受捐赠以及如何进行捐赠，以支持开源项目的发展。</p>
<p>需要注意的是，并非所有的包都会在
<code>package.json</code>中设置“funding”字段，只有那些明确声明了的包才会在
<code>npm fund</code>命令的输出中显示相关的捐赠信息。同时，捐赠是完全自愿的行为，用户可以根据自己的意愿和能力决定是否进行捐赠。</p>
<h4 id="npm-list">npm list</h4>
<p>检查某个模块是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list hexo-filter-mathjax</span><br></pre></td></tr></table></figure>
<h4 id="npm项目-package.json">npm项目 package.json</h4>
<h5 id="scripts字段">scripts字段</h5>
<p><code>scripts</code>
字段是一个对象，用于定义各种可执行的脚本命令。</p>
<p>这些脚本命令可以通过在终端中运行
<code>npm run &lt;script_name&gt;</code> 来执行。</p>
<p>例如，如果 <code>scripts</code> 字段中有以下定义：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"scripts"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"start"</span><span class="punctuation">:</span> <span class="string">"node server.js"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"build"</span><span class="punctuation">:</span> <span class="string">"webpack --config webpack.config.js"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>那么，您可以在终端中使用 <code>npm run start</code> 来启动
<code>node server.js</code> ，使用 <code>npm run build</code> 来执行
<code>webpack --config webpack.config.js</code> 。</p>
<p><code>scripts</code> 字段的主要用途包括：</p>
<ol type="1">
<li>定义项目的开发流程：比如启动开发服务器、进行代码编译、运行测试等。</li>
<li>简化复杂的命令：将一系列复杂的命令组合成一个简单易记的脚本名称。</li>
<li>保持命令的一致性：无论在哪个开发环境中，只要项目的
<code>package.json</code> 相同，运行
<code>npm run &lt;script_name&gt;</code> 的效果就是一致的。</li>
<li>方便团队协作：团队成员可以通过相同的脚本命令进行项目的开发、构建和部署等操作。</li>
</ol>
<p>总之，<code>scripts</code>
字段为项目提供了一种方便、可复用和标准化的方式来执行各种命令，提高了开发效率和项目的可维护性。</p>
<h3 id="yarn">yarn</h3>
<p><code>Yarn</code> 是一个 JavaScript 包管理工具。</p>
<p>它的主要目的是为了提供更可靠、高效和安全的依赖管理体验。</p>
<p><code>Yarn</code> 具有以下一些特点和优势：</p>
<p><strong>1. 确定性</strong>：通过创建 <code>yarn.lock</code>
文件来锁定每个依赖项的版本，确保在不同的环境中安装的依赖版本一致，从而提高项目的可重复性。</p>
<p><strong>2.
并行安装</strong>：能够同时下载多个依赖包，大大提高了安装速度。</p>
<p><strong>3.
离线模式</strong>：一旦依赖被下载过，再次安装时，如果缓存中存在，就可以离线安装，无需重新从网络获取。</p>
<p><strong>4.
安全检查</strong>：在安装依赖时，会对依赖包的完整性进行检查，确保其没有被篡改。</p>
<p>例如，当您在一个大型的前端项目中，使用 <code>Yarn</code>
可以快速、稳定地安装各种前端库和框架，如
<code>React</code>、<code>Vue</code> 等。同时，团队协作时，通过
<code>yarn.lock</code>
文件可以保证每个成员的开发环境中依赖版本的一致性。</p>
<h2 id="webview">webview</h2>
<h3 id="webview是什么">webview是什么?</h3>
<p>WebView 是一个能在移动应用或桌面应用中嵌入网页内容的组件。</p>
<p>它允许开发者在原生应用的界面中直接显示网页，实现了原生应用和网页内容的融合。</p>
<p>WebView 的主要作用包括：</p>
<ol type="1">
<li>混合开发：通过在原生应用中嵌入
WebView，开发者可以将部分界面或功能以网页的形式实现，这样既能利用原生应用的性能和功能，又能借助网页开发的便捷性和快速迭代能力。</li>
<li>展示动态内容：比如新闻应用可以使用 WebView
来显示从服务器获取的实时新闻页面。</li>
<li>跨平台：在不同的平台（如 Android、iOS 等）上，WebView
提供了一种相对统一的方式来展示网页内容，有助于减少跨平台开发的差异。</li>
<li>节省开发成本：对于一些相对简单且经常变化的功能，使用 WebView
加载网页可以避免为每个平台单独开发原生代码。</li>
</ol>
<p>例如，一些电商应用可能会在商品详情页面使用 WebView
来展示从服务器动态获取的商品介绍和评论，而应用的框架和核心功能则由原生代码实现。</p>
<p>不同的平台对 WebView
的实现和特性可能会有所不同，但总体功能和用途是相似的。在开发过程中，需要注意
WebView 的性能优化、缓存管理、与原生代码的交互等方面的问题。</p>
<h2 id="rust">Rust</h2>
<h3 id="cargo">cargo</h3>
<p><code>Cargo</code> 是 Rust 编程语言的包管理和构建工具。</p>
<p>它主要用于以下几个方面：</p>
<ol type="1">
<li>依赖管理：可以方便地声明项目所依赖的其他 Rust
库，并自动下载和管理它们的版本。</li>
<li>项目构建：处理项目的编译、链接等构建过程，支持多种编译选项和配置。</li>
<li>测试运行：能够轻松运行项目中的测试用例。</li>
<li>发布管理：帮助开发者将项目发布到 Rust 的包仓库（crates.io）。</li>
</ol>
<p>使用 <code>Cargo</code> 可以极大地提高 Rust
项目开发的效率和便利性。</p>
<p>例如，当您创建一个新的 Rust 项目时，只需要运行
<code>cargo new project_name</code> 命令，<code>Cargo</code>
就会自动为您创建项目的基本结构，包括 <code>Cargo.toml</code>
配置文件（用于管理依赖和项目设置）和 <code>src</code>
目录（存放源代码）。</p>
<p>如果您想在项目中添加一个依赖库，只需要在 <code>Cargo.toml</code>
文件中添加相应的依赖信息，然后运行 <code>cargo build</code>
，<code>Cargo</code> 就会自动下载并集成该依赖库。</p>
<p>总之，<code>Cargo</code> 是 Rust 生态系统中不可或缺的一部分，为 Rust
开发者提供了强大而便捷的工具支持。</p>
<h4 id="cargo-功能">Cargo 功能</h4>
<p>Cargo
除了创建工程以外还具备构建（build）工程、运行（run）工程等一系列功能，构建和运行分别对应以下命令：</p>
<ul>
<li><code>cargo new &lt;project-name&gt;</code>：创建一个新的 Rust
项目。</li>
<li><code>cargo build</code>：编译当前项目。</li>
<li><code>cargo run</code>：编译并运行当前项目。</li>
<li><code>cargo check</code>：检查当前项目的语法和类型错误。</li>
<li><code>cargo test</code>：运行当前项目的单元测试。</li>
<li><code>cargo update</code>：更新 Cargo.toml
中指定的依赖项到最新版本。</li>
<li><code>cargo --help</code>：查看 Cargo 的帮助信息。</li>
<li><code>cargo publish</code>：将 Rust 项目发布到 crates.io。</li>
<li><code>cargo clean</code>：清理构建过程中生成的临时文件和目录。</li>
<li>cargo clippy: 类似eslint，lint工具检查代码可以优化的地方</li>
<li>cargo fmt: 类似go fmt，代码格式化</li>
<li>cargo tree: 查看第三方库的版本和依赖关系</li>
<li>cargo bench: 运行benchmark(基准测试,性能测试)</li>
<li>cargo udeps(第三方): 检查项目中未使用的依赖</li>
</ul>
<p>另外 <strong>cargo build/run --release</strong> 使用 release
编译会比默认的 debug 编译性能提升 10 倍以上，但是 release
缺点是编译速度较慢，而且不会显示 panic backtrace 的具体行号</p>
<h4 id="创建一个最简单的rust项目">创建一个最简单的rust项目</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo new greeting </span><br><span class="line">cd ./greeting </span><br><span class="line">cargo build </span><br><span class="line">cargo run </span><br></pre></td></tr></table></figure>
<h4 id="编译rust代码">编译rust代码</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc runoob.rs   # 编译 runoob.rs 文件</span><br></pre></td></tr></table></figure>
<p>编译后会生成 <strong>runoob</strong> 可执行文件</p>
<p>Rust 输出文字的方式主要有两种：<strong>println!()</strong> 和
<strong>print!()</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"a is {}, a again is {}"</span>, a, a);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"a is {0}, a again is {0}"</span>, a); <span class="comment">//在 {} 之间可以放一个数字，它将把之后的可变参数当作一个数组来访问，下标从 0 开始。</span></span><br><span class="line"><span class="comment">//如果要输出 { 或 } 怎么办呢？格式字符串中通过 {{ 和 }} 分别转义代表 { 和 }。但是其他常用转义字符与 C 语言里的转义字符一样，都是反斜杠开头的形式。</span></span><br></pre></td></tr></table></figure>
<h4 id="在-vscode-中配置-rust-工程">在 VSCode 中配置 Rust 工程</h4>
<p>Cargo 是一个不错的构建工具，如果使 VSCode 与它相配合那么 VSCode
将会是一个十分便捷的开发环境。</p>
<p>在上一章中我们建立了 greeting 工程，现在我们用 VSCode 打开 greeting
文件夹（ <strong>注意不是 runoob-greeting</strong> ）。</p>
<p>打开 greeting 之后，在里面新建一个新的文件夹 <strong>.vscode</strong>
（注意 vscode 前面的点，如果有这个文件夹就不需要新建了）。在新建的
.vscode 文件夹里新建两个文件 tasks.json 和
launch.json，文件内容如下：</p>
<p>tasks.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span> </span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"2.0.0"</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">"tasks"</span><span class="punctuation">:</span> <span class="punctuation">[</span> </span><br><span class="line">        <span class="punctuation">{</span> </span><br><span class="line">            <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"build"</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"shell"</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">"command"</span><span class="punctuation">:</span><span class="string">"cargo"</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"build"</span><span class="punctuation">]</span> </span><br><span class="line">        <span class="punctuation">}</span> </span><br><span class="line">    <span class="punctuation">]</span> </span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>launch.json(mac os)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"(lldb) 启动"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"build"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"${workspaceFolder}/target/debug/${workspaceFolderBasename}"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"lldb"</span></span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>launch.json(linux)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0.2.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"configurations"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Debug"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"gdb"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"preLaunchTask"</span><span class="punctuation">:</span> <span class="string">"build"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"request"</span><span class="punctuation">:</span> <span class="string">"launch"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"target"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}/target/debug/${workspaceFolderBasename}"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"cwd"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>然后点击 VSCode 左栏的 "运行"。</p>
<p>如果你使用的是 MSVC 选择 "(Windows) 启动"。</p>
<p>如果使用的是 MinGW 且安装了 GDB 选择"(gdb)启动"，gdb 启动前请注意填写
launch.json 中的 "miDebuggerPath"。 <img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-8.png" alt="alt text"></p>
<p>程序就会开始调试运行了。运行输出将出现在"调试控制台"中： <img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-9.png" alt="alt text"></p>
<h4 id="rust声明变量">rust声明变量:</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p>Rust 语言不允许精度有损失的自动数据类型转换</p>
<p>在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着
a 不是"变量"（英文中的 variable），官方文档称 a
这种变量为"不可变变量"。</p>
<p>如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是
Rust 语言设计这种机制的原因。</p>
<p>当然，使变量变得"可变"（mutable）只需一个 <strong>mut</strong>
关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mut a =123;</span><br><span class="line">a =456;</span><br></pre></td></tr></table></figure>
<p><strong>变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123</span>;   <span class="comment">// 可以编译，但可能有警告，因为该变量没有被使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">456</span>;</span><br></pre></td></tr></table></figure>
<h4 id="rust函数">Rust函数:</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x 的值为 : {}"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"y 的值为 : {}"</span>, y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Rust 中可以在一个用 <strong>{}</strong>
包括的块里编写一个较为复杂的表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x 的值为 : {}"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"y 的值为 : {}"</span>, y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>注意：<strong>x + 1</strong> 之后没有分号，否则它将变成一条语句！</p>
<p>这种表达式块是一个合法的函数体。而且在 Rust
中，函数定义可以嵌套：</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"five() 的值为: {}"</span>, <span class="title function_ invoke__">five</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Rust 函数声明返回值类型的方式：在参数声明之后用
<strong>-&gt;</strong> 来声明函数返回值的类型（不是 <strong>:</strong>
）。</p>
<p>在函数体中，随时都可以以 return
关键字结束函数运行并返回一个类型合适的值。这也是最接近大多数开发者经验的做法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>但是 Rust
不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是"纯过程"，不允许产生返回值，return
后面不能有返回值表达式。这样做的目的是为了让公开的函数能够形成可见的公报。</p>
<p><strong>注意：</strong> 函数体表达式并不能等同于函数体，它不能使用
<strong>return</strong>** 关键字。**</p>
<h4 id="rust-条件语句">Rust 条件语句:</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() { </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>; </span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0</span> { </span><br><span class="line">        b = <span class="number">1</span>; </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> a &lt; <span class="number">0</span> { </span><br><span class="line">        b = -<span class="number">1</span>; </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">else</span> { </span><br><span class="line">        b = <span class="number">0</span>; </span><br><span class="line">    } </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b is {}"</span>, b); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>if <code>&lt;condition&gt;</code> { block 1 } else { block 2 }</p>
<p>示例:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() { </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> a &gt; <span class="number">0</span> { <span class="number">1</span> } <span class="keyword">else</span> { -<span class="number">1</span> }; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"number 为 {}"</span>, number); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="rust-循环">Rust 循环</h4>
<h5 id="rust-while循环">rust while循环</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">4</span> { </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, number); </span><br><span class="line">        number += <span class="number">1</span>; </span><br><span class="line">    } </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"EXIT"</span>); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在 C 语言中 for 循环使用for (i = 0; i &lt; 10;
i++)三元语句控制循环，但是 Rust 中没有这种用法，需要用 while
循环来代替：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> { </span><br><span class="line">    <span class="comment">// 循环体 </span></span><br><span class="line">    i += <span class="number">1</span>; </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="rust-for循环">rust for循环</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"值为 : {}"</span>, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="rust-loop-循环相当于whiletrue">rust loop
循环(相当于while(true))</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() { </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = [<span class="string">'R'</span>, <span class="string">'U'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'B'</span>]; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">loop</span> { </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ch</span> = s[i]; </span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">'O'</span> { </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        } </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"\'{}\'"</span>, ch);</span><br><span class="line">        i += <span class="number">1</span>; </span><br><span class="line">    } </span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<p>loop 循环可以通过 break 关键字类似于 return
一样使整个循环退出并给予外部一个返回值。这是一个十分巧妙的设计，因为
loop
这样的循环常被用来当作查找工具使用，如果找到了某个东西当然要将这个结果交出去：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() { </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = [<span class="string">'R'</span>, <span class="string">'U'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'B'</span>]; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">location</span> = <span class="keyword">loop</span> { </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ch</span> = s[i];</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">'O'</span> { </span><br><span class="line">            <span class="keyword">break</span> i; </span><br><span class="line">        } </span><br><span class="line">        i += <span class="number">1</span>; </span><br><span class="line">    }; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">" \'O\' 的索引为 {}"</span>, location); </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'O' 的索引为 3</span><br></pre></td></tr></table></figure>
<h4 id="rust-迭代器">Rust 迭代器</h4>
<p>使用 iter() 方法创建借用迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = vec.<span class="title function_ invoke__">iter</span>();</span><br></pre></td></tr></table></figure>
<p>使用 iter_mut() 方法创建可变借用迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter_mut</span> = vec.<span class="title function_ invoke__">iter_mut</span>();</span><br></pre></td></tr></table></figure>
<p>使用 into_iter() 方法创建获取所有权的迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">into_iter</span> = vec.<span class="title function_ invoke__">into_iter</span>();</span><br></pre></td></tr></table></figure>
<p>Rust
的迭代器提供了丰富的方法来处理集合中的元素，其中一些常见的方法包括：</p>
<ul>
<li><code>map()</code>：对每个元素应用给定的转换函数。</li>
<li><code>filter()</code>：根据给定的条件过滤集合中的元素。</li>
<li><code>fold()</code>：对集合中的元素进行累积处理。</li>
<li><code>skip()</code>：跳过指定数量的元素。</li>
<li><code>take()</code>：获取指定数量的元素。</li>
<li><code>enumerate()</code>：为每个元素提供索引。</li>
<li>......</li>
</ul>
<p>使用 map() 方法对每个元素进行转换：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">squared_vec</span>:<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;= vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x * x).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
<p>使用 filter() 方法根据条件过滤元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">filtered_vec</span>:<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;= vec.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;x| x %<span class="number">2</span>==<span class="number">0</span>).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
<h5 id="使用-for-循环遍历迭代器">使用 for 循环遍历迭代器</h5>
<p>Rust 提供了 for
循环语法来遍历迭代器中的元素，是一种更加简洁和直观的遍历方式。</p>
<p>Rust 的 for 循环底层实际上是使用迭代器的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>&amp;num <span class="keyword">in</span> vec.<span class="title function_ invoke__">iter</span>(){</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, num);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在这个循环中，vec.iter() 返回一个迭代器，for
循环遍历这个迭代器，并将每个元素赋值给 num
变量，然后执行循环体中的代码。</p>
<h5 id="消费迭代器">消费迭代器</h5>
<p>使用迭代器直到它被完全消耗。</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = arr.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(val) = iter.<span class="title function_ invoke__">next</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, val);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="rust-闭包">Rust 闭包</h4>
<p>Rust 中的闭包是一种匿名函数，它们可以捕获并存储其环境中的变量。</p>
<p>闭包允许在其定义的作用域之外访问变量，并且可以在需要时将其移动或借用给闭包。</p>
<p>闭包在 Rust
中被广泛应用于函数式编程、并发编程和事件驱动编程等领域。</p>
<p>闭包在 Rust
中非常有用，因为它们提供了一种简洁的方式来编写和使用函数。</p>
<p>以下是 Rust 闭包的一些关键特性和用法：</p>
<p>闭包的语法声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|参数...|{表达式}</span><br></pre></td></tr></table></figure>
<p>参数可以有类型注解，也可以省略，Rust 编译器会根据上下文推断它们。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one</span> =|x: <span class="type">i32</span>| x +<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>闭包的参数和返回值：</strong>
闭包可以有零个或多个参数，并且可以返回一个值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">calculate</span> =|a, b, c| a * b + c;</span><br></pre></td></tr></table></figure>
<p><strong>闭包的调用：</strong> 闭包可以像函数一样被调用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">calculate</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h5 id="使用实例">使用实例</h5>
<h6 id="匿名函数">匿名函数</h6>
<p>闭包在 Rust 中类似于匿名函数，可以在代码中以 <strong>{}</strong>
语法块的形式定义，使用 <strong>||</strong>
符号来表示参数列表，实例如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add</span> =|a, b| a + b;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, <span class="title function_ invoke__">add</span>(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，add 是一个闭包，接受两个参数 a 和 b，返回它们的和。</p>
<h6 id="捕获外部变量">捕获外部变量</h6>
<p>闭包可以捕获周围环境中的变量，这意味着它可以访问定义闭包时所在作用域中的变量。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">square</span> =|num| num * x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, <span class="title function_ invoke__">square</span>(<span class="number">3</span>));<span class="comment">// 输出: 15</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，闭包 square 捕获了外部变量 x，并在闭包体中使用了它。</p>
<h6 id="移动与借用">移动与借用</h6>
<p>闭包可以通过 <strong>move</strong>
关键字获取外部变量的所有权，或者通过借用的方式获取外部变量的引用。例如：</p>
<p><strong>借用变量：</strong>
默认情况下，闭包会借用它捕获的环境中的变量，这意味着闭包可以使用这些变量，但不能改变它们的所有权。这种情况下，闭包和外部作用域都可以使用这些变量。例如：</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_x</span> = |y| x + y;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, <span class="title function_ invoke__">add_x</span>(<span class="number">5</span>)); <span class="comment">// 输出 15</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, x); <span class="comment">// 仍然可以使用 x</span></span><br></pre></td></tr></table></figure>
<p><strong>获取所有权：</strong> 通过在闭包前添加 move
关键字，闭包会获取它捕获的环境变量的所有权。这意味着这些变量的所有权会从外部作用域转移到闭包内部，外部作用域将无法再使用这些变量。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">print_s</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);</span><br><span class="line"><span class="title function_ invoke__">print_s</span>(); <span class="comment">// 输出 "hello"</span></span><br><span class="line"><span class="comment">// println!("{}", s); // 这行代码将会报错，因为 s 的所有权已经被转移给了闭包</span></span><br></pre></td></tr></table></figure>
<h4 id="rust-所有权">Rust 所有权</h4>
<p>计算机程序必须在运行时管理它们所使用的内存资源。</p>
<p>大多数的编程语言都有管理内存的功能：</p>
<p>C/C++
这样的语言主要通过手动方式管理内存，开发者需要手动的申请和释放内存资源。但为了提高开发效率，只要不影响程序功能的实现，许多开发者没有及时释放内存的习惯。所以手动管理内存的方式常常造成资源浪费。</p>
<p>Java 语言编写的程序在虚拟机（JVM）中运行，JVM
具备自动回收内存资源的功能。但这种方式常常会降低运行时效率，所以 JVM
会尽可能少的回收资源，这样也会使程序占用较大的内存资源。</p>
<p>所有权对大多数开发者而言是一个新颖的概念，它是 Rust
语言为高效使用内存而设计的语法机制。所有权概念是为了让 Rust
在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。</p>
<h5 id="所有权规则">所有权规则</h5>
<p>所有权有以下三条规则：</p>
<ul>
<li>Rust 中的每个值都有一个变量，称为其所有者。</li>
<li>一次只能有一个所有者。</li>
<li>当所有者不在程序运行范围时，该值将被删除。</li>
</ul>
<p>这三条规则是所有权概念的基础。</p>
<p>接下来将介绍与所有权概念有关的概念。</p>
<p>Rust 中没有调用 free 函数来释放字符串 s 的资源（我知道这样在 C
语言中是不正确的写法，因为 "runoob"
不在堆中，这里假设它在）。<strong>Rust
之所以没有明示释放的步骤是因为在变量范围结束的时候，Rust
编译器自动添加了调用释放资源函数的步骤。</strong></p>
<p>这种机制看似很简单了：它不过是帮助程序员在适当的地方添加了一个释放资源的函数调用而已。但这种简单的机制可以有效地解决一个史上最令程序员头疼的编程问题。</p>
<h5 id="变量与数据交互的方式">变量与数据交互的方式</h5>
<p>变量与数据交互方式主要有移动（Move）和克隆（Clone）两种：</p>
<h6 id="移动">移动</h6>
<p>多个变量可以在 Rust 中以不同的方式与相同的数据交互：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<p>这个程序将值 5 绑定到变量 x，然后将 x 的值复制并赋值给变量
y。现在栈中将有两个值
5。此情况中的数据是"基本数据"类型的数据，不需要存储到堆中，仅在栈中的数据的"移动"方式是直接复制，这不会花费更长的时间或更多的存储空间。"基本数据"类型有这些：</p>
<ul>
<li>所有整数类型，例如 i32 、 u32 、 i64 等。</li>
<li>布尔类型 bool，值为 true 或 false 。</li>
<li>所有浮点类型，f32 和 f64。</li>
<li>字符类型 char。</li>
<li>仅包含以上类型数据的元组（Tuples）。</li>
</ul>
<p>但如果发生交互的数据在堆中就是另外一种情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> =<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>
<p>第一步产生一个 String 对象，值为 "hello"。其中 "hello"
可以认为是类似于长度不确定的数据，需要在堆中存储。</p>
<p>第二步的情况略有不同（
<strong>这不是完全真的，仅用来对比参考</strong> ）： <img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-2.png" alt="alt text"></p>
<p>如图所示：两个 String 对象在栈中，每个 String
对象都有一个指针指向堆中的 "hello" 字符串。在给 s2
赋值时，只有栈中的数据被复制了，堆中的字符串依然还是原来的字符串。</p>
<p>前面我们说过，当变量超出范围时，Rust
自动调用释放资源函数并清理该变量的堆内存。但是 s1 和 s2
都被释放的话堆区中的 "hello"
被释放两次，这是不被系统允许的。为了确保安全，在给 s2 赋值时 s1
已经无效了。没错，在把 s1 的值赋给 s2 以后 s1
将不可以再被使用。下面这段程序是错的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 =String::from("hello");</span><br><span class="line">let s2 = s1; </span><br><span class="line">println!("{}, world!", s1);// 错误！s1 已经失效</span><br></pre></td></tr></table></figure>
<p>所以实际情况是： <img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-3.png" alt="alt text"></p>
<p>s1 名存实亡。</p>
<h6 id="克隆">克隆</h6>
<p>Rust会尽可能地降低程序的运行成本，所以默认情况下，长度较大的数据存放在堆中，且采用移动的方式进行数据交互。但如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆。</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1 = {}, s2 = {}"</span>, s1, s2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = hello, s2 = hello</span><br></pre></td></tr></table></figure>
<p>这里是真的将堆中的 "hello" 复制了一份，所以 s1 和 s2
都分别绑定了一个值，释放的时候也会被当作两个资源。</p>
<p>当然，克隆仅在需要复制的情况下使用，毕竟复制数据会花费更多的时间。</p>
<h5 id="涉及函数的所有权机制">涉及函数的所有权机制</h5>
<p>对于变量来说这是最复杂的情况了。</p>
<p>如果将一个变量当作函数的参数传给其他函数，怎样安全的处理所有权呢？</p>
<p>下面这段程序描述了这种情况下所有权机制的运行原理：</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="comment">// s 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);</span><br><span class="line">    <span class="comment">// s 的值被当作参数传入函数</span></span><br><span class="line">    <span class="comment">// 所以可以当作 s 已经被移动，从这里开始已经无效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// x 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);</span><br><span class="line">    <span class="comment">// x 的值被当作参数传入函数</span></span><br><span class="line">    <span class="comment">// 但 x 是基本类型，依然有效</span></span><br><span class="line">    <span class="comment">// 在这里依然可以使用 x 却不能使用 s</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) { </span><br><span class="line">    <span class="comment">// 一个 String 参数 some_string 传入，有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_string);</span><br><span class="line">} <span class="comment">// 函数结束, 参数 some_string 在这里释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) { </span><br><span class="line">    <span class="comment">// 一个 i32 参数 some_integer 传入，有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_integer);</span><br><span class="line">} <span class="comment">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span></span><br></pre></td></tr></table></figure>
<p>如果将变量当作参数传入函数，那么它和移动的效果是一样的。</p>
<h5 id="函数返回值的所有权机制">函数返回值的所有权机制</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();</span><br><span class="line">    <span class="comment">// gives_ownership 移动它的返回值到 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="comment">// s2 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// s2 被当作参数移动, s3 获得返回值所有权</span></span><br><span class="line">} <span class="comment">// s3 无效被释放, s2 被移动, s1 无效被释放.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="comment">// some_string 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> some_string;</span><br><span class="line">    <span class="comment">// some_string 被当作返回值移动出函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> { </span><br><span class="line">    <span class="comment">// a_string 被声明有效</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string 被当作返回值移出函数</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。</p>
<h5 id="引用与租借">引用与租借</h5>
<p>引用（Reference）是 C++ 开发者较为熟悉的概念。</p>
<p>如果你熟悉指针的概念，你可以把它看作一种指针。</p>
<p>实质上"引用"是变量的间接访问方式。</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1 is {}, s2 is {}"</span>, s1, s2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 is hello, s2 is hello</span><br></pre></td></tr></table></figure>
<p><strong>&amp;</strong> 运算符可以取变量的"引用"。</p>
<p>当一个变量的值被引用时，变量本身不会被认定无效。因为"引用"并没有在栈中复制变量的值：
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-4.png" alt="alt text"></p>
<p>引用不会获得值的所有权。</p>
<p>引用只能租借（Borrow）值的所有权。</p>
<p>引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2
将无法继续租借使用 s1 的所有权。如果需要使用 s2
使用该值，必须重新租借：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;</span><br><span class="line">    s2 = &amp;s3; <span class="comment">// 重新从 s3 租借所有权</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序是正确的。</p>
<p>既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。</p>
<p>如果尝试利用租借来的权利来修改数据会被阻止：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"run"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);</span><br><span class="line">    s2.<span class="title function_ invoke__">push_str</span>(<span class="string">"oob"</span>); <span class="comment">// 错误，禁止修改租借的值</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序中 s2 尝试修改 s1
的值被阻止，租借的所有权不能修改所有者的值。</p>
<p>当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"run"</span>);</span><br><span class="line">    <span class="comment">// s1 是可变的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;<span class="keyword">mut</span> s1;</span><br><span class="line">    <span class="comment">// s2 是可变的引用</span></span><br><span class="line"></span><br><span class="line">    s2.<span class="title function_ invoke__">push_str</span>(<span class="string">"oob"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序就没有问题了。我们用 &amp;mut 修饰可变的引用类型。</p>
<p>可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}, {}"</span>, r1, r2);</span><br></pre></td></tr></table></figure>
<p>这段程序不正确，因为多重可变引用了 s。</p>
<p>Rust
对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。</p>
<p>由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。</p>
<h5 id="垂悬引用dangling-references">垂悬引用（Dangling
References）</h5>
<p>这是一个换了个名字的概念，如果放在有指针概念的编程语言里它就指的是那种没有实际指向一个真正能访问的数据的指针（注意，不一定是空指针，还有可能是已经释放的资源）。它们就像失去悬挂物体的绳子，所以叫"垂悬引用"。</p>
<p>"垂悬引用"在 Rust 语言里不允许出现，如果有，编译器会发现它。</p>
<p>下面是一个垂悬的典型案例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>很显然，伴随着 dangle
函数的结束，其局部变量的值本身没有被当作返回值，被释放了。但它的引用却被返回，这个引用所指向的值已经不能确定的存在，故不允许其出现。</p>
<h4 id="rust-slice切片类型不难">Rust Slice（切片）类型(不难)</h4>
<p>切片（Slice）是对数据值的部分引用。</p>
<p>切片这个名字往往出现在生物课上，我们做样本玻片的时候要从生物体上获取切片，以供在显微镜上观察。在
Rust 中，切片的意思大致也是这样，只不过它从数据取材引用。</p>
<h5 id="字符串切片">字符串切片</h5>
<p>最简单、最常用的数据切片类型是字符串切片（String Slice）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"broadcast"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part1</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part2</span> = &amp;s[<span class="number">5</span>..<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}={}+{}"</span>, s, part1, part2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-5.png" alt="alt text">
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>上图解释了字符串切片的原理（注：Rust
中的字符串类型实质上记录了字符在内存中的起始位置和其长度，我们暂时了解到这一点）。</p>
<p>使用 <strong>..</strong>
表示范围的语法在循环章节中出现过。<strong>x..y</strong> 表示 <strong>[x,
y)</strong> 的数学含义。<strong>..</strong> 两边可以没有运算数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">..y 等价于0..y</span><br><span class="line">x..等价于位置 x 到数据结束</span><br><span class="line">..等价于位置0到结束</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>
<strong>到目前为止，尽量不要在字符串中使用非英文字符，因为编码的问题。具体原因会在"字符串"章节叙述。</strong></p>
<p><strong>被切片引用的字符串禁止更改其值：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">"yes!"</span>); <span class="comment">// 错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"slice = {}"</span>, slice);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序不正确。</p>
<p>s 被部分引用，禁止更改其值。</p>
<p>实际上，到目前为止你一定疑惑为什么每一次使用字符串都要这样写<strong>String::from("runoob")</strong>
，直接写 <strong>"runoob"</strong> 不行吗？</p>
<p>事已至此我们必须分辨这两者概念的区别了。<strong>在 Rust
中有两种常用的字符串类型：str 和 String。</strong></p>
<p><strong>str 是 Rust
核心语言类型，就是本章一直在讲的字符串切片（String
Slice），常常以引用的形式出现（&amp;str）。</strong></p>
<p><strong>凡是用双引号包括的字符串常量整体的类型性质都是 &amp;str
：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>这里的 s 就是一个 &amp;str 类型的变量。</p>
<p>String 类型是 Rust
标准公共库提供的一种数据类型，它的功能更完善——它支持字符串的追加、清空等实用的操作。String
和 str
除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（capacity）属性。</p>
<p>String 和 str 都支持切片，切片的结果是 &amp;str 类型的数据。</p>
<p><strong>注意：切片结果必须是引用类型，但开发者必须自己明示这一点:</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>有一个快速的办法可以将 String 转换成 &amp;str：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> =<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> =&amp;s1[..];</span><br></pre></td></tr></table></figure>
<h5 id="非字符串切片">非字符串切片</h5>
<p>除了字符串以外，其他一些线性数据结构也支持切片操作，例如数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part</span> = &amp;arr[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> part.<span class="title function_ invoke__">iter</span>() {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="rust-结构体">Rust 结构体</h4>
<h5 id="结构体定义">结构体定义</h5>
<p>这是一个结构体定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">structSite{</span><br><span class="line">    domain:<span class="type">String</span>,</span><br><span class="line">    name:<span class="type">String</span>,</span><br><span class="line">    nation:<span class="type">String</span>,</span><br><span class="line">    found: <span class="type">u32</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>注意：如果你常用 C/C++，请记住在 Rust 里 struct
语句仅用来定义，不能声明实例，结尾不需要 ; 符号，而且每个字段定义之后用
, 分隔。</strong></p>
<h5 id="结构体实例">结构体实例</h5>
<p>Rust 很多地方受 JavaScript 影响，在实例化结构体的时候用 JSON 对象的
<strong>key: value</strong> 语法来实现定义：</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">runoob</span> = Site {</span><br><span class="line">    domain: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"www.runoob.com"</span>),</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"RUNOOB"</span>),</span><br><span class="line">    nation: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"China"</span>),</span><br><span class="line">    found: <span class="number">2013</span></span><br><span class="line">}; </span><br></pre></td></tr></table></figure>
<p>如果你不了解 JSON 对象，你可以不用管它，记住格式就可以了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体类名 {</span><br><span class="line">    字段名 : 字段值,</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这样的好处是不仅使程序更加直观，还不需要按照定义的顺序来输入成员的值。</p>
<p>如果正在实例化的结构体有字段名称和现存变量名称一样的，可以简化书写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">domain</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"www.runoob.com"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"RUNOOB"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">runoob</span> = Site {</span><br><span class="line">    domain,  <span class="comment">// 等同于 domain : domain,</span></span><br><span class="line">    name,    <span class="comment">// 等同于 name : name,</span></span><br><span class="line">    nation: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"China"</span>),</span><br><span class="line">    traffic: <span class="number">2013</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>有这样一种情况：你想要新建一个结构体的实例，其中大部分属性需要被设置成与现存的一个结构体属性一样，仅需更改其中的一两个字段的值，可以使用结构体更新语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">site</span> = Site {</span><br><span class="line">    domain: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"www.runoob.com"</span>),</span><br><span class="line">    name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"RUNOOB"</span>),</span><br><span class="line">    ..runoob</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>注意：<strong>..runoob</strong>
后面不可以有逗号。这种语法不允许一成不变的复制另一个结构体实例，意思就是说至少重新设定一个字段的值才能引用其他实例的值。</p>
<h5 id="元组结构体">元组结构体</h5>
<p>有一种更简单的定义和使用结构体的方式： <strong>元组结构体</strong>
。</p>
<p>元组结构体是一种形式是元组的结构体。</p>
<p>与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">structColor</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line"><span class="title function_ invoke__">structPoint</span>(<span class="type">f64</span>, <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> =<span class="title function_ invoke__">Color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> =<span class="title function_ invoke__">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>
<p>"颜色"和"点坐标"是常用的两种数据类型，但如果实例化时写个大括号再写上两个名字就为了可读性牺牲了便捷性，Rust
不会遗留这个问题。元组结构体对象的使用方式和元组一样，通过 .
和下标来进行访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">f64</span>, <span class="type">f64</span>);    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="built_in">println!</span>(<span class="string">"black = ({}, {}, {})"</span>, black.<span class="number">0</span>, black.<span class="number">1</span>, black.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"origin = ({}, {})"</span>, origin.<span class="number">0</span>, origin.<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="结构体所有权">结构体所有权</h5>
<p><strong>结构体必须掌握字段值所有权，因为结构体失效的时候会释放所有字段。</strong></p>
<p><strong>这就是为什么本章的案例中使用了 String 类型而不使用 &amp;str
的原因。</strong></p>
<p>但这不意味着结构体中不定义引用型字段，这需要通过"生命周期"机制来实现。</p>
<p>但现在还难以说明"生命周期"概念，所以只能在后面章节说明。</p>
<h5 id="输出结构体">输出结构体</h5>
<p>调试中，完整地显示出一个结构体实例是非常有用的。但如果我们手动的书写一个格式会非常的不方便。所以
Rust 提供了一个方便地输出一整个结构体的方法：</p>
<p>实例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle { width: <span class="number">30</span>, height: <span class="number">50</span> };    <span class="built_in">println!</span>(<span class="string">"rect1 is {:?}"</span>, rect1);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如第一行所示：一定要导入调试库 <strong>#[derive(Debug)]</strong>
，之后在 println 和 print 宏中就可以用 <strong>{:?}</strong>
占位符输出一整个结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rect1 isRectangle{ width:30, height:50}</span><br></pre></td></tr></table></figure>
<p>如果属性较多的话可以使用另一个占位符 <strong>{:#?}</strong> 。</p>
<p>输出结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rect1 isRectangle{</span><br><span class="line">    width:<span class="number">30</span>,</span><br><span class="line">    height:<span class="number">50</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="结构体方法">结构体方法</h5>
<p>方法（Method）和函数（Function）类似，只不过它是用来操作结构体实例的。</p>
<p><strong>Rust
语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象的珍贵思想可以在
Rust 实现。</strong></p>
<p><strong>结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为
self 不是一种风格而是关键字。</strong></p>
<p>计算一个矩形的面积：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle { width: <span class="number">30</span>, height: <span class="number">50</span> };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1's area is {}"</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>请注意，在调用结构体方法的时候不需要填写 self
，这是出于对使用方便性的考虑。</p>
<p>一个多参数的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wider</span>(&amp;<span class="keyword">self</span>, rect: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> {</span><br><span class="line">        <span class="keyword">self</span>.width &gt; rect.width</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle { width: <span class="number">30</span>, height: <span class="number">50</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle { width: <span class="number">40</span>, height: <span class="number">20</span> };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, rect1.<span class="title function_ invoke__">wider</span>(&amp;rect2));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="结构体关联函数">结构体关联函数</h5>
<p>之所以"结构体方法"不叫"结构体函数"是因为"函数"这个名字留给了这种函数：它在
impl 块中却没有 &amp;self 参数。</p>
<p>这种函数不依赖实例，但是使用它需要声明是在哪个 impl 块中的。</p>
<p>一直使用的 <strong>String::from</strong> 函数就是一个"关联函数"。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle {</span><br><span class="line">        Rectangle { width, height }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">create</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, rect);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>贴士：</strong> 结构体 impl
块可以写几次，效果相当于它们内容的拼接！</p>
<h5 id="单元结构体">单元结构体</h5>
<p>结构体可以只作为一种象征而无需任何成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">structUnitStruct;</span><br></pre></td></tr></table></figure>
<p>我们称这种没有身体的结构体为单元结构体（Unit Struct）。</p>
<h4 id="rust-枚举类">Rust 枚举类</h4>
<p>枚举类在 Rust
中并不像其他编程语言中的概念那样简单，但依然可以十分简单的使用：</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line"></span><br><span class="line">enum Book {</span><br><span class="line">    Papery, Electronic</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fn main() {</span><br><span class="line">    let book = Book::Papery;</span><br><span class="line">    println!("{:?}", book);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Papery</span><br></pre></td></tr></table></figure>
<h5 id="match-语法">match 语法</h5>
<p>枚举的目的是对某一类事物的分类，分类的目的是为了对不同的情况进行描述。基于这个原理，往往枚举类最终都会被分支结构处理（许多语言中的
switch ）。 switch 语法很经典，但在 Rust 中并不支持，很多语言摒弃 switch
的原因都是因为 switch 容易存在因忘记添加 break
而产生的串接运行问题，Java 和 C#
这类语言通过安全检查杜绝这种情况出现。</p>
<p>Rust 通过 match 语句来实现分支结构。先认识一下如何用 match
处理枚举类：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Book</span> {</span><br><span class="line">        Papery {index: <span class="type">u32</span>},</span><br><span class="line">        Electronic {url: <span class="type">String</span>},</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book</span> = Book::Papery{index: <span class="number">1001</span>};</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ebook</span> = Book::Electronic{url: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"url..."</span>)};</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">match</span> book {</span><br><span class="line">        Book::Papery { index } =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Papery book {}"</span>, index);</span><br><span class="line">        },</span><br><span class="line">        Book::Electronic { url } =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"E-book {}"</span>, url);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Papery book 1001</span><br></pre></td></tr></table></figure>
<p>match 块也可以当作函数表达式来对待，它也是可以有返回值的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match 枚举类实例{</span><br><span class="line">    分类1=&gt;返回值表达式,</span><br><span class="line">    分类2=&gt;返回值表达式,</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>但是所有返回值表达式的类型必须一样！</p>
<p>如果把枚举类附加属性定义成元组，在 match
块中需要临时指定一个名字：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Book</span> {</span><br><span class="line">    <span class="title function_ invoke__">Papery</span>(<span class="type">u32</span>),</span><br><span class="line">    Electronic {url: <span class="type">String</span>},</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> <span class="variable">book</span> = Book::<span class="title function_ invoke__">Papery</span>(<span class="number">1001</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> book {</span><br><span class="line">    Book::<span class="title function_ invoke__">Papery</span>(i) =&gt; {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, i);</span><br><span class="line">    },</span><br><span class="line">    Book::Electronic { url } =&gt; {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, url);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>match
除了能够对枚举类进行分支选择以外，还可以对整数、浮点数、字符和字符串切片引用（&amp;str）类型的数据进行分支选择。其中，浮点数类型被分支选择虽然合法，但不推荐这样使用，因为精度问题可能会导致分支错误。</p>
<p>对非枚举类进行分支选择时必须注意处理例外情况，即使在例外情况下没有任何要做的事
<strong>.</strong> 例外情况用下划线 **_** 表示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">match</span> t {</span><br><span class="line">        <span class="string">"abc"</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Yes"</span>),</span><br><span class="line">        _ =&gt; {},</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="option-枚举类">Option 枚举类</h5>
<p>Option 是 Rust 标准库中的枚举类，这个类用于填补 Rust 不支持 null
引用的空白。</p>
<p>许多语言支持 null
的存在（C/C++、Java），这样很方便，但也制造了极大的问题，null
的发明者也承认这一点，"一个方便的想法造成累计 10 亿美元的损失"。</p>
<p>null 经常在开发者把一切都当作不是 null
的时候给予程序致命一击：毕竟只要出现一个这样的错误，程序的运行就要彻底终止。</p>
<p><strong>为了解决这个问题，很多语言默认不允许 null，但在语言层面支持
null 的出现（常在类型前面用 ? 符号修饰）。</strong></p>
<p>Java 默认支持 null，但可以通过 <span class="citation" data-cites="NotNull">@NotNull</span> 注解限制出现
null，这是一种应付的办法。</p>
<p><strong>Rust 在语言层面彻底不允许空值 null
的存在</strong>，但无奈null 可以高效地解决少量的问题，<strong>所以 Rust
引入了 Option 枚举类</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果你想定义一个可以为空值的类，你可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let opt =Option::Some("Hello");</span><br></pre></td></tr></table></figure>
<p>如果你想针对 opt 执行某些操作，你必须先判断它是否是
<strong>Option::None</strong> ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span> = <span class="type">Option</span>::<span class="title function_ invoke__">Some</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">match</span> opt {</span><br><span class="line">        <span class="type">Option</span>::<span class="title function_ invoke__">Some</span>(something) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, something);</span><br><span class="line">        },</span><br><span class="line">        <span class="type">Option</span>::<span class="literal">None</span> =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"opt is nothing"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果你的变量刚开始是空值，你体谅一下编译器，它怎么知道值不为空的时候变量是什么类型的呢？</p>
<p>所以初始值为空的 Option 必须明确类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">opt</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="type">Option</span>::<span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">match</span> opt {</span><br><span class="line">        <span class="type">Option</span>::<span class="title function_ invoke__">Some</span>(something) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, something);</span><br><span class="line">        },</span><br><span class="line">        <span class="type">Option</span>::<span class="literal">None</span> =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"opt is nothing"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这种设计会让空值编程变得不容易，但这正是构建一个稳定高效的系统所需要的。<strong>由于
Option 是 Rust 编译器默认引入的，在使用时可以省略 Option:: 直接写 None
或者 Some()。</strong></p>
<p>Option 是一种特殊的枚举类，它可以含值分支选择：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t</span> = <span class="title function_ invoke__">Some</span>(<span class="number">64</span>);</span><br><span class="line">        <span class="keyword">match</span> t {</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(<span class="number">64</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"Yes"</span>),</span><br><span class="line">                _ =&gt; <span class="built_in">println!</span>(<span class="string">"No"</span>),</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="if-let-语法">if let 语法</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">match</span> i {</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">"zero"</span>),</span><br><span class="line">    _ =&gt; {},</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序的目的是判断 i 是否是数字 0，如果是就打印 zero。</p>
<p>现在用 if let 语法缩短这段代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="number">0</span> = i {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"zero"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>if let 语法格式如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> 匹配值 = 源变量 {</span><br><span class="line">    语句块</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>可以在之后添加一个 else 块来处理例外情况。</p>
<p>if let 语法可以认为是只区分两种情况的 match
语句的"语法糖"（语法糖指的是某种语法的原理相同的便捷替代品）。</p>
<p>对于枚举类依然适用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Book</span> {</span><br><span class="line">        <span class="title function_ invoke__">Papery</span>(<span class="type">u32</span>),</span><br><span class="line">        <span class="title function_ invoke__">Electronic</span>(<span class="type">String</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">book</span> = Book::<span class="title function_ invoke__">Electronic</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"url"</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Book</span>::<span class="title function_ invoke__">Papery</span>(index) = book {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Papery {}"</span>, index);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Not papery book"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="rust-组织管理">Rust 组织管理</h4>
<p>Rust 中有三个重要的组织概念：箱、包、模块。</p>
<h5 id="箱crate">箱（Crate）</h5>
<p>"箱"是二进制程序文件或者库文件，存在于"包"中。</p>
<p>"箱"是树状结构的，它的树根是编译器开始运行时编译的源文件所编译的程序。</p>
<p>注意："二进制程序文件"不一定是"二进制可执行文件"，只能确定是是包含目标机器语言的文件，文件格式随编译环境的不同而不同。</p>
<h5 id="包package">包（Package）</h5>
<p>当我们使用 Cargo 执行 new 命令创建 Rust 工程时，工程目录下会建立一个
Cargo.toml 文件。工程的实质就是一个包，包必须由一个 Cargo.toml
文件来管理，该文件描述了包的基本信息以及依赖项。</p>
<p>一个包最多包含一个库"箱"，可以包含任意数量的二进制"箱"，但是至少包含一个"箱"（不管是库还是二进制"箱"）。</p>
<p>当使用 cargo new 命令创建完包之后，src 目录下会生成一个 main.rs
源文件，Cargo
默认这个文件为二进制箱的根，编译之后的二进制箱将与包名相同。</p>
<h5 id="模块module">模块（Module）</h5>
<p>对于一个软件工程来说，我们往往按照所使用的编程语言的组织规范来进行组织，组织模块的主要结构往往是树。Java
组织功能模块的主要单位是类，而 JavaScript 组织模块的主要方式是
function。</p>
<p>这些先进的语言的组织单位可以层层包含，就像文件系统的目录结构一样。Rust
中的组织单位是模块（Module）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nation {</span><br><span class="line">    <span class="keyword">mod</span> government {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">govern</span>() {}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">mod</span> congress {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">legislate</span>() {}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">mod</span> court {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">judicial</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这是一段描述法治国家的程序：国家（nation）包括政府（government）、议会（congress）和法院（court），分别有行政、立法和司法的功能。我们可以把它转换成树状结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nation</span><br><span class="line"> ├── government</span><br><span class="line"> │ └── govern</span><br><span class="line"> ├── congress</span><br><span class="line"> │ └── legislate</span><br><span class="line"> └── court</span><br><span class="line">   └── judicial</span><br></pre></td></tr></table></figure>
<p>在文件系统中，目录结构往往以斜杠在路径字符串中表示对象的位置，Rust
中的路径分隔符是 <strong>::</strong> 。</p>
<p>路径分为绝对路径和相对路径。绝对路径从 crate
关键字开始描述。相对路径从 self 或 super
关键字或一个标识符开始描述。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crate::nation::government::<span class="title function_ invoke__">govern</span>();</span><br></pre></td></tr></table></figure>
<p>是描述 govern 函数的绝对路径，相对路径可以表示为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nation::government::<span class="title function_ invoke__">govern</span>();</span><br></pre></td></tr></table></figure>
<p>现在你可以尝试在一个源程序里定义类似的模块结构并在主函数中使用路径。</p>
<p>如果你这样做，你一定会发现它不正确的地方：government
模块和其中的函数都是私有（private）的，你不被允许访问它们。</p>
<h5 id="访问权限">访问权限</h5>
<p>Rust 中有两种简单的访问权：公共（public）和私有（private）。</p>
<p>默认情况下，如果不加修饰符，模块中的成员访问权将是私有的。</p>
<p>如果想使用公共权限，需要使用 pub 关键字。</p>
<p>对于私有的模块，只有在与其平级的位置或下级的位置才能访问，不能从其外部访问。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nation {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> government {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">govern</span>() {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> congress {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">legislate</span>() {}</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">mod</span> court {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">judicial</span>() {</span><br><span class="line">            super::congress::<span class="title function_ invoke__">legislate</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    nation::government::<span class="title function_ invoke__">govern</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序是能通过编译的。请注意观察 court 模块中 super
的访问方法。</p>
<p>如果模块中定义了结构体，结构体除了其本身是私有的以外，其字段也默认是私有的。所以如果想使用模块中的结构体以及其字段，需要
pub 声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> {</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast {</span><br><span class="line">            Breakfast {</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"peaches"</span>),</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">"Rye"</span>);</span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Wheat"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I'd like {} toast please"</span>, meal.toast);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">eat_at_restaurant</span>()</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>枚举类枚举项可以内含字段，但不具备类似的性质:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> SomeModule {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Person</span> {</span><br><span class="line">        King {</span><br><span class="line">            name: <span class="type">String</span></span><br><span class="line">        },</span><br><span class="line">        Queen</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = SomeModule::Person::King{</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Blue"</span>)</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">match</span> person {</span><br><span class="line">        SomeModule::Person::King {name} =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, name);</span><br><span class="line">        }</span><br><span class="line">        _ =&gt; {}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blue</span><br></pre></td></tr></table></figure>
<h5 id="难以发现的模块">难以发现的模块</h5>
<p>使用过 Java 的开发者在编程时往往非常讨厌最外层的 class
块——它的名字与文件名一模一样，因为它就表示文件容器，尽管它很繁琐但我们不得不写一遍来强调"这个类是文件所包含的类"。</p>
<p>不过这样有一些好处：起码它让开发者明明白白的意识到了类包装的存在，而且可以明确的描述类的继承关系。</p>
<p>在 Rust 中，模块就像是 Java
中的类包装，但是文件一开头就可以写一个主函数，这该如何解释呢？</p>
<p>每一个 Rust 文件的内容都是一个"难以发现"的模块。</p>
<p>让我们用两个文件来揭示这一点：</p>
<p><strong>main.rs 文件</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.rs</span></span><br><span class="line"><span class="keyword">mod</span> second_module;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"This is the main module."</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, second_module::<span class="title function_ invoke__">message</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>second_module.rs 文件</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// second_module.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">message</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"This is the 2nd module."</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thisis the main module.</span><br><span class="line">Thisis the 2ndmodule.</span><br></pre></td></tr></table></figure>
<h5 id="use-关键字">use 关键字</h5>
<p>use 关键字能够将模块标识符引入当前作用域：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nation {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> government {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">govern</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::nation::government::govern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">govern</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序能够通过编译。</p>
<p>因为 use 关键字把 govern
标识符导入到了当前的模块下，可以直接使用。</p>
<p>这样就解决了局部模块路径过长的问题。</p>
<p>当然，有些情况下存在两个相同的名称，且同样需要导入，我们可以使用 as
关键字为标识符添加别名：</p>
<p>示例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nation {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> government {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">govern</span>() {}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">govern</span>() {}</span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">use</span> crate::nation::government::govern;</span><br><span class="line"><span class="keyword">use</span> crate::nation::govern <span class="keyword">as</span> nation_govern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">nation_govern</span>();</span><br><span class="line">    <span class="title function_ invoke__">govern</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里有两个 govern 函数，一个是 nation 下的，一个是 government
下的，我们用 as 将 nation 下的取别名
nation_govern。两个名称可以同时使用。</p>
<p>use 关键字可以与 pub 关键字配合使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> nation {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> government {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">govern</span>() {}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> government::govern;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    nation::<span class="title function_ invoke__">govern</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="引用标准库">引用标准库</h5>
<p>Rust 官方标准库字典：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/all.html">https://doc.rust-lang.org/stable/std/all.html</a></p>
<p>在学习了本章的概念之后，我们可以轻松的导入系统库来方便的开发程序了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">f64</span>::consts::PI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, (PI / <span class="number">2.0</span>).<span class="title function_ invoke__">sin</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>所有的系统库模块都是被默认导入的，所以在使用的时候只需要使用 use
关键字简化路径就可以方便的使用了。</p>
<h4 id="rust-错误处理">Rust 错误处理</h4>
<p>Rust 有一套独特的处理异常情况的机制，它并不像其它语言中的 try
机制那样简单。</p>
<p>首先，程序中一般会出现两种错误：<strong>可恢复错误和不可恢复错误</strong>。</p>
<p>可恢复错误的典型案例是文件访问错误，如果访问一个文件失败，有可能是因为它正在被占用，是正常的，我们可以通过等待来解决。</p>
<p>但还有一种错误是由编程中无法解决的逻辑错误导致的，例如访问数组末尾以外的位置。</p>
<p>大多数编程语言不区分这两种错误，并用 Exception
（异常）类来表示错误。<strong>在 Rust 中没有 Exception</strong>。</p>
<p>对于可恢复错误用 <strong>Result&lt;T, E&gt;
类</strong>来处理，对于不可恢复错误使用 <strong>panic!
宏</strong>来处理。</p>
<h5 id="不可恢复错误">不可恢复错误</h5>
<p>本章以前没有专门介绍 Rust 宏的语法，但已经使用过了 println!
宏，因为这些宏的使用较为简单，所以暂时不需要彻底掌握它，我们可以用同样的方法先学会使用
panic! 宏的使用方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"error occured"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, Rust"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread 'main' panicked at 'error occured', src\main.rs:3:5</span><br><span class="line">note: run with`RUST_BACKTRACE=1` environment variable to display a backtrace.</span><br></pre></td></tr></table></figure>
<p>很显然，程序并不能如约运行到 println!("Hello, Rust") ，而是在 panic!
宏被调用时停止了运行。</p>
<p>不可恢复的错误一定会导致程序受到致命的打击而终止运行。</p>
<p>让我们注视错误输出的两行：</p>
<ul>
<li>第一行输出了 panic! 宏调用的位置以及其输出的错误信息。</li>
<li>第二行是一句提示，翻译成中文就是"通过 <code>RUST_BACKTRACE=1</code>
环境变量运行以显示回溯"。接下来我们将介绍回溯（backtrace）。</li>
</ul>
<p>紧接着刚才的例子，我们在 VSCode 中新建一个终端： <img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-6.png" alt="alt text"></p>
<p>在新建的终端里设置环境变量（不同的终端方法不同，这里介绍两种主要的方法）：</p>
<p>如果在 Windows 7 及以上的 Windows 系统版本中，默认使用的终端命令行是
Powershell，请使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$env:RUST_BACKTRACE=1; cargo run</span><br></pre></td></tr></table></figure>
<p>如果你使用的是 Linux 或 macOS 等 UNIX 系统，一般情况下默认使用的是
bash 命令行，请使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure>
<p>然后，你会看到以下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread 'main' panicked at 'error occured', src\main.rs:3:5</span><br><span class="line">stack backtrace:</span><br><span class="line">  ...</span><br><span class="line">  11: greeting::main</span><br><span class="line">             at .\src\main.rs:3</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>回溯是不可恢复错误的另一种处理方式，它会展开运行的栈并输出所有的信息，然后程序依然会退出。上面的省略号省略了大量的输出信息，我们可以找到我们编写的
panic! 宏触发的错误。</p>
<h5 id="可恢复的错误">可恢复的错误</h5>
<p>此概念十分类似于 Java 编程语言中的异常。实际上在 C
语言中我们就常常将函数返回值设置成整数来表达函数遇到的错误，在 Rust
中通过 Result&lt;T, E&gt; 枚举类作返回值来进行异常表达：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enumResult&lt;T, E&gt;{</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在 Rust 标准库中可能产生异常的函数的返回值都是 Result
类型的。例如：当我们尝试打开一个文件时：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="keyword">match</span> f {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"File opened successfully."</span>);</span><br><span class="line">        },</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Failed to open the file."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果 hello.txt 文件不存在，会打印 <strong>"Failed to open the
file."</strong> 。</p>
<p>当然，我们在枚举类章节讲到的 if let 语法可以简化 match 语法块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(file) = f {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"File opened successfully."</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Failed to open the file."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>如果想使一个可恢复错误按不可恢复错误处理，Result
类提供了两个办法：unwrap() 和 expect(message: &amp;str) ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f1</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f2</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>).<span class="title function_ invoke__">expect</span>(<span class="string">"Failed to open."</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序相当于在 Result 为 Err 时调用 panic! 宏。两者的区别在于
expect 能够向 panic! 宏发送一段指定的错误信息。</p>
<h5 id="可恢复的错误的传递">可恢复的错误的传递</h5>
<p>之前所讲的是接收到错误的处理方式，但是如果我们自己编写一个函数在遇到错误时想传递出去怎么办呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">bool</span>&gt; {</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> { <span class="title function_ invoke__">Ok</span>(i) }</span><br><span class="line">    <span class="keyword">else</span> { <span class="title function_ invoke__">Err</span>(<span class="literal">false</span>) }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">f</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(v) = r {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Ok: f(-1) = {}"</span>, v);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Err"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ok: f(-1)=10000</span><br></pre></td></tr></table></figure>
<p>这段程序中函数 f 是错误的根源，现在我们再写一个传递错误的函数 g
：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">g</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">bool</span>&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="title function_ invoke__">f</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">match</span> t {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(i) =&gt; <span class="title function_ invoke__">Ok</span>(i),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(b) =&gt; <span class="title function_ invoke__">Err</span>(b)</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>函数 g 传递了函数 f 可能出现的错误（这里的 g
只是一个简单的例子，实际上传递错误的函数一般还包含很多其它操作）。</p>
<p>这样写有些冗长，Rust 中可以在 Result 对象后添加 ? 操作符将同类的 Err
直接传递出去：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">bool</span>&gt; {</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> { <span class="title function_ invoke__">Ok</span>(i) }</span><br><span class="line">    <span class="keyword">else</span> { <span class="title function_ invoke__">Err</span>(<span class="literal">false</span>) }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">g</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">bool</span>&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="title function_ invoke__">f</span>(i)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(t) <span class="comment">// 因为确定 t 不是 Err, t 在这里已经是 i32 类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">g</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(v) = r {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Ok: g(10000) = {}"</span>, v);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Err"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ok: g(10000)=10000</span><br></pre></td></tr></table></figure>
<p><strong>?</strong> 符的实际作用是将 Result
类非异常的值直接取出，如果有异常就将异常 Result 返回出去。所以，?
符仅用于返回值类型为 Result&lt;T, E&gt; 的函数，其中 E 类型必须和 ?
所处理的 Result 的 E 类型一致。</p>
<h5 id="kind-方法">kind 方法</h5>
<p>到此为止，Rust 似乎没有像 try
块一样可以令任何位置发生的同类异常都直接得到相同的解决的语法，但这样并不意味着
Rust 实现不了：我们完全可以把 try
块在独立的函数中实现，将所有的异常都传递出去解决。实际上这才是一个分化良好的程序应当遵循的编程方法：应该注重独立功能的完整性。</p>
<p>但是这样需要判断 Result 的 Err 类型，获取 Err 类型的函数是
kind()。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_text_from_file</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_file</span> = <span class="title function_ invoke__">read_text_from_file</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line">    <span class="keyword">match</span> str_file {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; {</span><br><span class="line">            <span class="keyword">match</span> e.<span class="title function_ invoke__">kind</span>() {</span><br><span class="line">                io::ErrorKind::NotFound =&gt; {</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">"No such file"</span>);</span><br><span class="line">                },</span><br><span class="line">                _ =&gt; {</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">"Cannot read the file"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No such file</span><br></pre></td></tr></table></figure>
<h4 id="rust-泛型与特性">Rust 泛型与特性</h4>
<p>泛型是一个编程语言不可或缺的机制。</p>
<p>C++ 语言中用"模板"来实现泛型，而 C 语言中没有泛型的机制，这也导致 C
语言难以构建类型复杂的工程。</p>
<p>泛型机制是编程语言用于表达类型抽象的机制，一般用于功能确定、数据类型待定的类，如链表、映射表等。</p>
<h5 id="在函数中定义泛型">在函数中定义泛型</h5>
<p>这是一个对整型数字选择排序的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>(array: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; array.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        <span class="keyword">if</span> array[i] &gt; array[max_index] {</span><br><span class="line">            max_index = i;</span><br><span class="line">        }</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    array[max_index]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"max = {}"</span>, <span class="title function_ invoke__">max</span>(&amp;a));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这是一个简单的取最大值程序，可以用于处理 i32
数字类型的数据，但无法用于 f64
类型的数据。通过使用泛型我们可以使这个函数可以利用到各个类型中去。但实际上并不是所有的数据类型都可以比大小，所以接下来一段代码并不是用来运行的，而是用来描述一下函数泛型的语法格式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>&lt;T&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> T {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; array.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        <span class="keyword">if</span> array[i] &gt; array[max_index] {</span><br><span class="line">            max_index = i;</span><br><span class="line">        }</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    array[max_index]</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="结构体与枚举类中的泛型">结构体与枚举类中的泛型</h5>
<p>在之前我们学习的 Option 和 Result 枚举类就是泛型的。</p>
<p>Rust 中的结构体和枚举类都可以实现泛型机制。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; {</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这是一个点坐标结构体，T
表示描述点坐标的数字类型。我们可以这样使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = Point {x: <span class="number">1</span>, y: <span class="number">2</span>};</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = Point {x: <span class="number">1.0</span>, y: <span class="number">2.0</span>};</span><br></pre></td></tr></table></figure>
<p>使用时并没有声明类型，这里使用的是自动类型机制，但不允许出现类型不匹配的情况如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point {x: <span class="number">1</span>, y: <span class="number">2.0</span>};</span><br></pre></td></tr></table></figure>
<p>x 与 1 绑定时就已经将 T 设定为 i32，所以不允许再出现 f64
的类型。如果我们想让 x 与 y
用不同的数据类型表示，可以使用两个泛型标识符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T1, T2&gt; {</span><br><span class="line">    x: T1,</span><br><span class="line">    y: T2</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在枚举类中表示泛型的方法诸如 Option 和 Result：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>结构体与枚举类都可以定义方法，那么方法也应该实现泛型的机制，否则泛型的类将无法被有效的方法操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; {</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point { x: <span class="number">1</span>, y: <span class="number">2</span> };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = {}"</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.x =1</span><br></pre></td></tr></table></figure>
<p>注意，impl 关键字的后方必须有
<strong><code>&lt;T&gt;</code></strong>，因为它后面的 T
是以之为榜样的。但我们也可以为其中的一种泛型添加方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Point&lt;f64&gt;{</span><br><span class="line">    fn x(&amp;self)-&gt; f64 {</span><br><span class="line">        self.x</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>impl 块本身的泛型并没有阻碍其内部方法具有泛型的能力：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T, U&gt;Point&lt;T, U&gt;{</span><br><span class="line">    fn mixup&lt;V, W&gt;(self, other:Point&lt;V, W&gt;)-&gt;Point&lt;T, W&gt;{</span><br><span class="line">        Point{</span><br><span class="line">            x:self.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>方法 mixup 将一个 Point&lt;T, U&gt; 点的 x 与 Point&lt;V, W&gt; 点的
y 融合成一个类型为 Point&lt;T, W&gt; 的新点。</p>
<h5 id="特性trait">特性（trait）</h5>
<p>特性（trait）概念接近于 Java
中的接口（Interface），但两者不完全相同。特性与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。</p>
<p>特性在 Rust 中用 trait 表示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Descriptive</span>{</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">describe</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">String</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Descriptive 规定了实现者必需有 <strong>describe(&amp;self) -&gt;
String</strong> 方法。</p>
<p>我们用它实现一个结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Descriptive</span> <span class="keyword">for</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">describe</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{} {}"</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl &lt;特性名&gt; for &lt;所实现的类型名&gt;</span><br></pre></td></tr></table></figure>
<p>Rust 同一个类可以实现多个特性，每个 impl 块只能实现一个。</p>
<h5 id="默认特性">默认特性</h5>
<p>这是特性与接口的不同点：接口只能规范方法而不能定义方法，但特性可以定义方法作为默认方法，因为是"默认"，所以对象既可以重新定义方法，也可以不重新定义方法使用默认的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Descriptive</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">describe</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"[Object]"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Descriptive</span> <span class="keyword">for</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">describe</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{} {}"</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cali</span> = Person {</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Cali"</span>),</span><br><span class="line">        age: <span class="number">24</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, cali.<span class="title function_ invoke__">describe</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cali 24</span><br></pre></td></tr></table></figure>
<p>如果我们将 impl Descriptive for Person
块中的内容去掉，那么运行结果就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Object]</span><br></pre></td></tr></table></figure>
<h5 id="特性做参数">特性做参数</h5>
<p>很多情况下我们需要传递一个函数做参数，例如回调函数、设置按钮事件等。在
Java 中函数必须以接口实现的类实例来传递，在 Rust
中可以通过传递特性参数来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">output</span>(object: <span class="keyword">impl</span> <span class="title class_">Descriptive</span>){</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>,object.<span class="title function_ invoke__">describe</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>任何实现了 Descriptive
特性的对象都可以作为这个函数的参数，这个函数没必要了解传入对象有没有其他属性或方法，只需要了解它一定有
Descriptive
特性规范的方法就可以了。当然，此函数内也无法使用其他的属性与方法。</p>
<p>特性参数还可以用这种等效语法实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">output</span>&lt;T:Descriptive&gt;(object: T){</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>,object.<span class="title function_ invoke__">describe</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这是一种风格类似泛型的语法糖，这种语法糖在有多个参数类型均是特性的情况下十分实用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">output_two</span>&lt;T:Descriptive&gt;(arg1: T, arg2: T){</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, arg1.<span class="title function_ invoke__">describe</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, arg2.<span class="title function_ invoke__">describe</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>特性作类型表示时如果涉及多个特性，可以用 <strong>+</strong>
符号表示，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>+Display)</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T:Summary+Display&gt;(item: T)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 仅用于表示类型的时候，并不意味着可以在 impl
块中使用。</p>
<p>复杂的实现关系可以使用 where 关键字简化，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn some_function&lt;T:Display+Clone, U:Clone+Debug&gt;(t: T, u: U)</span><br></pre></td></tr></table></figure>
<p>可以简化成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: T, u: U)<span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T:Display+<span class="built_in">Clone</span>,</span><br><span class="line">          U:<span class="built_in">Clone</span>+<span class="built_in">Debug</span></span><br></pre></td></tr></table></figure>
<p>在了解这个语法之后，泛型章节中的"取最大值"案例就可以真正实现了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Comparable</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compare</span>(&amp;<span class="keyword">self</span>, object: &amp;<span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="type">i8</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">max</span>&lt;T: Comparable&gt;(array: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">max_index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; array.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        <span class="keyword">if</span> array[i].<span class="title function_ invoke__">compare</span>(&amp;array[max_index]) &gt; <span class="number">0</span> {</span><br><span class="line">            max_index = i;</span><br><span class="line">        }</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    &amp;array[max_index]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Comparable</span> <span class="keyword">for</span> <span class="title class_">f64</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">compare</span>(&amp;<span class="keyword">self</span>, object: &amp;<span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">i8</span> {</span><br><span class="line">        <span class="keyword">if</span> &amp;<span class="keyword">self</span> &gt; &amp;object { <span class="number">1</span> }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> &amp;<span class="keyword">self</span> == &amp;object { <span class="number">0</span> }</span><br><span class="line">        <span class="keyword">else</span> { -<span class="number">1</span> }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"maximum of arr is {}"</span>, <span class="title function_ invoke__">max</span>(&amp;arr));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maximum of arr is5</span><br></pre></td></tr></table></figure>
<p><strong>Tip:</strong> 由于需要声明 compare
函数的第二参数必须与实现该特性的类型相同，所以 Self
（注意大小写）关键字就代表了当前类型（不是实例）本身。</p>
<h5 id="特性做返回值">特性做返回值</h5>
<p>特性做返回值格式如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">person</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Descriptive</span> {</span><br><span class="line">    Person {</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Cali"</span>),</span><br><span class="line">        age: <span class="number">24</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>但是有一点，特性做返回值只接受实现了该特性的对象做返回值且在同一个函数中所有可能的返回值类型必须完全一样。比如结构体
A 与结构体 B 都实现了特性 Trait，下面这个函数就是错误的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>(<span class="type">bool</span> bl) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Descriptive</span> {</span><br><span class="line">    <span class="keyword">if</span> bl {</span><br><span class="line">        <span class="keyword">return</span> A {};</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> B {};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="有条件实现方法">有条件实现方法</h5>
<p>impl
功能十分强大，我们可以用它实现类的方法。但对于泛型类来说，有时我们需要区分一下它所属的泛型已经实现的方法来决定它接下来该实现的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;T&gt; {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: B + C&gt; A&lt;T&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">d</span>(&amp;<span class="keyword">self</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段代码声明了 A <code>&lt;T&gt;</code> 类型必须在 T 已经实现 B 和 C
特性的前提下才能有效实现此 impl 块。</p>
<h4 id="rust-生命周期">Rust 生命周期</h4>
<p>Rust 生命周期机制是与所有权机制同等重要的资源管理机制。</p>
<p>之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。</p>
<p>引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算。</p>
<p>但引用往往导致极其复杂的资源管理问题，首先认识一下垂悬引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r: {}"</span>, r);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段代码是不会通过 Rust 编译器的，原因是 r
所引用的值已经在使用之前被释放。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-7.png" alt="alt text">
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<p>上图中的绿色范围 'a 表示 r 的生命周期，蓝色范围 'b 表示 x
的生命周期。很显然，'b 比 'a
小得多，引用必须在值的生命周期以内才有效。</p>
<p>一直以来我们都在结构体中使用 String 而不用
&amp;str，我们用一个案例解释原因：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longer</span>(s1: &amp;<span class="type">str</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> {</span><br><span class="line">    <span class="keyword">if</span> s2.<span class="title function_ invoke__">len</span>() &gt; s1.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        s2</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        s1</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>longer 函数取 s1 和 s2
两个字符串切片中较长的一个返回其引用值。但只这段代码不会通过编译，原因是返回值引用可能会返回过期的引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">"rust"</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"ecmascript"</span>;</span><br><span class="line">        r = <span class="title function_ invoke__">longer</span>(s1, s2);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} is longer"</span>, r);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序中虽然经过了比较，但 r 被使用的时候源值 s1 和 s2
都已经失效了。当然我们可以把 r 的使用移到 s1 和 s2
的生命周期范围以内防止这种错误的发生，但对于函数来说，它并不能知道自己以外的地方是什么情况，它为了保障自己传递出去的值是正常的，必选所有权原则消除一切危险，所以
longer 函数并不能通过编译。</p>
<p>注: &amp;str和String类型的区别如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Hello Rust"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, s.<span class="title function_ invoke__">capacity</span>());    <span class="comment">// prints 12</span></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">"Here I come!"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// prints 24</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"Hello, Rust!"</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, s.<span class="title function_ invoke__">capacity</span>()); <span class="comment">// compile error: no method named `capacity` found for type `&amp;str`</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{}"</span>, s.<span class="title function_ invoke__">len</span>()); <span class="comment">// prints 12</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的a, b
是&amp;str，不是String，&amp;str更像一个固定的数组，String像一个可变的数组。</li>
<li>String保留了一个len()和capacity()，但str只有一个len()。</li>
<li>&amp;str 是 str的一个的borrowed
类型，可以称为一个字符串切片，一个不可变的string。</li>
</ul>
<p>如果只想要一个字符串的只读视图，或者&amp;str作为一个函数的参数，那就首选&amp;str。如果想拥有所有权，想修改字符串那就用String吧。</p>
<h5 id="生命周期注释">生命周期注释</h5>
<p>生命周期注释是描述引用生命周期的办法。</p>
<p>虽然这样并不能够改变引用的生命周期，但可以在合适的地方声明两个引用的生命周期一致。</p>
<p>生命周期注释用单引号开头，跟着一个小写字母单词：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;i32        // 常规引用</span><br><span class="line">&amp;'a i32     // 含有生命周期注释的引用</span><br><span class="line">&amp;'a mut i32 // 可变型含有生命周期注释的引用</span><br></pre></td></tr></table></figure>
<p>让我们用生命周期注释改造 longer 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longer</span>&lt;<span class="symbol">'a</span>&gt;(s1: &amp;<span class="symbol">'a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">'a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">'a</span> <span class="type">str</span> {</span><br><span class="line">    <span class="keyword">if</span> s2.<span class="title function_ invoke__">len</span>() &gt; s1.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        s2</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        s1</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>我们需要用泛型声明来规范生命周期的名称，随后函数返回值的生命周期将与两个参数的生命周期一致，所以在调用时可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">"rust"</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"ecmascript"</span>;</span><br><span class="line">        r = <span class="title function_ invoke__">longer</span>(s1, s2);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{} is longer"</span>, r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上两段程序结合的运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecmascript is longer</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 别忘记了自动类型判断的原则。</p>
<h5 id="结构体中使用字符串切片引用">结构体中使用字符串切片引用</h5>
<p>这是之前留下的疑问，在此解答：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Str</span>&lt;<span class="symbol">'a</span>&gt; {</span><br><span class="line">        content: &amp;<span class="symbol">'a</span> <span class="type">str</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Str {</span><br><span class="line">        content: <span class="string">"string_slice"</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s.content = {}"</span>, s.content);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.content = string_slice</span><br></pre></td></tr></table></figure>
<p>如果对结构体 Str 有方法定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; Str&lt;<span class="symbol">'a</span>&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_content</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> {</span><br><span class="line">        <span class="keyword">self</span>.content</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这里返回值并没有生命周期注释，但是加上也无妨。这是一个历史问题，早期
Rust
不支持生命周期自动判断，所有的生命周期必须严格声明，但主流稳定版本的
Rust 已经支持了这个功能。</p>
<h5 id="静态生命周期">静态生命周期</h5>
<p>生命周期注释有一个特别的：'static
。所有用双引号包括的字符串常量所代表的精确数据类型都是 &amp;'static str
，'static 所表示的生命周期从程序运行开始到程序运行结束。</p>
<h5 id="泛型特性与生命周期协同作战">泛型、特性与生命周期协同作战</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">'a</span>, T&gt;(x: &amp;<span class="symbol">'a</span> <span class="type">str</span>, y: &amp;<span class="symbol">'a</span> <span class="type">str</span>, ann: T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">'a</span> <span class="type">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Announcement! {}"</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        x</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        y</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这段程序出自 Rust
圣经，是一个同时使用了泛型、特性、生命周期机制的程序，不强求，可以体验，毕竟早晚用得到！</p>
<h4 id="rust-面向对象">Rust 面向对象</h4>
<p>面向对象的编程语言通常实现了数据的封装与继承并能基于数据调用方法。</p>
<p>Rust 不是面向对象的编程语言，但这些功能都得以实现。</p>
<h5 id="封装">封装</h5>
<p>封装就是对外显示的策略，在 Rust
中可以通过模块的机制来实现最外层的封装，并且每一个 Rust
文件都可以看作一个模块，模块内的元素可以通过 pub
关键字对外明示。这一点在"组织管理"章节详细叙述过。</p>
<p>"类"往往是面向对象的编程语言中常用到的概念。"类"封装的是数据，是对同一类数据实体以及其处理方法的抽象。在
Rust 中，我们可以使用结构体或枚举类来实现类的功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ClassName</span> {</span><br><span class="line">    <span class="keyword">pub</span> field: Type,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">impl</span> <span class="title class_">ClassName</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">some_method</span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line">        <span class="comment">// 方法函数体</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">EnumName</span> {</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">impl</span> <span class="title class_">EnumName</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">some_method</span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line"></span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>下面建造一个完整的类：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">second.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ClassName</span> {</span><br><span class="line">    field: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ClassName</span> {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> ClassName {</span><br><span class="line">        ClassName {</span><br><span class="line">            field: value</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">public_method</span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"from public method"</span>);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">private_method</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">private_method</span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"from private method"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">main.rs</span><br><span class="line"><span class="keyword">mod</span> second;</span><br><span class="line"><span class="keyword">use</span> second::ClassName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">object</span> = ClassName::<span class="title function_ invoke__">new</span>(<span class="number">1024</span>);</span><br><span class="line">    object.<span class="title function_ invoke__">public_method</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="继承">继承</h5>
<p>几乎其他的面向对象的编程语言都可以实现"继承"，并用"extend"词语来描述这个动作。</p>
<p>继承是多态（Polymorphism）思想的实现，多态指的是编程语言可以处理多种类型数据的代码。在
Rust
中，通过特性（trait）实现多态。有关特性的细节已在"特性"章节给出。但是特性无法实现属性的继承，只能实现类似于"接口"的功能，所以想继承一个类的方法最好在"子类"中定义"父类"的实例。</p>
<p>总结地说，<strong>Rust
没有提供跟继承有关的语法糖，也没有官方的继承手段（完全等同于 Java
中的类的继承），但灵活的语法依然可以实现相关的功能。</strong></p>
<h4 id="rust-宏">Rust 宏</h4>
<p>Rust
宏（Macros）是一种在编译时生成代码的强大工具，它允许你在编写代码时创建自定义语法扩展。</p>
<p>宏（Macro）是一种在代码中进行元编程（Metaprogramming）的技术，它允许在编译时生成代码，宏可以帮助简化代码，提高代码的可读性和可维护性，同时允许开发者在编译时执行一些代码生成的操作。</p>
<p>宏在 Rust 中有两种类型：<strong>声明式宏（Declarative
Macros）</strong>和<strong>过程宏（Procedural Macros）</strong>。</p>
<p>本文主要介绍声明式宏。</p>
<h5 id="宏的定义">宏的定义</h5>
<p>在 Rust 中，使用 <strong>macro_rules!</strong>
关键字来定义声明式宏。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> my_macro {</span><br><span class="line">    <span class="comment">// 模式匹配和展开</span></span><br><span class="line">    ($arg:expr)=&gt;{</span><br><span class="line">        <span class="comment">// 生成的代码</span></span><br><span class="line">        <span class="comment">// 使用 $arg 来代替匹配到的表达式</span></span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>声明式宏使用 <strong>macro_rules!</strong> 关键字进行定义，它们被称为
<strong>"macro_rules"</strong>
宏。这种宏的定义是基于模式匹配的，可以匹配代码的结构并根据匹配的模式生成相应的代码。这样的宏在不引入新的语法结构的情况下，可以用来简化一些通用的代码模式。</p>
<p>下面是一个简单的宏定义的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏的定义</span></span><br><span class="line"><span class="built_in">macro_rules!</span> greet {</span><br><span class="line">    <span class="comment">// 模式匹配</span></span><br><span class="line">    ($name:expr) =&gt; {</span><br><span class="line">        <span class="comment">// 宏的展开</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello, {}!"</span>, $name);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 调用宏</span></span><br><span class="line">    greet!(<span class="string">"World"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<ul>
<li><strong>模式匹配：</strong>
宏通过模式匹配来匹配传递给宏的代码片段，模式是宏规则的左侧部分，用于捕获不同的代码结构。</li>
<li><strong>规则：</strong> 宏规则是一组由 <strong>$</strong>
引导的模式和相应的展开代码，规则由分号分隔。</li>
<li><strong>宏的展开：</strong>
当宏被调用时，匹配的模式将被替换为相应的展开代码，展开代码是宏规则的右侧部分。</li>
</ul>
<h5 id="实例">实例</h5>
<p>下面是一个更复杂的例子，演示了如何使用宏创建一个简单的
<strong>vec!</strong> 宏，以便更方便地创建 Vec：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏的定义</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec {</span><br><span class="line">    <span class="comment">// 基本情况，空的情况</span></span><br><span class="line">    () =&gt; {</span><br><span class="line">        <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    };</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 递归情况，带有元素的情况</span></span><br><span class="line">    ($($element:expr),+ $(,)?) =&gt; {</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.<span class="title function_ invoke__">push</span>($element);</span><br><span class="line">            )+</span><br><span class="line">            temp_vec</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 调用宏</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, my_vec); <span class="comment">// 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">empty_vec</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, empty_vec); <span class="comment">// 输出: []</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<strong>vec!</strong> 宏使用了模式匹配，以及
<strong><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="0.88ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 389 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g></g></g></svg></mjx-container></span>element:expr),+
$(,)?)</strong> 这样的语法来捕获传递给宏的元素，并用它们创建一个
Vec。</p>
<p>注意，$<strong>(,)?)</strong>
用于处理末尾的逗号，使得在不同的使用情境下都能正常工作。</p>
<p><code>($($element:expr),+ $(,)?)</code> 是 Rust
声明宏中用于模式匹配的一部分。它的具体含义如下：</p>
<ul>
<li><code>$($element:expr)</code>：这是一个重复匹配的部分。其中
<code>$element:expr</code> 表示匹配一个表达式，并将其绑定到元变量
<code>$element</code> 上。<code>$()</code>
表示可以匹配零个或多个这样的表达式。</li>
<li><code>,+</code>：表示在匹配了前面的表达式之后，紧接着可以有一个或多个逗号。</li>
<li><code>$(,)?)</code>：这里的 <code>$(,)?</code>
表示可选的单个逗号。其中 <code>?</code>
表示该部分是可选的，即可以有逗号，也可以没有逗号。</li>
</ul>
<p>总的来说，<code>($($element:expr),+ $(,)?)</code>
用于匹配一个或多个表达式，这些表达式之间可以用逗号分隔，并且最后可能有一个可选的逗号。</p>
<h5 id="过程宏procedural-macros">过程宏（Procedural Macros）</h5>
<p>过程宏是一种更为灵活和强大的宏，允许在编译时通过自定义代码生成过程来操作抽象语法树（AST）。过程宏在功能上更接近于函数，但是它们在编写和使用上更加复杂。</p>
<p>过程宏的类型：</p>
<ul>
<li><strong>派生宏（Derive Macros）</strong> ：用于自动实现trait（比如
<code>Copy</code>、<code>Debug</code>）的宏。</li>
<li><strong>属性宏（Attribute Macros）</strong>
：用于在声明上附加额外的元数据，如 <code>#[derive(Debug)]</code>。</li>
</ul>
<p>过程宏的实现通常需要使用 proc_macro 库提供的功能，例如 TokenStream 和
TokenTree，以便更直接地操纵源代码。</p>
<h4 id="rust-智能指针">Rust 智能指针</h4>
<p>智能指针（Smart pointers）是一种在 Rust
中常见的数据结构，它们提供了额外的功能和安全性保证，以帮助管理内存和数据。</p>
<p>在 Rust
中，智能指针是一种封装了对动态分配内存的所有权和生命周期管理的数据类型。</p>
<p>智能指针通常封装了一个原始指针，并提供了一些额外的功能，比如引用计数、所有权转移、生命周期管理等。</p>
<p>在 Rust 中，标准库提供了几种常见的智能指针类型，例如 Box、Rc、Arc 和
RefCell。</p>
<p><strong>智能指针的使用场景:</strong></p>
<ul>
<li>当需要在堆上分配内存时，使用 <code>Box&lt;T&gt;</code>。</li>
<li>当需要多处共享所有权时，使用 <code>Rc&lt;T&gt;</code> 或
<code>Arc&lt;T&gt;</code>。</li>
<li>当需要内部可变性时，使用 <code>RefCell&lt;T&gt;</code>。</li>
<li>当需要线程安全的共享所有权时，使用 <code>Arc&lt;T&gt;</code>。</li>
<li>当需要互斥访问数据时，使用 <code>Mutex&lt;T&gt;</code>。</li>
<li>当需要读取-写入访问数据时，使用 <code>RwLock&lt;T&gt;</code>。</li>
<li>当需要解决循环引用问题时，使用 <code>Weak&lt;T&gt;</code>。</li>
</ul>
<h5 id="box-t-智能指针">Box <code>&lt;T&gt;</code> 智能指针</h5>
<p>Box <code>&lt;T&gt;</code> 是 Rust
中最简单的智能指针之一，它允许在堆上分配一块内存，并将值存储在这个内存中。</p>
<p>由于 Rust 的所有权规则，使用 Box
可以在堆上创建具有已知大小的数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"b = {}"</span>, b);</span><br></pre></td></tr></table></figure>
<h5 id="rc-t-智能指针">Rc <code>&lt;T&gt;</code> 智能指针</h5>
<p>Rc
<code>&lt;T&gt;</code>（引用计数指针）允许多个所有者共享数据，它使用引用计数来跟踪数据的所有者数量，并在所有者数量为零时释放数据。</p>
<p>Rc <code>&lt;T&gt;</code> 适用于单线程环境下的数据共享。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">data_clone</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;data);</span><br></pre></td></tr></table></figure>
<h5 id="arc-t-智能指针">Arc <code>&lt;T&gt;</code> 智能指针</h5>
<p>Arc <code>&lt;T&gt;</code>（原子引用计数指针）与 Rc
<code>&lt;T&gt;</code>
类似，但是可以安全地在多线程环境中共享数据，因为它使用原子操作来更新引用计数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">data_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;data);</span><br></pre></td></tr></table></figure>
<h5 id="refcell-t-智能指针">RefCell <code>&lt;T&gt;</code> 智能指针</h5>
<p>RefCell <code>&lt;T&gt;</code>
允许在运行时检查借用规则，它使用内部可变性来提供了一种安全的内部可变性模式，允许在不可变引用的情况下修改数据。</p>
<p>但是，RefCell <code>&lt;T&gt;</code> 只能用于单线程环境。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">borrowed_data</span> = data.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">*borrowed_data = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h5 id="mutex-t-智能指针">Mutex <code>&lt;T&gt;</code> 智能指针</h5>
<p>Mutex <code>&lt;T&gt;</code>
是一个互斥锁，它保证了在任何时刻只有一个线程可以访问 Mutex
内部的数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>
<h5 id="rwlock-t-智能指针">RwLock <code>&lt;T&gt;</code> 智能指针</h5>
<p>RwLock <code>&lt;T&gt;</code>
是一种读取-写入锁，允许多个读取者同时访问数据，但在写入时是排他的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::RwLock;</span><br><span class="line"></span><br><span class="line">let lock = RwLock::new(5);</span><br><span class="line">let read_guard = lock.read().unwrap();</span><br></pre></td></tr></table></figure>
<h5 id="weak-t-智能指针">Weak <code>&lt;T&gt;</code> 智能指针</h5>
<p>Weak <code>&lt;T&gt;</code> 是 Rc <code>&lt;T&gt;</code>
的非拥有智能指针，它不增加引用计数，用于解决循环引用问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::{Rc, Weak};</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">weak_five</span> = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;five);</span><br></pre></td></tr></table></figure>
<h5 id="智能指针的生命周期管理">智能指针的生命周期管理</h5>
<p>智能指针可以帮助管理数据的生命周期，当智能指针被销毁时，它们会自动释放内存，从而避免了内存泄漏和野指针的问题。</p>
<p>此外，智能指针还允许在创建时指定特定的析构函数，以实现自定义的资源管理。</p>
<h6 id="实例-1">实例</h6>
<p>下面是一个简单的 Rust 智能指针完整实例，该示例使用 Rc
<code>&lt;T&gt;</code>
智能指针实现了一个简单的引用计数功能，并演示了多个所有者共享数据的情况。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入所需的依赖库</span></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体，用于存储数据</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> {</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 创建一个 Rc 智能指针，共享数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Rc::<span class="title function_ invoke__">new</span>(Data { value: <span class="number">5</span> });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆 Rc 智能指针，增加数据的引用计数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_clone1</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_clone2</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数据的值和引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data value: {}"</span>, data.value);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Reference count: {}"</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印克隆后的 Rc 智能指针</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data clone 1: {:?}"</span>, data_clone1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Data clone 2: {:?}"</span>, data_clone2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上代码中，我们首先定义了一个 <code>Data</code>
结构体，用于存储一个整数值。然后在 <code>main</code> 函数中创建了一个
<code>Rc&lt;Data&gt;</code> 智能指针，用于共享数据。接着通过
<code>Rc::clone</code>
方法克隆了两个智能指针，增加了数据的引用计数。最后打印了数据的值、引用计数和克隆后的智能指针。</p>
<p>运行该程序，可以看到输出了数据的值和引用计数，以及克隆后的智能指针。由于
<code>Rc</code>
智能指针使用引用计数来跟踪数据的所有者数量，因此在每次克隆时，数据的引用计数会增加，当所有者数量为零时，数据会被自动释放。</p>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Data value:5</span><br><span class="line">Reference count:3</span><br><span class="line">Data clone 1:Data{ value:5}</span><br><span class="line">Data clone 2:Data{ value:5}</span><br></pre></td></tr></table></figure>
<h5 id="总结">总结</h5>
<p>Rust
的智能指针提供了一种安全和自动化的方式来管理内存和共享所有权。</p>
<p>智能指针是 Rust
中非常重要的一种数据结构，它们提供了一种安全、灵活和方便的内存管理方式，帮助程序员避免了常见的内存安全问题，提高了代码的可靠性和可维护性。</p>
<p>智能指针是 Rust
安全性模型的重要组成部分，允许开发者编写低级代码而不必担心内存安全问题。</p>
<p>通过智能指针，Rust 既保持了 C 语言的控制能力，又避免了其风险。</p>
<h4 id="rust-并发编程">Rust 并发编程</h4>
<p>安全高效的处理并发是 Rust
诞生的目的之一，主要解决的是服务器高负载承受能力。</p>
<p>并发（concurrent）的概念是指程序不同的部分独立执行，这与并行（parallel）的概念容易混淆，并行强调的是"同时执行"。</p>
<p>并发往往会造成并行。</p>
<p>本章讲述与并发相关的编程概念和细节。</p>
<h5 id="线程">线程</h5>
<p>线程（thread）是一个程序中独立运行的一个部分。</p>
<p>线程不同于进程（process）的地方是线程是程序以内的概念，程序往往是在一个进程中执行的。</p>
<p>在有操作系统的环境中进程往往被交替地调度得以执行，线程则在进程以内由程序进行调度。</p>
<p>由于线程并发很有可能出现并行的情况，所以在并行中可能遇到的死锁、延宕错误常出现于含有并发机制的程序。</p>
<p>为了解决这些问题，很多其它语言（如
Java、C#）采用特殊的运行时（runtime）软件来协调资源，但这样无疑极大地降低了程序的执行效率。</p>
<p>C/C++
语言在操作系统的最底层也支持多线程，且语言本身以及其编译器不具备侦察和避免并行错误的能力，这对于开发者来说压力很大，开发者需要花费大量的精力避免发生错误。</p>
<p>Rust 不依靠运行时环境，这一点像 C/C++ 一样。</p>
<p>但 Rust
在语言本身就设计了包括所有权机制在内的手段来尽可能地把最常见的错误消灭在编译阶段，这一点其他语言不具备。</p>
<p>但这不意味着我们编程的时候可以不小心，迄今为止由于并发造成的问题还没有在公共范围内得到完全解决，仍有可能出现错误，并发编程时要尽量小心！</p>
<p>Rust 中通过 std::thread::spawn 函数创建新线程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">spawn_function</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"spawned thread print {}"</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(spawn_function);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"main thread print {}"</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread print0</span><br><span class="line">spawned thread print0</span><br><span class="line">main thread print1</span><br><span class="line">spawned thread print1</span><br><span class="line">main thread print2</span><br><span class="line">spawned thread print2</span><br></pre></td></tr></table></figure>
<p>这个结果在某些情况下顺序有可能变化，但总体上是这样打印出来的。</p>
<p>此程序有一个子线程，目的是打印 5
行文字，主线程打印三行文字，但很显然随着主线程的结束，spawn
线程也随之结束了，并没有完成所有打印。</p>
<p>std::thread::spawn
函数的参数是一个无参函数，但上述写法不是推荐的写法，我们可以使用闭包（closures）来传递函数作为参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| {</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"spawned thread print {}"</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"main thread print {}"</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>闭包是可以保存进变量或作为参数传递给其他函数的匿名函数。闭包相当于
Rust 中的 Lambda 表达式，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|参数1,参数2,...|-&gt;返回值类型{</span><br><span class="line">    // 函数体</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inc</span> = |num: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        num + <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"inc(5) = {}"</span>, <span class="title function_ invoke__">inc</span>(<span class="number">5</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc(5)=6</span><br></pre></td></tr></table></figure>
<p>闭包可以省略类型声明使用 Rust 自动类型判断机制：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inc</span> = |num| {</span><br><span class="line">        num + <span class="number">1</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"inc(5) = {}"</span>, <span class="title function_ invoke__">inc</span>(<span class="number">5</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>结果没有变化。</p>
<h5 id="join-方法">join 方法</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| {</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"spawned thread print {}"</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"main thread print {}"</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main thread print0 </span><br><span class="line">spawned thread print0 </span><br><span class="line">spawned thread print1 </span><br><span class="line">main thread print1 </span><br><span class="line">spawned thread print2 </span><br><span class="line">main thread print2 </span><br><span class="line">spawned thread print3 </span><br><span class="line">spawned thread print4</span><br></pre></td></tr></table></figure>
<p>join 方法可以使子线程运行结束后再停止运行程序。</p>
<h5 id="move-强制所有权迁移">move 强制所有权迁移</h5>
<p>这是一个经常遇到的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"hello"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在子线程中尝试使用当前函数的资源，这一定是错误的！因为所有权机制禁止这种危险情况的产生，它将破坏所有权机制销毁资源的一定性。我们可以使用闭包的
move 关键字来处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="消息传递">消息传递</h5>
<p>Rust
中一个实现消息传递并发的主要工具是通道（channel），通道有两部分组成，一个发送者（transmitter）和一个接收者（receiver）。</p>
<p>std::sync::mpsc 包含了消息传递的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hi"</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: {}"</span>, received);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br></pre></td></tr></table></figure>
<p>子线程获得了主线程的发送者 tx，并调用了它的 send
方法发送了一个字符串，然后主线程就通过对应的接收者 rx 接收到了。</p>
<h4 id="rust-异步编程-asyncawait">Rust 异步编程 async/await</h4>
<p>在现代编程中，异步编程变得越来越重要，因为它允许程序在等待 I/O
操作（如文件读写、网络通信等）时不被阻塞，从而提高性能和响应性。</p>
<p>异步编程是一种在 Rust 中处理非阻塞操作的方式，允许程序在执行长时间的
I/O 操作时不被阻塞，而是在等待的同时可以执行其他任务。</p>
<p>Rust 提供了多种工具和库来实现异步编程，包括 <strong>async</strong> 和
<strong>await</strong> 关键字、<strong>futures</strong> 和异步运行时（如
tokio、async-std 等），以及其他辅助工具。</p>
<ul>
<li><strong>Future</strong> ：Future 是 Rust
中表示异步操作的抽象。它是一个可能还没有完成的计算，将来某个时刻会返回一个值或一个错误。</li>
<li><strong>async/await</strong> ：<code>async</code>
关键字用于定义一个异步函数，它返回一个 Future。<code>await</code>
关键字用于暂停当前 Future 的执行，直到它完成。</li>
</ul>
<h5 id="实例-2">实例</h5>
<p>以下实例展示了如何使用 async 和 await
关键字编写一个异步函数，以及如何在异步函数中执行异步任务并等待其完成。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入所需的依赖库</span></span><br><span class="line"><span class="keyword">use</span> tokio;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数，模拟异步任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_task</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">    <span class="comment">// 模拟异步操作，等待 1 秒钟</span></span><br><span class="line">    tokio::time::<span class="title function_ invoke__">delay_for</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="number">42</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务执行函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">execute_async_task</span>() {</span><br><span class="line">    <span class="comment">// 调用异步任务，并等待其完成</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">async_task</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Async task result: {}"</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Start executing async task..."</span>);</span><br><span class="line">    <span class="comment">// 调用异步任务执行函数，并等待其完成</span></span><br><span class="line">    <span class="title function_ invoke__">execute_async_task</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Async task completed!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上代码中，我们首先定义了一个异步函数
<code>async_task()</code>，该函数模拟了一个异步操作，使用
<code>tokio::time::delay_for()</code> 方法来等待 1 秒钟，然后返回结果
42。接着定义了一个异步任务执行函数
<code>execute_async_task()</code>，在其中调用了异步函数，并使用
<code>await</code> 关键字等待异步任务的完成。最后在 <code>main</code>
函数中使用 <code>tokio::main</code>
宏来运行异步任务执行函数，并等待其完成。</p>
<p>运行该程序，可以看到程序输出了开始执行异步任务的提示，然后等待了 1
秒钟后输出了异步任务的结果，并最终输出了异步任务完成的提示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start executing async task...</span><br><span class="line">Async task result:42</span><br><span class="line">Async task completed!</span><br></pre></td></tr></table></figure>
<p>这个例子演示了 Rust 中使用 <code>async</code> 和 <code>await</code>
关键字编写异步函数，以及如何在异步函数中执行异步任务并等待其完成。</p>
<p>以下实例使用 tokio 库执行异步 HTTP 请求，并输出响应结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入所需的依赖库</span></span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> tokio::runtime::Runtime;</span><br><span class="line"><span class="keyword">use</span> reqwest::get;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数，用于执行 HTTP GET 请求并返回响应结果</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fetch_url</span>(url: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; {</span><br><span class="line">    <span class="comment">// 使用 reqwest 发起异步 HTTP GET 请求</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">get</span>(url).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = response.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(body)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务执行函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">execute_async_task</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; {</span><br><span class="line">    <span class="comment">// 发起异步 HTTP 请求</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">"https://jsonplaceholder.typicode.com/posts/1"</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">fetch_url</span>(url).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="comment">// 输出响应结果</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Response: {}"</span>, result);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 创建异步运行时</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rt</span> = Runtime::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 在异步运行时中执行异步任务</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = rt.<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">execute_async_task</span>());</span><br><span class="line">    <span class="comment">// 处理异步任务执行结果</span></span><br><span class="line">    <span class="keyword">match</span> result {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">"Async task executed successfully!"</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">"Error: {}"</span>, e),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上代码中，我们首先引入了 tokio 和 reqwest
库，分别用于执行异步任务和进行 HTTP 请求。然后定义了一个异步函数
fetch_url，用于执行异步的 HTTP GET 请求，并返回响应结果。</p>
<p>接着定义了一个异步任务执行函数
execute_async_task，该函数在其中发起了异步 HTTP
请求，并输出响应结果。</p>
<p>最后，在 main 函数中创建了一个 tokio
异步运行时，并在其中执行了异步任务，处理了异步任务的执行结果。</p>
<p>运行该程序，可以看到输出了异步 HTTP 请求的响应结果，实例中请求了
JSONPlaceholder 的一个帖子数据，并打印了其内容。</p>
<h5 id="异步编程说明">异步编程说明</h5>
<h6 id="async-关键字">async 关键字</h6>
<p>async 关键字用于定义异步函数，即返回 Future 或 impl Future
类型的函数。异步函数执行时会返回一个未完成的 Future
对象，它表示一个尚未完成的计算或操作。</p>
<p>异步函数可以包含 await 表达式，用于等待其他异步操作的完成。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">hello</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="string">"Hello, world!"</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="await-关键字">await 关键字</h6>
<p>await 关键字用于等待异步操作的完成，并获取其结果。</p>
<p>await
表达式只能在异步函数或异步块中使用，它会暂停当前的异步函数执行，等待被等待的
Future 完成，然后继续执行后续的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">print_hello</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">hello</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, result);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="异步函数返回值">异步函数返回值</h6>
<p>异步函数的返回值类型通常是
<code>impl Future&lt;Output = T&gt;</code>，其中 <code>T</code>
是异步操作的结果类型。由于异步函数的返回值是一个 Future，因此可以使用
<code>.await</code> 来等待异步操作的完成，并获取其结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    a + b</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="异步块">异步块</h6>
<p>除了定义异步函数外，Rust
还提供了异步块的语法，可以在同步代码中使用异步操作。异步块由
<code>async { }</code> 构成，其中可以包含异步函数调用和
<code>await</code> 表达式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result1</span> = <span class="title function_ invoke__">hello</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result2</span> = <span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: {}, {}"</span>, result1, result2);</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h6 id="异步任务执行">异步任务执行</h6>
<p>在 Rust 中，异步任务通常需要在执行上下文中运行，可以使用
<code>tokio::main</code>、<code>async-std</code> 的
<code>task::block_on</code> 或 <code>futures::executor::block_on</code>
等函数来执行异步任务。这些函数会接受一个异步函数或异步块，并在当前线程或执行环境中执行它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    task::<span class="title function_ invoke__">block_on</span>(<span class="title function_ invoke__">print_hello</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="错误处理">错误处理</h6>
<p><code>await</code> 后面跟一个 <code>?</code> 操作符可以传播错误。如果
<code>await</code> 的 Future
完成时返回了一个错误，那么这个错误会被传播到调用者。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">my_async_function</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; {</span><br><span class="line">    <span class="title function_ invoke__">some_async_operation</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="comment">// 如果 some_async_operation 出错，错误会被传播</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="异步-trait-方法">异步 trait 方法</h6>
<p>Rust 允许为 trait
定义异步方法。这使得你可以为不同类型的对象定义异步操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyAsyncTrait</span> {</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt;;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyAsyncTrait</span> <span class="keyword">for</span> <span class="title class_">MyType</span> {</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; {</span><br><span class="line">        <span class="comment">// 异步逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="异步上下文">异步上下文</h6>
<p>在 Rust 中，异步代码通常在异步运行时（如 Tokio 或
async-std）中执行。这些运行时提供了调度和执行异步任务的机制。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">some_async_operation</span>().<span class="keyword">await</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>以上代码中，<strong>#[tokio::main]</strong> 属性宏将
<strong>main</strong> 函数包装在一个异步运行时中。</p>
<h6 id="异步宏">异步宏</h6>
<p>Rust 提供了一些异步宏，如
<strong>tokio::spawn</strong>，用于在异步运行时中启动新的异步任务。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> {</span><br><span class="line">        <span class="comment">// 异步逻辑</span></span><br><span class="line">    });</span><br><span class="line">    handle.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="异步-io">异步 I/O</h6>
<p>Rust 的标准库提供了异步 I/O 操作，如 <strong>tokio::fs::File</strong>
和 <strong>async_std::fs::File</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::fs::File;</span><br><span class="line"><span class="keyword">use</span> tokio::io::{<span class="keyword">self</span>, AsyncReadExt};</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"file.txt"</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Contents: {}"</span>, contents);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h6 id="异步通道">异步通道</h6>
<p>Rust 的一些异步运行时提供了异步通道（如
tokio::sync::mpsc），允许在异步任务之间传递消息</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> tokio::spawn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = mpsc::<span class="title function_ invoke__">channel</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">child</span> = <span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">response</span> = <span class="string">"Hello, world!"</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(response).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Received: {}"</span>, response);</span><br><span class="line"></span><br><span class="line">    child.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="vscode-中tasks.json和launch.json的作用是什么">.vscode
中tasks.json和launch.json的作用是什么?</h2>
<p>在 <code>.vscode</code> 文件夹中：</p>
<p><strong><code>tasks.json</code> 的作用</strong>：</p>
<p><code>tasks.json</code> 用于定义在 Visual Studio Code
中可以执行的任务。这些任务可以是编译代码、运行测试、执行脚本等各种自定义的操作。</p>
<p>例如，如果您正在开发一个使用特定编程语言的项目，您可以配置一个编译任务，指定编译器的命令和参数，以便在
VS Code 中轻松地编译您的代码。</p>
<p>再比如，您可能有一个需要在特定目录下运行的脚本，也可以在
<code>tasks.json</code> 中定义这个任务。</p>
<p><strong><code>launch.json</code> 的作用</strong>：</p>
<p><code>launch.json</code> 主要用于配置调试（Debug）相关的设置。</p>
<p>它允许您定义如何启动和调试您的应用程序或脚本。您可以指定调试的类型（例如
Node.js、Python、Java 等）、启动的文件、传递的参数、环境变量等。</p>
<p>例如，如果您正在开发一个 Node.js 应用程序，您可以在
<code>launch.json</code>
中配置如何启动服务器，并在调试过程中设置断点、查看变量值等。</p>
<p>以下是一个简单的示例：</p>
<p>在 <code>tasks.json</code> 中定义一个简单的 JavaScript 编译任务：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"2.0.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"tasks"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"Compile JavaScript"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"shell"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"command"</span><span class="punctuation">:</span> <span class="string">"babel src -d dist"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>在 <code>launch.json</code> 中定义一个 Node.js 调试配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0.2.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"configurations"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Launch Node.js"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"node"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"request"</span><span class="punctuation">:</span> <span class="string">"launch"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"program"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}/app.js"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"stopOnEntry"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"cwd"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"preLaunchTask"</span><span class="punctuation">:</span> <span class="string">"Compile JavaScript"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>preLaunchTask</code> 字段指定在调试之前先执行
<code>Compile JavaScript</code> 这个任务。</p>
<h2 id="bpfcc在5.10内核上不可用解决">bpfcc在5.10内核上不可用解决:</h2>
<p>需要重新编译bcc，参考这个文档
https://github.com/realwujing/ebpf-learning/blob/1d4dc60cef79a16354520fbda4f44b7013275e47/BCC.md</p>
<p>1）安装依赖 sudo apt-get -y install bison build-essential cmake flex
git libedit-dev llvm-13-dev libclang-13-dev python zlib1g-dev libelf-dev
libfl-dev python3-distutils</p>
<p>依赖里面 llvm-13-dev libclang-13-dev
没有，可以添加debian源，然后再下。 添加debian源方法： cat
/etc/debian_version 确定debian版本，10对应buster，百度搜索debian 清华源
，选择buster</p>
<p>2）下载代码： git clone https://github.com/iovisor/bcc.git git
checkout -b v0.6.1 3）编译： 在执行git clone的目录写一个脚本 #!/bin/bash
set -ex mkdir bcc/build cd bcc/build cmake .. make sudo make install
cmake -DPYTHON_CMD=python3 .. # build python3 binding pushd src/python/
make sudo make install popd 然后执行 4）设置环境变量 需要先sudo -i echo
"export PATH=$PATH:/usr/share/bcc/tools" &gt;&gt; /etc/profile sudo
visudo后追加/usr/share/bcc/tools到secure_path后面 source
/etc/profile</p>
<p>5）修改python默认指向python3 sudo update-alternatives --install
/usr/bin/python python /usr/bin/python2 100 sudo update-alternatives
--install /usr/bin/python python /usr/bin/python3 150 sudo
update-alternatives --config python</p>
<p>编译出来的程序是trace； 直接 sudo trace运行，有时候需要重启</p>
<h2 id="curl">curl</h2>
<p><code>curl</code> 是一个用于通过各种网络协议（如 HTTP、FTP
等）获取数据的工具</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1723693919066.png" alt="1723693919066">
<figcaption aria-hidden="true">1723693919066</figcaption>
</figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://example.com/file.txt #-O 选项表示使用服务器上的文件名来保存下载的文件</span><br><span class="line">curl -o custom_name.txt https://example.com/file.txt #-o 选项指定自定义的文件名来保存下载的文件</span><br><span class="line">curl --proxy 127.0.0.1:7890 www.google.com</span><br><span class="line">curl -s https://install.zerotier.com/ | sudo bash #curl读取并执行脚本。-s, --silent               Silent mode</span><br><span class="line">curl -sfL https://get.k3s.io | sh - #-s 表示静默模式，不显示进度或错误信息（除非是严重错误）。-f 表示如果服务器返回错误，curl 直接报错退出。-L 表示如果服务器返回的是重定向的响应，curl 会跟随重定向。</span><br></pre></td></tr></table></figure>
<h2 id="内核编译">内核编译：</h2>
<p>284 ls arch/ 285 ls arch/arm64/configs/ 286 make
merge_kirin990_armpc_defconfig 287 sudo apt install bison 288 make
merge_kirin990_armpc_defconfig 289 sudo apt install flex 290 make
merge_kirin990_armpc_defconfig 291 make menuconfig 292 lscpu 294 make
bindeb-pkg -j10 编出来后安装linux-headerXXX.deb linux-image-xxx.deb</p>
<p>sudo apt install bison flex cp /boot/config-4.19.0-amd64-desktop
arch/x86/configs/icbc_x86_defconfig make icbc_x86_defconfig make
menuconfig 不需要 lscpu vim scripts/package/Makefile
注释掉deepin-apigail-generate的2行</p>
<p>查看回调函数具体调用的函数名
在Linux内核代码里面，很多结构体里面都有一些函数指针。在调试过程中，经常不知道该指针具体调用的是哪一个函数，那么有下面两种方法可以进行查看：
方法一：打印堆栈信息
在使用函数指针的后面，调用dump_stack()函数。这个函数会把堆栈信息打印出来，通过堆栈信息，就可以知道函数指针具体调用的是哪一个函数。
方法二：使用lookup_symbol_name函数 函数原型：int
lookup_symbol_name(unsigned long addr, char *symname) 说明：
addr参数-传入函数指针的值 symname参数-保存函数名字的首地址
注：要使用lookup_symbol_name函数，需要包含#include
&lt;linux/kallsyms.h&gt;头文件 Oops: 0002 [#1] SMP 0002这个是 OOPS
信息的错误码</p>
<p>bit 0 0 means no page found, 1 means a protection fault bit 1 0 means
read, 1 means write bit 2 0 means kernel, 1 means user-mode 位0 0
表示找不到页面，1表示保护故障 bit 1 0表示已读，1表示已写 位2 0
表示内核，1表示用户模式</p>
<p>[#1] — this value is the number of times the Oops occurred. Multiple
Oops can be triggered as a cascading effect of the first one. 这个值是
Oops 发生的次数, 多个 Oops 可以级联效应触发</p>
<p>CPU: 0 PID: 1313 Comm: kworker/u4:0 Tainted: G D 3.14.52-1.1.1_ga #40
表示发生在CPU 0，当前运行的进程是1313 进程是kworker/u4:0
Tainted标识为：G 内核版本：3.14.52-1.1.1_ga 操作系统#40 ————————————————
版权声明：本文为CSDN博主「monkey_lqd」的原创文章，遵循CC 4.0
BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/a3121772305/article/details/116885768</p>
<p>内核中函数指针用的很多，在debug
的时候能直接打印出一个函数指针对应的函数就会很方便。</p>
<p>打印裸指针(raw pointer)用
%p,%p除了可以用来打印指针外还可以打印其它的信息</p>
<p>%pF可打印函数指针的函数名和偏移地址，%pf只打印函数指针的函数名，不打印偏移地址。</p>
<p>如</p>
<p>printk("%pf %pF", ptr, ptr) will print:</p>
<p>module_start module_start+0x0/0x62 [hello]</p>
<p>但是为了支持这个功能你需要开启CONFIG_KALLSYMS 选项</p>
<p>打印函数栈 用户态 打印函数栈
使用backtrace()相关函数来达到输出函数栈的目的，man
backtrace查看详细的参数，返回值等信息 简单说下这3个函数的用法：</p>
<p>int backtrace(void **buffer, int size);
backtrace()把函数栈中的函数地址写到buffer数组，buffer数组的成员即void
*类型。size表示把栈顶size个函数地址搞出来，如果想把函数栈完全搞出来，确保buffer数组和size足够大。</p>
<p>char <strong>backtrace_symbols(void <em>const </em>buffer, int size);
void backtrace_symbols_fd(void <em>const </em>buffer, int size, int fd);
backtrace_symbols()或者backtrace_symbols_fd()与上边的backtrace()配合使用，起一个翻译作用，即把函数地址翻译为函数名（还有函数的偏移和返回地址）。backtrace_symbols()把buffer数组中的size个元素翻译为函数名，把字符串数组保存在返回值char
</strong>中，自带了malloc功能，用完需把返回值free，见测试例。backtrace_symbols_fd()前两个参数和前者一样，但是把结果字符串数组输出到fd中，如fd=1，即输出到屏幕
由函数指针得到函数名
根据以上可以看出，backtrace_symbols和backtrace_symbols_fd可以用来将函数指针转换为函数名
内核态 打印函数栈
使用dump_stack()函数。直接在需要查看函数栈的位置加入这一句，然后dmesg中就可以看到函数栈了。</p>
<p>查找分区的uuid grub-probe -t fs_uuid /boot</p>
<p>bash :local a=0 声明一个局部变量 判断一个命令是否存在：if ! command
-v fsck &gt;/dev/null 2&gt;&amp;1;then 将命令结果保存到指定目录logsave
-a -s <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="28.452ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 12576 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mi" transform="translate(681,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="msub" transform="translate(1444,0)"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"/></g><g data-mml-node="mi" transform="translate(819,-150) scale(0.707)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g></g><g data-mml-node="mi" transform="translate(2842.6,0)"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"/></g><g data-mml-node="mi" transform="translate(3346.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/></g><g data-mml-node="mi" transform="translate(4027.6,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></g><g data-mml-node="mi" transform="translate(4791.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(5341.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(5810.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(6243.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(6986.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(7987.1,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(8738.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(9738.5,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(10664.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(11665,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(12026,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g></g></g></svg></mjx-container></span>root_fstype" "<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.636ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6469 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mi" transform="translate(1522,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mi" transform="translate(2285,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2989,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g><g data-mml-node="mi" transform="translate(3539,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3884,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(4434,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(4712,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(5490,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5919,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g></g></g></svg></mjx-container></span>ROOT" ]; then
$?用于查找最后执行的命令的返回值</p>
<p>$$ Shell本身的PID（ProcessID） <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="36.579ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 16168 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(923,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mi" transform="translate(1499,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(1965,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2263,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(2561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">最</text></g><g data-mml-node="mi" transform="translate(3561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">后</text></g><g data-mml-node="mi" transform="translate(4561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(5561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(6561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(7561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">后</text></g><g data-mml-node="mi" transform="translate(8561,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">台</text></g><g data-mml-node="mi" transform="translate(9561,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(10312,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(10763,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(11248,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(11681,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(12147,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(12616,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(13085,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(14085,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(14836,0)"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"/></g><g data-mml-node="mi" transform="translate(15340,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"/></g></g></g></svg></mjx-container></span>?
最后运行的命令的结束代码（返回值） <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="30.097ex" height="2.161ex" role="img" focusable="false" viewbox="0 -750 13303 955"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">使</text></g><g data-mml-node="mi" transform="translate(1778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mi" transform="translate(2778,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(3423,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(3889,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(4250,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">命</text></g><g data-mml-node="mi" transform="translate(5250,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">令</text></g><g data-mml-node="mi" transform="translate(6250,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">设</text></g><g data-mml-node="mi" transform="translate(7250,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">定</text></g><g data-mml-node="mi" transform="translate(8250,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(9250,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/></g><g data-mml-node="mi" transform="translate(9999,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(10297,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(10826,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(11303,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(12303,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">览</text></g></g></g></svg></mjx-container></span><em>
所有参数列表。如"$</em>"用「"」括起来的情况、以"<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>2 … <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="25.226ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 11150 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(600,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g><g data-mml-node="mi" transform="translate(1150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(2150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">形</text></g><g data-mml-node="mi" transform="translate(3150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">式</text></g><g data-mml-node="mi" transform="translate(4150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">输</text></g><g data-mml-node="mi" transform="translate(5150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mi" transform="translate(6150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">所</text></g><g data-mml-node="mi" transform="translate(7150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">有</text></g><g data-mml-node="mi" transform="translate(8150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">参</text></g><g data-mml-node="mi" transform="translate(9150,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(10150,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g></g></g></svg></mjx-container></span>@
所有参数列表。如"<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="30.38ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 13428 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="40" d="M56 347Q56 429 86 498T164 612T270 680T386 705Q522 705 622 603T722 349Q722 126 608 126Q541 126 513 176Q512 177 512 179T510 182L509 183Q508 183 503 177T487 163T464 146T429 132T385 126Q311 126 251 186T190 347Q190 448 251 508T385 568Q426 568 460 548T509 511T531 479H555Q580 479 582 478Q586 477 587 468Q588 454 588 338V260Q588 200 593 182T619 163Q641 163 655 178T674 223T680 273T682 325V330Q682 426 647 500Q611 569 544 618T388 668Q271 668 184 577T96 347Q96 216 180 121T396 26Q421 26 446 28T493 34T535 43T573 52T605 63T629 72T647 80T657 84H716Q722 78 722 74Q722 65 675 45T547 7T392 -11Q255 -11 156 90T56 347ZM274 347Q274 266 308 214T390 162Q420 162 449 182T498 235L504 245V449L498 459Q453 532 387 532Q347 532 311 483T274 347Z"/></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(778,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g><g data-mml-node="mi" transform="translate(1328,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2328,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">「</text></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3328,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3878,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">」</text></g></g><g data-mml-node="mi" transform="translate(4878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">括</text></g><g data-mml-node="mi" transform="translate(5878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">起</text></g><g data-mml-node="mi" transform="translate(6878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">来</text></g><g data-mml-node="mi" transform="translate(7878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(8878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">情</text></g><g data-mml-node="mi" transform="translate(9878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">况</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(10878,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mi" transform="translate(11878,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">以</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(12878,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g></g></g></svg></mjx-container>1" "<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="6.649ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 2938.7 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1216.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2388.7,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g></g></g></svg></mjx-container></span>n" 的形式输出所有参数。
<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="28.959ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 12800 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="You can't use 'macro parameter character #' in math mode" title="You can't use 'macro parameter character #' in math mode"><rect data-background="true" width="12800" height="950" y="-200"/><title>You can't use 'macro parameter character #' in math mode</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px"># 添加到Shell的参数个数 </text></g></g></g></g></svg></mjx-container>0 Shell本身的文件名 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="3.394ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 1500 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">～</text></g></g></g></svg></mjx-container></span>n
添加到Shell的各参数值。<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="13.575ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 6000 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">是</text></g><g data-mml-node="mi" transform="translate(1500,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">第</text></g><g data-mml-node="mn" transform="translate(2500,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">参</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5000,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g></g></g></svg></mjx-container>2是第2参数…。</p>
<p>获取当前终端 read -r console rest &lt;/proc/consoles
if [ "<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="172.398ex" height="2.149ex" role="img" focusable="false" viewbox="0 -750 76200 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="You can't use 'macro parameter character #' in math mode" title="You can't use 'macro parameter character #' in math mode"><rect data-background="true" width="76200" height="950" y="-200"/><title>You can't use 'macro parameter character #' in math mode</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">{console}" = "tty0" ]; then     # Need to choose a specific VT     console="tty1" fi 获取所有sh(应该也可以用其他程序）的pid集合 pids=</text></g></g></g></g></svg></mjx-container>(pidof sh)
获取当前pid
self_pid=
$$

如何判断是否在real environment还是在initramfs中：看看dde-dock存不存在

## vscode快捷键

### 展开和折叠代码

#### macOS

在 macOS 上，你可以使用以下快捷键来折叠和展开代码：

* **折叠当前级别** ：`Command` + `Option` + `[`
* **展开当前级别** ：`Command` + `Option` + `]`
* **折叠所有代码** ：`Command` + `K` 然后 `Command` + `0`
* **展开所有代码** ：`Command` + `K` 然后 `Command` + `J`

#### Windows

在 Windows 上，你可以使用以下快捷键来折叠和展开代码：

**折叠当前级别** ：`Ctrl` + `Shift` + `[`

**展开当前级别** ：`Ctrl` + `Shift` + `]`

**折叠所有代码** ：`Ctrl` + `K` 然后 `Ctrl` + `0`

**展开所有代码** ：`Ctrl` + `K` 然后 `Ctrl` + `J`

### 打开命令窗口

F1或者command + shift + p

![1721828678402](命令/1721828678402.png)

### 切换页面

`ctrl+1~9`

### 在 Mac 终端中通过输入 `code.`来打开 VS Code

要在 Mac 终端中通过输入 `code.`来打开 VS Code，可以按照以下步骤进行设置：

方法一：

1. 打开 VS Code。
2. 使用快捷键 `command + shift + p`打开命令窗口。
3. 在命令窗口中输入 `shell command`，找到并点击提示中的 `shell command: install ‘code’ command in path`，运行该命令。

这种方法简单快捷，但设置的命令在电脑重启后可能会失效。

## chrome快捷键

### 切换页面

`cmd+1~9`

`ctrl+tab 或ctrl+shift+tab或ctrl+pgup或ctrl+pagedown`

## quake 3算法

计算 `float y = 1 / sqrt (x) ;`

**参考视频:https://www.bilibili.com/video/BV1ym421g7tz/?buvid=Z2448B2CF12E9AC1456080ED1C48B091E8F7&amp;from_spmid=main.my-history.0.0&amp;is_story_h5=false&amp;mid=FPr3cOaw3%2Fuu5BD4j4onuw%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=371B5190-2E4C-4290-A7BB-93C1B390D45B&amp;share_source=COPY&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1721631862&amp;unique_k=lASYA5Q&amp;up_id=1263732318&amp;vd_source=69d49a91e3d96bad6e2f1ea1eb1f6c22**

![1721706464469](命令/1721706464469.png)

**注意这个算法要求number非负数,非0,且取得是近似值**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">Q_rsqrt</span><span class="params">( <span class="type">float</span> number )</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">long</span> i;<span class="comment">//占32位</span></span><br><span class="line">	<span class="type">float</span> ×<span class="number">2</span>, y;<span class="comment">//均占32位</span></span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> threehalfs = <span class="number">1.5F</span>;<span class="comment">//1.5 also 32位</span></span><br><span class="line"></span><br><span class="line">	X2 = number * <span class="number">0.5F</span>;</span><br><span class="line">	y = number;</span><br><span class="line">	i = * ( <span class="type">long</span> * ) &amp;у;<span class="comment">// evil floating point bit hack通过强制类型转换将浮点数 y 的地址当作长整型的地址来获取其底层的位表示</span></span><br><span class="line">	i = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );<span class="comment">// what the fuck?</span></span><br><span class="line">	y = * (<span class="type">float</span> * ) &amp;i;<span class="comment">//又通过强制类型转换将长整型 i 的位表示转换回浮点数赋值给 y</span></span><br><span class="line">	y = y * ( threehalfs - ( x2 * y * y ) );<span class="comment">// 1st iteration</span></span><br><span class="line">	<span class="comment">// y = y * ( threehalfs - ( x2 * y * y ) );// 2nd iteration, can be removed</span></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上面的
<code>i = * ( long * ) &amp;у</code>实际就等于M+2^23*E,其中M和E是y这个浮点数用IEEE754表示法的尾数和指数(实际把32位数写出来再看很好理解)</p>
<p>log2(y)=<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721707887167.png" alt="1721707887167"></p>
<p>至于上面这个公式实际就是计算log2(y)的近似值,推导过程见视频,其中上面的mu是一个0到1的未确定的值,但会使得约等于的两边取得最小的误差</p>
<p>所以经过 <code>i = * ( long * ) &amp;у</code>后,i会约等于log2(y)</p>
<p>而log(1/(y^1/2))=-1/2log2(y)=-(y&gt;&gt;1)</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721717289233.png" alt="1721717289233">
<figcaption aria-hidden="true">1721717289233</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721717410864.png" alt="1721717410864">
<figcaption aria-hidden="true">1721717410864</figcaption>
</figure>
<p><code>y = * (float * ) &amp;i;//又通过强制类型转换将长整型 i 的位表示转换回浮点数赋值给 y</code>这一步就不讲了,跟上面的步骤反过来就是了</p>
<p><code>y = y * ( threehalfs - ( x2 * y * y ) );// 1st iteration</code></p>
<p>经过上面的步骤,我们得到一个不错的近似值,但同时也引入了一些误差项,得益于牛顿迭代法,可以从一个相当不错的近似值出发,得到一个相当精确的近似结果</p>
<p><strong>牛顿迭代法（Newton's Method）</strong></p>
<p>牛顿迭代法是一种用于求解方程根的数值方法。</p>
<p>它的基本思想是通过不断地用切线来逼近函数的根。</p>
<p>假设我们要求解方程 <code>f(x) = 0</code>
的根，首先我们需要选取一个初始的近似值 <code>x0</code> 。</p>
<p>然后，通过以下公式进行迭代计算：</p>
<p><code>x(n + 1) = x(n) - f(x(n)) / f'(x(n))</code></p>
<p>其中 <code>f'(x)</code> 是函数 <code>f(x)</code> 的导数。</p>
<p>每次迭代都会使新的近似值更接近方程的根。</p>
<p>例如，要求解方程 <code>x^2 - 5 = 0</code> ，其导数为 <code>2x</code>
。</p>
<p>假设初始近似值 <code>x0 = 2</code> ，则：</p>
<p>第一次迭代：<code>x1 = 2 - (2^2 - 5) / (2 * 2) = 2.25</code></p>
<p>第二次迭代：<code>x2 = 2.25 - (2.25^2 - 5) / (2 * 2.25) ≈ 2.2361</code></p>
<p>以此类推，不断迭代，逐渐逼近方程的根。</p>
<p>牛顿迭代法的优点是收敛速度较快，但它也有一些局限性。比如，要求函数在根的附近具有较好的性质，且导数的计算要准确和方便。</p>
<p>在实际应用中，牛顿迭代法常用于求解非线性方程、计算函数的零点、优化问题等领域。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721717907153.png" alt="1721717907153">
<figcaption aria-hidden="true">1721717907153</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721718035706.png" alt="1721718035706">
<figcaption aria-hidden="true">1721718035706</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721718082505.png" alt="1721718082505">
<figcaption aria-hidden="true">1721718082505</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721718125314.png" alt="1721718125314">
<figcaption aria-hidden="true">1721718125314</figcaption>
</figure>
<p>对于 <code>y = y * (threehalfs - (x2 * y * y))</code>
这一行，它是牛顿迭代法的应用。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721719272279.png" alt="1721719272279">
<figcaption aria-hidden="true">1721719272279</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721719295174.png" alt="1721719295174">
<figcaption aria-hidden="true">1721719295174</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/1721719321991.png" alt="1721719321991">
<figcaption aria-hidden="true">1721719321991</figcaption>
</figure>
<h2 id="whether-in-the-real-environment">Whether in the real
environment</h2>
<p>real_env=1 if [ -f /bin/dde-dock ]; then real_env=0
LOG_FILE=/tmp/$PROJ.log fi</p>
<p>shell log: log_info() { echo "$*" &gt;&amp;2 echo "TUI: <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex;" xmlns="http://www.w3.org/2000/svg" width="6.524ex" height="1.357ex" role="img" focusable="false" viewbox="0 -560 2883.8 600"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1327.8,0)"><g data-mml-node="text"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g></g></g></g></svg></mjx-container></span>LOG_FILE }</p>
<p>trap用法： trap clean_boot EXIT 起因
项目中的升级脚本可能耗时很长，在这段时间内，脚本没有任何输出的，这带给市场部署人员的感觉就是脚本好像卡住了。通常情况下，部署人员都会直接CTRL+C停掉升级脚本，这会导致升级失败，最终需要开发人员介入去修复环境。</p>
<p>可以通过输出升级进度的方式提示部署人员升级正在进行中，但进度也可能在一段时间不动，而且无法避免意外终止升级的情况，此时可以使用Shell的内建命令trap来忽略SIGINT这些信号，保证升级不会中断。
trap [-lp] [[arg] sigspec ...] arg可以是shell命令或者自定义函数
sigspec可以是以下的一个或多个
定义在&lt;signal.h&gt;中的信号名或者数值。信号名的大小写不敏感，SIG这个前缀也是可选的。以下的命令的效果都是一样的
trap "echo 123" SIGINT trap "echo 123" INT trap "echo 123" 2 trap "echo
123" int trap "echo 123" Int
EXIT：在shell退出前执行trap设置的命令，也可以指定为0
RETURN：在函数返回时，或者.和source执行其他脚本返回时，执行trap设置的命令
DEBUG：在任何命令执行前执行trap设置的命令，但对于函数仅在函数的第一条命令前执行一次</p>
<p>shell中判断语句if中-z 和 -n</p>
<p>[ -a FILE ] 如果 FILE 存在则为真。</p>
<p>[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。</p>
<p>[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。</p>
<p>[ -d FILE ] 如果 FILE 存在且是一个目录则为真。</p>
<p>[ -e FILE ] 如果 FILE 存在则为真。</p>
<p>[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</p>
<p>[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</p>
<p>[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。</p>
<p>[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</p>
<p>[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</p>
<p>[ -r FILE ] 如果 FILE 存在且是可读的则为真。</p>
<p>[ -s FILE ] 如果 FILE 存在且大小不为0则为真。</p>
<p>[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。</p>
<p>[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</p>
<p>[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。</p>
<p>[ -x FILE ] 如果 FILE 存在且是可执行的则为真。</p>
<p>[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。</p>
<p>[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</p>
<p>[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。</p>
<p>[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last
read则为真。</p>
<p>[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。</p>
<p>[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than
FILE2, or 如果 FILE1 exists and FILE2 does not则为真。</p>
<p>[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1
不存在则为真。</p>
<p>[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2
指向相同的设备和节点号则为真。</p>
<p>[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。</p>
<p>[ -z STRING ] “STRING” 的长度为零则为真。</p>
<p>[ -n STRING ] or [ STRING ] “STRING” 的长度为非零
non-zero则为真。</p>
<p>[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of
“==” for strict POSIX compliance则为真。</p>
<p>[ STRING1 != STRING2 ] 如果字符串不相等则为真。</p>
<p>[ STRING1 &lt; STRING2 ] 如果 “STRING1” sorts before “STRING2”
lexicographically in the current locale则为真。</p>
<p>[ STRING1 &gt; STRING2 ] 如果 “STRING1” sorts after “STRING2”
lexicographically in the current locale则为真。</p>
<p>[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These
arithmetic binary operators return true if “ARG1” is equal to, not equal
to, less than, less than or equal to, greater than, or greater than or
equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.</p>
<p>cat /proc/net/netlink| grep sockid 这里面的基本都是内核传的socket
sudo netstat -x | grep sockid sudo netstat -xp| grep proc cat
/proc/net/unix | grep sockid</p>
<p>给u盘改名： sudo mlabel -i /dev/sda ::LL （label是名字）</p>
<pre><code>例子：

sudo mlabel -i /dev/sda ::recovery</code></pre>
<p>格式化U盘：</p>
<p>sudo mkfs.btrfs -f /dev/sdc</p>
<h2 id="下载wpa最上游源码">下载wpa最上游源码：</h2>
<p>git clone git://w1.fi/srv/git/hostap.git</p>
<h2 id="使用wpa开热点">使用wpa开热点：</h2>
<p>ctrl_interface=/var/run/wpa_supplicant update_config=1 ap_scan=2</p>
<p>network={ ssid="A-WPA3-TEST" mode=2 key_mgmt=SAE proto=RSN
pairwise=CCMP psk="12345678" sae_password="12345678" ieee80211w=2 }
wpa_supplicant -Dnl80211 -iwlan0 -c wpa_supplicant.conf</p>
<h2 id="删除已连接的网络-1">删除已连接的网络：</h2>
<p>删除/etc/NetworkManager/system-connections/下，然后重启NetworkManager</p>
<h2 id="vim快捷键">vim快捷键</h2>
<pre><code>这几个常用:

向上翻半页`ctrl+u`</code></pre>
<ul>
<li>向后翻半页：<code>ctrl+d</code></li>
<li>向后翻整页：<code>ctrl+f</code></li>
<li>向前翻整页：<code>ctrl+b</code></li>
</ul>
<p>突出显示字符: set hls</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:set number </span><br><span class="line"># 或者简写为 </span><br><span class="line">:set nu </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 关闭行号显示 </span><br><span class="line">:set nonumber </span><br><span class="line"># 或者简写为 </span><br><span class="line">:set nonu</span><br></pre></td></tr></table></figure>
<h3 id="vim快速跳转">vim快速跳转</h3>
<h2 id="一.按单词跳转可以跨行跳转">一.按单词跳转(可以跨行跳转)</h2>
<p>w &lt;---&gt; b 跳转到下个/上个单词的第一个字符处</p>
<p>e &lt;---&gt; ge 跳转到下个/上个单词的最后一个字符处</p>
<h4 id="二.行内跳转">二.行内跳转</h4>
<p>0 跳转到光标所在行的行首</p>
<p>$ 跳转到光标所在行的行尾</p>
<p>n| 跳转到光标所在行的指定列</p>
<h4 id="三.行内查找并跳转">三.行内查找并跳转</h4>
<p>f
命令移动到光标右边的指定字符上，例如，"fm"，会把移动到光标右边的第一个'm'字符上</p>
<p>F 命令则反方向查找，也就是移动到光标左边的指定字符上</p>
<p>t 命令和”f“命令的区别在于，它移动到光标右边的指定字符之前</p>
<p>T 命令是”t“命令的反向版本，它移动到光标右边的指定字符之后</p>
<p>; 命令重复前一次输入的f, t, F, T命令，</p>
<p>, 命令会反方向重复前一次输入的f, t, F, T命令</p>
<p>可以在这组命令前面使用数字，表示倍数。例如，"6fm"表示移动到光标右边的第6个'm'字符上</p>
<h4 id="四-跳转指定行">四、 跳转指定行</h4>
<p>比如想跳转到文本的第12行，可以执行如下命令：</p>
<p>（1）12gg /
12G(建议使用这种,因为ngg/nG输入以后不需要按下回车键，而输入:n之后还要按下回车键才会跳转)</p>
<p>（2）:12</p>
<p>（3）打开文件时输入vim +12 filename</p>
<p>五、往上或往下跳n行</p>
<p>5k :往上跳 5 行</p>
<p>5j: 往下跳 5 行</p>
<h3 id="vim替换模式">vim替换模式</h3>
<p>使用大写
<code>R</code>命令，将进入替换模式（屏幕底部显示“--REPLACE--”）。此时新输入的文本将直接替代/覆盖已经存在的内容，直至点击ESC键返回常规模式。
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-10.png" alt="alt text"></p>
<p>使用小写
<code>r</code>命令，将进入<strong>单字符替换模式</strong>，此时新输入的字符将替代光标之下的当前字符，然后自动返回到常规模式。</p>
<p>通过在r命令中增加数字前缀，可以一次性替换多个字符。例如，将光标定位到“||”字符处，然后执行
<code>2r&amp;</code>命令，可以将其替换为“&amp;&amp;”。</p>
<h3 id="vim中启用鼠标">Vim中启用鼠标:</h3>
<p>set mouse =a
#这将在所有模式下启用鼠标。如果你只想在特定模式下启用鼠标，可以将上述配置中的“a”替换为对应的模式。各模式的区别如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Enable the use of the mouse.  Works for most terminals (xterm, Win32</span><br><span class="line">win32-mouse, QNX pterm, *BSD console with sysmouse and Linux console</span><br><span class="line">with gpm).  For using the mouse in the GUI, see gui-mouse.  The</span><br><span class="line">mouse can be enabled for different modes:</span><br><span class="line">        n       Normal mode and Terminal modes</span><br><span class="line">        v       Visual mode</span><br><span class="line">        i       Insert mode</span><br><span class="line">        c       Command-line mode</span><br><span class="line">        h       all previous modes when editing a help file</span><br><span class="line">        a       all previous modes</span><br><span class="line">        r       for hit-enter and more-prompt prompt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Vim中，鼠标可以用于启动各种模式。当你将鼠标光标移动到屏幕边缘时，Vim将自动切换到相应的模式。例如，将光标移动到屏幕底部边缘将切换到Normal模式，移动到屏幕左侧边缘将切换到Visual模式，移动到屏幕右侧边缘将切换到Insert模式。
除了在屏幕边缘切换模式外，你还可以使用鼠标右键菜单来切换模式。在Normal模式下，将鼠标光标移动到屏幕边缘并单击右键，将弹出一个菜单，你可以从中选择要切换到的模式。</p>
<p>需要注意的是，启用鼠标后可能会影响Vim的操作体验。因为在Vim中，键盘快捷键是主要的操作方式，而鼠标操作可能会打破这种习惯。此外，Vim中的许多功能是通过键盘快捷键实现的，启用鼠标后可能会与这些快捷键产生冲突。因此，如果你是一个习惯使用键盘快捷键的Vim用户，建议慎重考虑是否启用鼠标。</p>
<h2 id="查看vim是否支持剪切板">查看vim是否支持剪切板</h2>
<p>vim --version| grep "clipboard" 不支持的话安装： sudo apt install
vim-gtk</p>
<ol start="3" type="1">
<li>使用快捷键#
"+y和"+p的输入挺麻烦的，我们直接为他们创建个快捷键吧</li>
</ol>
<p>vim创建快捷键的原理可以看 jalused的博客</p>
<p>我使用的快捷键如下</p>
<p>" 支持在Visual模式下，通过C-y复制到系统剪切板 vnoremap
<code>&lt;C-y&gt;</code> "+y " 支持在normal模式下，通过C-p粘贴系统剪切板
nnoremap <code>&lt;C-p&gt;</code> "*p
将上面的内容copy到~/.vimrc中即可生效，效果就是：</p>
<p>在vim的visual模式下选中了要复制的内容，再用Ctrl +
y复制到系统剪切板，直接去其他窗口中Ctrl + v粘贴
在其他窗口中选择之后（不一定要Ctrl + c），可直接在vim中用Ctrl + p来粘贴
"语法高亮度显示 syntax on
"下面两行在进行编写代码时，在格式对起上很有用；
"第一行，vim使用自动对起，也就是把当前行的对起格式应用到下一行；
"第二行，依据上面的对起格式，智能的选择对起方式，对于类似C语言编
"写上很有用 set autoindent set smartindent
"在编辑过程中，在右下角显示光标位置的状态行 set ruler</p>
<h2 id="cpio格式-initrd-的解压与压缩">cpio格式 initrd 的解压与压缩:</h2>
<p>https://blog.csdn.net/feisang/article/details/6121269
https://blog.sina.com.cn/s/blog_6795385f0100kdb7.html</p>
<p>加载initrd的过程:
http://blog.chinaunix.net/uid-29073321-id-5570250.html</p>
<h2 id="第二部分initrdinitramfs">第二部分：initrd、initramfs</h2>
<p>一、 initrd出现的背景
在早期的linux系统中，一般只有硬盘或者软盘被用来作为linux根文件系统的存储设备，因此也就很容易把这些设备的驱动程序集成到内核中。但是现在的嵌入式系统中可能将根文件系统保存到各种存储设备上，包括scsi、sata，u-disk等等。因此把这些设备的驱动代码全部编译到内核中显然就不是很方便。
在内核模块自动加载机制udev中，我们看到利用udevd可以实现内核模块的自动加载，因此我们希望如果存储根文件系统的存储设备的驱动程序也能够实现自动加载，那就好了。但是这里有一个矛盾，udevd是一个可执行文件，在根文件系统被挂载前，是不可能执行udevd的，但是如果udevd没有启动，那就无法自动加载存储根文件系统设备的驱动程序，同时也无法在/dev目录下建立相应的设备节点。
为了解决这一矛盾，于是出现了基于ramdisk的initrd( bootloader initialized
RAM disk
)。Initrd是一个被压缩过的小型根目录，这个目录中包含了启动阶段中必须的驱动模块，可执行文件和启动脚本，也包括上面提到的udevd（实现udev机制的demon）。当系统启动的时候，bootloader会把initrd文件读到内存中，然后把initrd文件在内存中的起始地址和大小传递给内核。内核在启动初始化过程中会解压缩initrd文件，然后将解压后的initrd挂载为根目录，然后执行根目录中的/init脚本（cpio格式的initrd为/init,而image格式的initrd&lt;也称老式块设备的initrd或传统的文件镜像格式的initrd&gt;为/initrc），您就可以在这个脚本中运行initrd文件系统中的udevd，让它来自动加载realfs（真实文件系统）存放设备的驱动程序以及在/dev目录下建立必要的设备节点。在udevd自动加载磁盘驱动程序之后，就可以mount真正的根目录，并切换到这个根目录中来。
这里只是个简单的描述，后面慢慢分析吧。</p>
<p>5、noinitrd (仅当内核配置了选项
CONFIG_BLK_DEV_RAM和CONFIG_BLK_DEV_INITRD)现在的内核都可以支持initrd了，引导进程首先装载内核和一个初始化的ramdisk，然后内核将initrd转换成普通的ramdisk，也就是读写模式的根文件系统设备。然后linuxrc执行，然后装载真正的根文件系统，之后ramdisk被卸载，最后执行启动序列，比如/sbin/init。</p>
<p>选项noinitrd告诉内核不执行上面的步骤，即使内核编译了initrd，而是把initrd的数据写到
/dev/initrd，只是这是一个一次性的设备。</p>
<h2 id="debian-linux-内核手册">Debian Linux 内核手册：</h2>
<p>https://kernel-team.pages.debian.net/kernel-handbook/index.html</p>
<p>142347
【4.19自测】【桌面专业版】【1050update2】【第一轮】【PGV】【Kirin990】【DDE】双屏仅单屏显示，切换tty后再切换账户登录，a屏显示登录页面，b屏显示tty界面：
设置主屏only时候 xorg切换tty会调用10+次 drm_mode_setcrtc，调用栈基本一样
32.36100 1326 1326 Xorg drm_mode_setcrtc drm_mode_setcrtc+0x0 <a href="#kernel">kernel</a> drm_ioctl+0x1c0 <a href="#kernel">kernel</a>
$x+0x50 <a href="#kernel">kernel</a> do_vfs_ioctl+0xa4 <a href="#kernel">kernel</a> ksys_ioctl+0x78 <a href="#kernel">kernel</a>
__arm64_sys_ioctl+0x1c <a href="#kernel">kernel</a> el0_svc_common+0x90
<a href="#kernel">kernel</a> el0_svc_handler+0x9c <a href="#kernel">kernel</a> el0_svc+0x8 <a href="#kernel">kernel</a>
<strong>GI</strong>_ioctl+0xc [libc-2.28.so] drmModeSetCrtc+0x98
[libdrm.so.2.4.0] [unknown] [amdgpu_drv.so] [unknown] [Xorg]
xf86DisableUnusedFunctions+0xac [Xorg] [unknown] [Xorg] RRCrtcSet+0x22c
[Xorg] ProcRRSetCrtcConfig+0x21c [Xorg] [unknown] [Xorg] [unknown]
[Xorg] __libc_start_main+0xe4 [libc-2.28.so] [unknown] [Xorg]
华为机器使用的wayland，切换tty不会调用drm_mode_setcrtc，此函数用于关闭显示器.
在其他使用wayland的机器上也是如此，并且有同样的现象。说明此问题是wayland的问题。</p>
<h2 id="linux-下常用的程序调试器-gdb-是什么原理"><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/578172542/answer/3389041105">Linux
下常用的程序调试器 gdb 是什么原理？</a></h2>
<p>linux系统上有一个非常厉害的系统调用： <strong><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=ptrace%28%29&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">ptrace()</a>
</strong> ,在linux上的声明是这样子的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern long int ptrace (enum __ptrace_request __request, ...) __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li>long ptrace(request, <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=pid_t%20pid&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">pid_t
pid</a>, void <em>addr, void </em>data)
<ul>
<li>request: 宏定义，比如说PTRACE_TRACEME,
PTRACE_PEEKDATA等，表示一个动作</li>
<li>pid就是一个进程的进程号</li>
<li>addr是地址</li>
<li>data是一个数据，写入动作的话，就是将这个数据写入到这个地址上，如果是读出，那么会读到这个地址上去。</li>
</ul></li>
</ul>
<p>他可以接管一个子进程的执行，就是跟踪一个进程，linux上的进程产生差不多是这样子：父进程先fork()一遍产生一个几乎一摸一样的自己，然后再excel()一个新进程，这时候就会将fork出来的进程替换成要执行的进程。使用ptrace()这个命令就可以跟踪这个新产生的进程。并且进行调试。代码差不多是这样子的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> {</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> program_name { argv[<span class="number">1</span>] };</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 设置跟踪状态</span></span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, nullptr, nullptr);</span><br><span class="line">        execl(program_name.c_str(), program_name.c_str(), nullptr);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 进行调试等操作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="断点的原理"><strong>断点的原理</strong></h2>
<p>emm.我觉得断点的原理跟修改代码差不多，使用ptrace()这个无敌的函数调用可以对函数的汇编代码进行一定的修改，在x86上有一条汇编指令，叫做
** INT 3（** 这里的INT 不是 int，而是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=interrupt&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">interrupt</a>的缩写），当出现这个指令的时候，程序就会发生中断，也就是trap了，然后父进程就可以捕获这个信号，子进程就会中断在那里，等待下一步的命令，也就是说当gdb进行打断点的时候，就是将一条汇编代码修改一下，将其修改成<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=INT%203&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">INT
3</a>的机器码，而INT 3的机器码是多少呢？是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=0xcc&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">0xcc</a>,
所以说当打断点的时候，就会将原来的汇编代码对应的机器码中的机器码指令换成0xcc，当程序执行到一步的时候，就会触发断点，等到调试，那如何跳出这个断点？，将要被替换的机器码指令保存下来就可以了，等到执行的时候将其重新替换上去就可以了（相当于恢复现场）。</p>
<p>ptrace一次是四个字节的修改，但是0xcc是一个字节，（八位），你就需要修改四字节的低位进行处理，然后替换的时候就是将其替换到低位（也就是末位)，替换到低位是因为大部分机器是小端存储，等到一执行到这里的时候就会立马发生中断，等到恢复的时候，不仅要恢复现场（将修改的数值修改到原来的位置上），并且要将寄存器的PC指针
- 1（pc寄存器向上递增的，这里要将寄存器的数值 -1
就是0xcc之前的那个位置，然后继续执行，执行到下一个断点）</p>
<p>打断点的本质上是在机器码上进行打断点的，那么如何知道机器码和你写的代码之间的关系呢，有一个调试信息文件，也就是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=dwarf%E6%96%87%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">dwarf文件</a>,dwarf上会记录上一些相关的信息，如函数的low_pc()和<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=high_pc%28%29&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">high_pc()</a>，（low_pc()
就是最低的那个地址，是函数开头，可以通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=objdump&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">objdump</a>这个工具<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%8F%8D%E6%B1%87%E7%BC%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">反汇编</a>得到的信息和dwarf文件上的信息对比一下，刚好是对应上的）函数名所在的机器码指令在哪，都可以找到，所以说在gdb上就可以直接进行在函数名上打断点了。</p>
<p>ptrace()能干的事情有很多，具体可以查一查手册qwq，其他原理如bt（gdb打印出函数调用）等，涉及到了<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3389041105%7D">函数栈帧</a>的调用，保存在寄存器上，ptrace()也可以直接看寄存器上保存的数值，然后读取出来，做一些有用的事情。</p>
<h2 id="重新安装英伟达驱动">重新安装英伟达驱动：</h2>
<p>1、清除英伟达显卡驱动安装包： dpkg -l |grep nvidia |awk '{print $2}'
|xargs sudo apt-get purge -y 2、看仓库有什么版的包： apt policy
nvidia-driver 3、安装英伟达的驱动包： apt install
nvidia-<strong>driver</strong></p>
<h2 id="nvidia开启drm的设置">nvidia开启drm的设置：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16752202244564-16752204907801.png" alt="企业微信截图_16752202244564">
<figcaption aria-hidden="true">企业微信截图_16752202244564</figcaption>
</figure>
<p>问题分析：该机型同时存在两种显示驱动，一个是BIOS提供的，一个是amd驱动提供，默认控制终端显示采用bios提供的那个驱动，而那个驱动偏偏是有问题的，
如果在grub中添加一个参数：fbcon=map:1
强行让amdgpu驱动来显示控制终端就可以切换tty了</p>
<p>getenforce 看selinux是否打开</p>
<p>http://pkg.loongnix.cn/loongnix/pool/main
龙芯的源码在这个仓库地址里找。</p>
<p>debian官网查找类似代码的网站，可以用来参考其他包是怎么写代码的：</p>
<p>https://codesearch.debian.net/</p>
<p>获取机器的机型：sudo dmidecode -s system-family</p>
<p>通过dsc下载代码：</p>
<p>http://pkg.loongnix.cn/loongnix/pool/main/o/openjdk-8/openjdk-8_8u352-b08-lnd.8.1.12.dsc</p>
<p>dpkg-source -x openjdk-8_8u352-b08-lnd.8.1.12.dsc</p>
<p>龙芯仓库 http://pkg.loongnix.cn/loongnix/pool/main/</p>
<p>龙芯mips仓库http://ftp.loongnix.cn/os/loongnix/20/mips64el/pool/main/</p>
<h2 id="dbus-send">dbus-send：</h2>
<p>dbus-send --print-reply --session
--dest=com.deepin.daemon.InputDevices
/com/deepin/daemon/InputDevice/Wacom org.freedesktop.DBus.Properties.Get
string:com.deepin.daemon.InputDevice.Wacom string:Exis</p>
<p>dbus-send --print-reply --system --type=method_call
--dest=org.freedesktop.DBus / org.freedesktop.DBus.ReloadConfig</p>
<p>获取当前的bssid：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbus-send --system --dest=fi.w1.wpa_supplicant1 --print-reply /fi/w1/wpa_supplicant1/Interfaces/1 org.freedesktop.DBus.Properties.Get string:fi.w1.wpa_supplicant1.Interface string:CurrentBSS</span><br><span class="line"></span><br><span class="line">    method return time=1685433175.012823 sender=:1.7 -&gt; destination=:1.861 serial=631 reply_serial=2</span><br><span class="line">       variant       object path "/fi/w1/wpa_supplicant1/Interfaces/1/BSSs/22"</span><br><span class="line"></span><br><span class="line">dbus-send --system --dest=fi.w1.wpa_supplicant1 --print-reply /fi/w1/wpa_supplicant1/Interfaces/1/BSSs/22 org.freedesktop.DBus.Properties.Get string:fi.w1.wpa_supplicant1.BSS string:BSSID</span><br><span class="line">	method return time=1685434152.265572 sender=:1.7 -&gt; destination=:1.1099 serial=643 reply_serial=2</span><br><span class="line">   variant       array of bytes [</span><br><span class="line">         38 eb 47 bc eb d1</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>
<h2 id="通过-d-bus-访问接口跟d-feet打印的类似">通过 D-Bus
访问接口，跟d-feet打印的类似：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ gdbus introspect --system --dest org.freedesktop.hostname1 --object-path /org/freedesktop/hostname1</span><br><span class="line">node /org/freedesktop/hostname1 {</span><br><span class="line">  interface org.freedesktop.hostname1 {</span><br><span class="line">    methods:</span><br><span class="line">      SetHostname(in  s name,</span><br><span class="line">                  in  b user_interaction);</span><br><span class="line">      SetStaticHostname(in  s name,</span><br><span class="line">                        in  b user_interaction);</span><br><span class="line">      SetPrettyHostname(in  s name,</span><br><span class="line">                        in  b user_interaction);</span><br><span class="line">      SetIconName(in  s name,</span><br><span class="line">                  in  b user_interaction);</span><br><span class="line">      SetChassis(in  s name,</span><br><span class="line">                 in  b user_interaction);</span><br><span class="line">    signals:</span><br><span class="line">    properties:</span><br><span class="line">      readonly s Hostname = 'dhcp-192-168-47-11';</span><br><span class="line">      readonly s StaticHostname = 'lennarts-computer';</span><br><span class="line">      readonly s PrettyHostname = 'Lennart's Computer';</span><br><span class="line">      readonly s IconName = 'computer-laptop';</span><br><span class="line">      readonly s Chassis = 'laptop';</span><br><span class="line">  };</span><br><span class="line">  interface org.freedesktop.DBus.Properties {</span><br><span class="line">  };</span><br><span class="line">  interface org.freedesktop.DBus.Introspectable {</span><br><span class="line">  };</span><br><span class="line">  interface org.freedesktop.DBus.Peer {</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230419101036631.png" alt="image-20230419101036631">
<figcaption aria-hidden="true">image-20230419101036631</figcaption>
</figure>
<h3 id="一种打印非以0结尾的字符串的方法">一种打印非以'\0'结尾的字符串的方法：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Print only 'nbytes' of 'buf', as it doesn't contain a terminating</span><br><span class="line">              null byte ('\0'). */</span><br><span class="line">           printf("'%s' points to '%.*s'\n", argv[1], (int) nbytes, buf);</span><br></pre></td></tr></table></figure>
<h2 id="libinput">Libinput：</h2>
<p>查看libinput事件：</p>
<p>sudo libinput debug-events</p>
<p>查看按的键：</p>
<p>sudo libinput debug-events --show-keycodes</p>
<h3 id="libevdev中libevdev-events.c文件对应的命令是什么怎么使用">libevdev中libevdev-events.c文件对应的命令是什么？怎么使用</h3>
<p><code>libevdev-events.c</code> 文件是 <code>libevdev</code>
库中的一个示例程序，用于演示如何使用 <code>libevdev</code>
库处理输入事件。该文件并不是一个可执行程序，而是一个源代码文件，需要通过编译生成可执行程序。</p>
<p>你可以通过以下步骤编译 <code>libevdev-events.c</code> 文件：</p>
<ol type="1">
<li><p>确保已经安装了 <code>libevdev</code>
库及其头文件，以及编译工具链（如 gcc）。</p></li>
<li><p>下载 <code>libevdev</code>
源代码，并切换到对应版本的代码目录。</p></li>
<li><p>进入 <code>./test</code> 目录，该目录下包含了
<code>libevdev</code> 库的一些示例程序。</p></li>
<li><p>使用以下命令编译 <code>libevdev-events.c</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">gcc -Wall -g -o libevdev-events libevdev-events.c -levdev</span><br></pre></td></tr></table></figure>
<p>上述命令中，<code>-Wall</code>
参数用于开启所有警告信息，<code>-g</code>
参数用于开启调试信息，<code>-o</code> 参数用于指定生成的可执行文件名为
<code>libevdev-events</code>，<code>-levdev</code> 参数用于链接
<code>libevdev</code> 库。</p></li>
<li><p>执行编译生成的可执行文件
<code>libevdev-events</code>，并传递输入设备文件名作为参数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">./libevdev-events /dev/input/event0</span><br></pre></td></tr></table></figure>
<p>上述命令中，<code>/dev/input/event0</code>
是输入设备文件名，你需要将其替换为你想要监控的输入设备文件名。</p></li>
</ol>
<p>执行上述命令后，<code>libevdev-events</code>
程序会打印出输入设备上产生的所有事件信息。你可以通过修改
<code>libevdev-events.c</code> 文件中的代码，来了解如何使用
<code>libevdev</code> 库处理输入事件。</p>
<h3 id="如何确定devinputeventx呢比如我想知道触摸板设备对应哪个event实际上没这么麻烦直接使用libinput-debug-events然后移动鼠标就行了">如何确定/dev/input/eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput
debug-events然后移动鼠标就行了）</h3>
<p>您可以使用
<code>evtest</code>命令来列出可用的输入设备及其对应的event。下面是一些基本的使用方法：</p>
<ol type="1">
<li><p>安装evtest：在大多数Linux发行版上，您可以使用以下命令安装evtest：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduinoCopy code</span><br><span class="line">sudo apt-get install evtest</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy code</span><br><span class="line">sudo yum install evtest</span><br></pre></td></tr></table></figure></li>
<li><p>列出可用的输入设备：运行以下命令以列出可用的输入设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code</span><br><span class="line">evtest --enumerate</span><br></pre></td></tr></table></figure>
<p>该命令将列出所有的输入设备及其对应的event，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code/dev/input/event0    Lid Switch</span><br><span class="line">/dev/input/event1    Power Button</span><br><span class="line">/dev/input/event2    AT Translated Set 2 keyboard</span><br><span class="line">/dev/input/event3    SynPS/2 Synaptics TouchPad</span><br></pre></td></tr></table></figure></li>
<li><p>测试输入设备：您可以使用以下命令来测试某个输入设备，例如触摸板设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">evtest /dev/input/event3</span><br></pre></td></tr></table></figure>
<p>该命令将打印出输入设备发出的事件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">luaCopy codeEvent: time 1618822168.785292, type 3 (EV_ABS), code 0 (ABS_X), value 3097</span><br><span class="line">Event: time 1618822168.785292, type 3 (EV_ABS), code 1 (ABS_Y), value 1509</span><br><span class="line">Event: time 1618822168.785292, type 3 (EV_ABS), code 24 (ABS_PRESSURE), value 0</span><br><span class="line">Event: time 1618822168.785292, -------------- SYN_REPORT ------------</span><br></pre></td></tr></table></figure>
<p>这将帮助您确定触摸板设备对应的event号码。</p></li>
</ol>
<h2 id="ldconfig">ldconfig:</h2>
<p>/*ldconfig 命令的用途主要是在默认搜寻目录 /lib 和 /usr/lib
以及动态库配置文件 /etc/ld.so.conf 内所列的目录下，</p>
<p>搜索出可共享的动态链接库（格式如
lib<em>.so</em>），进而创建出动态链接器（ld.so 或
ld-linux.so）所需的缓存文件。</p>
<p>缓存文件默认为
/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，</p>
<p>需运行动态链接库的管理命令 ldconfig
更新动态链接库的缓存文件，此执行程序存放在 /sbin 目录下。</p>
<p>ldconfig
通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。*/</p>
<p>一个重要的bug:https://pms.uniontech.com/zentao/bug-view-101762.html</p>
<p>复现问题，查看cat /proc/bus/input/devices &gt;input.txt
,查看文件触摸板设备Touch为event2 远程cat
/dev/input/event2发现是有数据的。执行 sudo libinput debug-events
--show-keycode 命令无数据，sudo libinput debug-events有数据。</p>
<p>这个问题目前分析的应该是比较全面了。分析结论如下：</p>
<p>1、休眠同时触发合盖动作，lid event节点会上报合盖事件，同时休眠。</p>
<p>2、kwin调用libinput，在接收到合盖事件后，主动禁用触摸设备，这一操作是libinput内部操作，主要的实现机制是关闭对应event的fd。在kwin场景下是通过调用systemd的releaseDevice来达到关闭触摸设备的目的。</p>
<p>3、开盖后，唤醒设备，此时系统并不会有开盖的事件上报。</p>
<p>4、因为此时kwin并没有收到开盖事件，所以触摸设备仍然处于禁用状态。</p>
<p>5、按下键盘，此时仍然不会收到开盖事件，这一点可以通过监听sudo cat
/dev/input/eventX设备节点可以确认，而且通过sudo
evtest也可以确认确实没有监听到开盖事件，同时也可以查到此时开合盖的状态仍然处于合盖状态。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278110.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>6、按下按键后，libinput虽然发现设备仍然处于合盖状态，但是根据libinput的机制，认为触发键盘按键时，设备应该实际处于开盖状态。所以libinput主动上报了一个开盖事件出来。(通过sudo
libinput debug-events --show-keycodes可以监听到这个事件)。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278105.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>上面说的2、5、6三点均为libinput的机制。官方文档地址如下</p>
<p>https://wayland.freedesktop.org/libinput/doc/1.8.1/switches.html</p>
<p>简单翻译</p>
<p>在可用的场景下，libinput会监听提供盖子开关的设备。evdev事件代码EV_SW
SW_LID提供为LIBINPUT_SWITCH_LID。如果带有盖子开关的设备有触摸板设备，则当盖子在逻辑上关闭时，该设备将被禁用。这是为了避免触控板和闭合的盖子可能引起的鬼触。当盖子打开时，触摸板会自动重新启用。</p>
<p>这种盖子开关的处理对用户来说是透明的，不发送通知，设备在任何时候都显示为启用。</p>
<p>在某些设备上，设备的盖子状态并不总是反映物理状态，即使当盖子物理上是打开的，盖子状态也可能报告为关闭。Libinput使用一些启发式方法来检测用户输入(特别是输入)，以重新启用这些设备上的触摸板。</p>
<p>该问题的根本原因还是在于开合盖的状态和实际物理状态不一致导致的。如果想要彻底解决该问题，还是需要能够解决这个状态异常的情况。</p>
<p>问题复现时进行开盖合盖测试程序测试</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-278278.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278278.png" alt="img"></a></p>
<p>发生问题时开盖合盖简直监测：</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-278281.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-278281.png" alt="img"></a></p>
<p>当问题复现时驱动层无开盖信息。</p>
<p>复现场景为待机按键后马上合盖，合盖后进入待机流程。此时待机未完成进入待机保存现场（带有合盖待机状态），处于待机未完成。当打开笔记本盖子时继续完成待机，（待机相关信息保存在硬盘，无法监测到开盖事件。）相关处理指示灭掉灯表示此时已经完成保存待机状态。待机状态设备状态此是不通电驱动层的无法感知开盖，系统层无法修改，只能应用层规避此问题。</p>
<pre><code>休眠             合盖                              开盖            半休眠状态信息保存硬盘是掉电状态驱动无法获取开盖事件</code></pre>
<p>运行状态---------》休眠到一半-------》带有合盖状态休眠保存待机状态---------》恢复带有合盖状态休眠保存待机状态再次执行未完成的待机--—》开机问题复现</p>
<p>进程休眠或者待机收到为同一信号无法做区分，需要加入新的唤醒信号或者做标识，来让上层做分析处理。</p>
<p>下层处理风险太大，按现在逻辑分析按键时间会模拟开盖事件，只是滑动触摸板没有模拟开盖事件。无硬件反馈下层是无法感知，即使修改会产生很大问题。libinput是可以感应到滑动触摸板，做个开盖模拟操作就可以了。</p>
<p>查看kwin相关代码：libinput/device.cpp +526</p>
<p>Device::Device(libinput_device <em>device, QObject
</em>parent)类中有相关处理</p>
<p>cat /dev/input/event
事件，触摸板有滑动事件，但是异常出问题libinput被拦截。替换麒麟内核问题依然复现不是内核原因，不是在用户内部服务修改，不然登陆界面复现问题，比较大的概率在libinput。</p>
<h2 id="安装双系统">安装双系统：</h2>
<p>第一个系统分区[注意顺序]：</p>
<p>efi 300M</p>
<p>swap 8G[和原有运行内存相当]</p>
<p>/boot 2G</p>
<p>/ 根分区100G</p>
<p>第二个系统</p>
<p>在第一个系统的分区基础上进行</p>
<p>/boot 2G</p>
<p>/</p>
<h2 id="华为机型判断">华为机型判断</h2>
<p>一、华为机型判断 KLV中有: HUAWEI QINGYUN L420 KLVV-W5821 PGV中有:
PGUV W515 KLU中有: L410 KLVU PGW中有: PGUW W525 机型判断3种方式
1.可以通过机器上的铭牌查看 2.进入系统后通过cat /etc/hw_version查看
3.通过dmidecode -s system-product-name查看</p>
<p>二、klu和klua机型区分 hwfirmware
-v的结果小于等于2.0.0.53是klu,其他是klua，如:结果是2.0.1.7就是klua</p>
<p>三、pgv和pgv C版本机器区分
拆开机箱看显卡芯片，在风扇边上的是小芯片就是pgv机器，是大芯片就是pgv
c版本机器</p>
<p>四、pgv使用ti显卡芯片还是龙讯显卡芯片区分 dmesg | grep
lt9711a结果出现lt9711a is onboard就是龙讯显卡芯片的pgv机器 dmesg | grep
sn65dsix6结果出现sn65dsix6 is onboard就是ti显卡芯片的pgv机器</p>
<p>五、查看目前安装的系统华为版本 通过cat /etc/hw_version查看</p>
<p>六、查看目前安装的系统统信版本 通过cat
/etc/os-version查看,主要看MinorVersion=的结果，如MinorVersion=1022是1022版本</p>
<h2 id="systemd-analyze是如何统计开机时间的">systemd-analyze是如何统计开机时间的</h2>
<p>使用systemd-analyze可以得到以下结果： Startup finished in 22.440s
(firmware) + 2.471s (loader) + 40.688s (kernel) + 8.427s (userspace) =
1min 14.028s graphical.target reached after 8.420s in userspace
我们可以清晰的看到固件，grub，内核所耗费的时间，但systemd启动的时机在fireware,loader和kernel之后，它是如何统计这些启动阶段所耗的时间的呢。</p>
<h3 id="firmware和loader">firmware和loader</h3>
<p>通过分析systemd代码，systemd统计fireware和loader的时间是通过读取acpi
fpdt表和efi变量来完成的。具体的代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">boot_timestamps</span><span class="params">(<span class="type">const</span> dual_timestamp *n, dual_timestamp *firmware, dual_timestamp *loader)</span> {</span><br><span class="line">        r = acpi_get_boot_usec(&amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) {</span><br><span class="line">                r = efi_loader_get_boot_usec(&amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">        } </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中acpi_get_boot_usec主要是解析acpi
fpdt表的内容。大致实现如下。在高版本的内核中已经实现了acpi表的解析，不再需要在用户态来解析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">acpi_get_boot_usec</span><span class="params">(<span class="type">usec_t</span> *loader_start, <span class="type">usec_t</span> *loader_exit)</span> {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_table_header</span> *<span class="title">tbl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_fpdt_header</span> *<span class="title">rec</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_fpdt_boot_header</span> <span class="title">hbrec</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">acpi_fpdt_boot</span> <span class="title">brec</span>;</span></span><br><span class="line"></span><br><span class="line">        r = read_full_file(<span class="string">"/sys/firmware/acpi/tables/FPDT"</span>, &amp;buf, &amp;l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find Firmware Basic Boot Performance Pointer Record */</span></span><br><span class="line">        <span class="keyword">for</span> (rec = (<span class="keyword">struct</span> acpi_fpdt_header *)(buf + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_table_header));</span><br><span class="line">             (<span class="type">char</span> *)rec length)) {</span><br><span class="line">                <span class="keyword">if</span> (rec-&gt;length type != ACPI_FPDT_TYPE_BOOT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (rec-&gt;length != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_header))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                ptr = rec-&gt;ptr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read Firmware Basic Boot Performance Data Record */</span></span><br><span class="line">    fd = open(<span class="string">"/dev/mem"</span>, O_CLOEXEC|O_RDONLY);</span><br><span class="line">       l = pread(fd, &amp;hbrec, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_boot_header), ptr);  </span><br><span class="line">       l = pread(fd, &amp;brec, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_boot), ptr + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> acpi_fpdt_boot_header));</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>efi_loader_get_boot_usec函数主要是读取LoaderTimeInitUSec和LoaderTimeExecUSec两个efi变量，在此不再描述。</p>
<p>如果acpi表中数据有误，systemd-analyze则无法显示firmware和loader的时间。</p>
<h3 id="kernel">kernel</h3>
<p>systemd统计kernel耗费时间的方式是记录自身启动时间的monotonic
time。但实际上并不是内核启动的时间，它包含了kernel+initrd+systemd加载自身的时间。具体如何分析这三部分的时间需要分析内核和initrd的日志。
systemd统计内核启动时间的方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line"></span><br><span class="line">        dual_timestamp initrd_timestamp = DUAL_TIMESTAMP_NULL, userspace_timestamp = DUAL_TIMESTAMP_NULL, kernel_timestamp = DUAL_TIMESTAMP_NULL;</span><br><span class="line">        <span class="comment">/* Take timestamps early on */</span></span><br><span class="line">        dual_timestamp_from_monotonic(&amp;kernel_timestamp, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="cmake基础学习">CMake基础学习</h2>
<p>https://docsin.uniontech.com/?p=20713</p>
<h2 id="mount">Mount:</h2>
<p>sudo mount -o remount,rw /dev/sdd2 重新以可写方式挂载boot分区</p>
<p>mount -i 打印的信息就是cat /proc/self/mountinfo的信息</p>
<h2 id="gdb打印所有堆栈">GDB打印所有堆栈：</h2>
<p>thread apply all bt</p>
<h2 id="玲珑包工具">玲珑包工具：</h2>
<p>https://linglong.dev/guide/ll-cli/introduction.html</p>
<h2 id="trace-cmd">trace-cmd:</h2>
<p>ftrace: https://www.modb.pro/db/105914 trace-cmd:
https://www.modb.pro/db/125882</p>
<p>查看trace-cmd是否可用：</p>
<p>mount | grep tracefs(好像没啥用，我虚拟机完全没打印东西)</p>
<p>查看有哪些追踪器可用：</p>
<p>trace-cmd list -t</p>
<p>启用你的第一个追踪器:</p>
<p>trace-cmd start -p function</p>
<p>trace-cmd record -l ext4_* -p function_graph</p>
<p>trace-cmd record -p function_graph</p>
<p>trace-cmd report</p>
<p>用 <code>-P</code> 选项传递PID</p>
<p>/sys/kernel/tracing</p>
<h2 id="apparmor官方文档">apparmor官方文档：</h2>
<p>https://gitlab.com/apparmor/apparmor/-/wikis/Documentation</p>
<h2 id="scsi设备扫描">scsi设备扫描：</h2>
<p>https://zhuanlan.zhihu.com/p/61608889</p>
<h2 id="休眠的实现">休眠的实现：</h2>
<p>将"mem", "standby", "freeze" and "disk"写入/sys/power/state</p>
<p>参考：https://www.kernel.org/doc/Documentation/power/states.txt</p>
<p>内核部分的代码：关键词Syncing filesystems..和done.</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230316161646504.png" alt="image-20230316161646504">
<figcaption aria-hidden="true">image-20230316161646504</figcaption>
</figure>
<h2 id="openssl-调试">openssl 调试:</h2>
<p>\1. 编译 /config --debug --prefix=/usr/ \2. 安装 make install_sw
会把openssl库安装到/usr/lib64</p>
<p>\3. /etc/ld.so.conf.d/libc.conf添加 /usr/lib64</p>
<p>\4. 如果openssl有问题，会导致系统无法运行，此时用live镜像或者
initramfs 删除 /root/lib64下的openssl库</p>
<p>/etc/profile是由base-file生成的</p>
<h2 id="双rtc问题参考190897">双rtc问题（参考190897）：</h2>
<p>1、分析确认设备只有一个物理时钟芯片，但从内核看到两个rtc设备节点（efi-rtc和ds1307）
2、两个设备中读取出来的时间存在一致的问题。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621353.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>初步分析为 问题1: 一个物理时钟芯片，在内核中存在两个rtc设备问题</p>
<p>双rtc的问题的根源是固件那边同时实现了物理rtc到efi-rtc的映射实现的同时，在固件传给内核的acpi表上没有屏蔽掉物理rtc芯片设备，从而导致内核这边注册了两次rtc设备。</p>
<p>这个问题可以从固件方面修改，需要固件那边屏蔽acpi上面的物理设备的传递。或者内核这边通过内核启动参数，只注册efi-rtc忽略其他rtc设备。
或者内核通过custome acpi表，修改和屏蔽一个rtc设备。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621355.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>问题2:设备中读取出来的时间存在不一致的问题
通过修改bios中时间，在系统下读内核注册的rtc时间发现。</p>
<p>固件中修改时间后，rtc0 （efi-rtc）中的年份时间与预期一致。
但rtc1中（ds1307） 中的年份与预期不一致。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621357.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-621359.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>因内核第二次从rtc中读出年份解析错误，而导致系统时间变成了
2106（这个是系统显示时间上限问题）</p>
<p>这个问题初步确认为内核中rtc1的驱动读取时间时，出现解析年份异常。导致出现了2124年，这个问题是否是双rtc问题导致不确定（需要设备进一步排除）。</p>
<p>结论，以上问题非系统问题，建议转内核或厂商固件处理。</p>
<h2 id="shutdownreboot">Shutdown/reboot</h2>
<p>对于目前使用systemd的linux发行版，reboot，shutdown，halt等命令是指向systemctl的软链接，执行reboot相当于执行
systemctl reboot，systemctl reboot 会切换到 reboot.target.</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/v2-7e584546c229a0b2784cad5d37939b99_720w.webp" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>注意，如果应用程序希望重启系统， 那么不应该直接启动此目标，而应该使用
systemctl reboot 命令(有可能还需要加上 --no-block 选项)或者直接调用
systemd-logind.service(8) 的 org.freedesktop.login1.Manager.Reboot D-Bus
方法。</p>
<p>为了保持与SysV的兼容性， runlevel6.target
是此单元的一个别名(软连接)。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/v2-c8220c022468b4a9e1e80aa31b4f54b5_720w.webp" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>conflicts with all system
services：指那些定义了Conflicts=shutdown.target 和
Before=shutdown.target 依赖关系（除非明确设置了 DefaultDependencies=no
，否则 service
单元将会自动添加这些依赖）的服务，这些服务在shutdown.target运行之前会停止。</p>
<p>实际执行过程从上到下，以reboot为例：</p>
<pre><code>systemd-reboot.service:</code></pre>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/v2-f23a61e22a6d505f59281d3f8804750e_720w.webp" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<pre><code>我们的systemd-reboot.service是这样写的：</code></pre>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103814108.png" alt="image-20230322103814108">
<figcaption aria-hidden="true">image-20230322103814108</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103941482.png" alt="image-20230322103941482">
<figcaption aria-hidden="true">image-20230322103941482</figcaption>
</figure>
<p><strong>\1.
停止和shutdown.target、umount.target冲突的服务。</strong></p>
<p><strong>\2. shutdown.target、umount.target</strong></p>
<p><strong>\3. various low-level services</strong></p>
<p><strong>\4. final.target</strong></p>
<p><strong>\5. systemd-reboot.service</strong></p>
<p>该服务执行的命令行：ExecStart=/bin/systemctl --force
reboot，这条命令会调用systemd-shutdown，它将以简单而强大的方式卸载任何剩余的文件系统，杀死任何剩余的进程并释放任何其他剩余的资源，而不再考虑任何服务或单元概念。一般这是最后执行的服务。</p>
<p><strong>\6. reboot.target</strong></p>
<p>目标单元的功能仅仅是通过依赖关系将一组单元汇聚在一起，
形成一个同步点，并给这个同步点取一个众所周知的名称，
以便用作启动目标或其他单元的依赖。对于shutdown.target、umount.target、final.target、reboot.target这些目标单元，其组内的单元（.wants/、.requires/）实际的启动顺序取决于单元自身的依赖关系。</p>
<h2 id="systemd常规启动流程">systemd常规启动流程：</h2>
<p>当成功挂载了"root="内核引导选项指定的根文件系统之后，内核将启动由"init="内核引导选项指定的init程序，
从这个时间点开始，即进入了"常规启动流程"：
检测硬件设备并加载驱动、挂载必要的文件系统、启动所有必要的服务，等等。对于
<a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.html#">systemd(1)</a>
系统来说，上述"init程序"就是 systemd 进程，
而整个"常规启动流程"也以几个特殊的 target 单元(详见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.target.html#">systemd.target(5)</a>)
作为节点，被划分为几个阶段性步骤。
在每个阶段性步骤内部，任务是高度并行的，
所以无法准确预测同一阶段内单元的先后顺序，
但是不同阶段之间的先后顺序总是固定的。</p>
<p>当启动系统时， systemd 将会以 <code>default.target</code>
为启动目标， 借助单元之间环环相扣的依赖关系，即可完成"常规启动流程"。
<code>default.target</code> 通常只是一个指向
<code>graphical.target</code>(图形界面) 或
<code>multi-user.target</code>(文本控制台) 的软连接。
为了强制启动流程的规范性以及提高单元的并行性，
预先定义了一些具有特定含义的 target 单元。 详见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.special.html#">systemd.special(7)</a>
手册。</p>
<p>下面的图表解释了 这些具有特定含义的 target 单元之间的依赖关系
以及各自在启动流程中的位置。
图中的箭头表示了单元之间的依赖关系与先后顺序，
整个图表按照自上而下的时间顺序执行。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322102843189.png" alt="image-20230322102843189">
<figcaption aria-hidden="true">image-20230322102843189</figcaption>
</figure>
<p>用<em>斜体</em>标识的目标单元经常被用作启动目标。
有两种方法可以指定启动目标： (1)使用 <code>systemd.unit=</code>
内核引导选项(参见 <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd.html#">systemd(1)</a>)；
(2)使用 <code>default.target</code> 软连接。</p>
<p>因为 <code>timers.target</code> 以异步方式包含在
<code>basic.target</code> 中， 所以 timer 单元可以依赖于在
<code>basic.target</code> 之后才启动的服务。</p>
<h2 id="initrdinitial-ram-disk-启动流程">initrd(Initial RAM Disk)
启动流程<a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/bootup.html#initrd(Initial%20RAM%20Disk)%20启动流程">¶</a></h2>
<p>在initrd内部， 也可以将 systemd 用作
init程序(由"rdinit="内核引导选项指定)。</p>
<p>此时 <code>initrd.target</code> 将是默认目标。
initrd内部启动流程的上半部分与前一小节 <code>basic.target</code>
之前的部分完全相同。 随后的启动流程将以 <code>initrd.target</code>
为目标(如下图所示)。 在挂载任何文件系统之前(也就是在启动
<code>local-fs-pre.target</code> 之前)，
<code>systemd-hibernate-resume@.service</code> 将会首先完成启动，
以检查系统是要从先前的休眠状态中恢复， 还是要执行常规的启动流程。
在检查完成之前，将不会挂载任何文件系统。 当根文件系统设备可用时，将到达
<code>initd-root-device.target</code> 目标。
如果成功的将根文件系统挂载到 <code>/sysroot</code> 目录，那么
<code>sysroot.mount</code> 单元将被启动，然后进一步到达
<code>initrd-root-fs.target</code> 目标。
<code>initrd-parse-etc.service</code> 将会分析
<code>/sysroot/etc/fstab</code> 文件以挂载 <code>/usr</code> (若需要)
与带有 <em>x-initrd.mount</em> 标记的挂载点。 所有这些挂载点都将被挂载到
<code>/sysroot</code> 之下，然后流程到达 <code>initrd-fs.target</code>
目标。再接下来 <code>initrd-cleanup.service</code> 将会使用
<strong>systemctl --no-block isolate</strong> 命令启动
<code>initrd-switch-root.target</code> 目标。 因为 isolate
表示立即停止所有在新的目标单元中不需要的进程，
所以此动作实际上是为接下来切换根目录做预先的准备(也就是清理环境)。
最后，启动 <code>initrd-switch-root.service</code>
服务，将系统的根目录切换至 <code>/sysroot</code> 目录。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103231804.png" alt="image-20230322103231804">
<figcaption aria-hidden="true">image-20230322103231804</figcaption>
</figure>
<h2 id="关机流程">关机流程<a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/bootup.html#关机流程">¶</a></h2>
<p>systemd 系统在关机时同样遵循固定的流程， 具体如下图所示：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230322103311681.png" alt="image-20230322103311681">
<figcaption aria-hidden="true">image-20230322103311681</figcaption>
</figure>
<p><em>斜体</em>标识的目标单元经常被用作关机目标。</p>
<p>注意， <a target="_blank" rel="noopener" href="http://www.jinbuguo.com/systemd/systemd-halt.service.html#">systemd-halt.service(8)</a>,
<code>systemd-reboot.service</code>,
<code>systemd-poweroff.service</code>,
<code>systemd-kexec.service</code> 会将系统与 systemd(PID=1)
带入关机流程的第二个阶段(由 <code>systemd-shutdown</code> 执行)，
也就是不再考虑任何服务与单元等概念，
只用一种简单粗暴的方式卸载所有文件系统、杀死所有进程、释放所有资源。
一般来说，在第一阶段结束时，常规应用都已终止、常规资源都已释放，第二阶段只是一个兜底的安全网，
那些在第一阶段基于单元的关闭流程中(见前文)
未能结束的进程将被强制终止、未能释放的资源将被强制释放。</p>
<h2 id="出现d状态程序后打印内核堆栈">出现D状态程序后打印内核堆栈：</h2>
<p>如果出现D状态程序后，开两个终端，一个先执行dmesg -w，另一个再执行echo
w &gt; /proc/sysrq-trigger, 在dmesg里打印内核的调用栈，</p>
<p>/etc/sysctl.conf file:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel.sysrq=1</span><br><span class="line"></span><br><span class="line">下面是抓程序堆栈（没试过）：</span><br><span class="line">文管卡住的时候，</span><br><span class="line">1. 查询文管 PID </span><br><span class="line">2. gcore <span class="variable">$PID</span> 生成 core.xxx 文件</span><br><span class="line">3. gdb dde-file-manager core.xxxx</span><br></pre></td></tr></table></figure>
<h2 id="休眠变重启问题"><strong>休眠变重启问题：</strong></h2>
<p>系统安装中最后一次执行的update-initramfs动作是在chroot环境内,在chroot环境中执行是不会生成initrd/conf/conf.d/zz-resume-auto文件，该文件用于记录休眠唤醒时的起点，必须在真机上执行update-initramfs时才会生成</p>
<p>该问题使用临时方案进行解决：将安装配置（用户、时区等）放在系统安装之后</p>
<p>https://gerrit.uniontech.com/plugins/gitiles/system-devel/iso-build-deepin/+/ae9276819d28e1e7dd63fd25950f026fe6331798</p>
<p>该问题根因：安装器的配置流程放在了系统安装之前，V20上是安装完成之后才开始配置的</p>
<p><strong>wpa 打开log日志：</strong></p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230323093436435.png" alt="image-20230323093436435">
<figcaption aria-hidden="true">image-20230323093436435</figcaption>
</figure>
<h2 id="虚拟机搭建">虚拟机搭建：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libvirt0 libvirt-daemon libvirt-daemon-system qemu virt-manager bridge-utils libvirt-clients python-libvirt qemu-efi uml-utilities virtinst qemu-system</span><br></pre></td></tr></table></figure>
<h4 id="设置网络桥接"><strong>设置网络桥接</strong></h4>
<h6 id="首先要停止网络服务">首先：要停止网络服务</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop network-manager.service</span><br></pre></td></tr></table></figure>
<h6 id="其次修改网络配置文件">其次：修改网络配置文件</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>
<h6 id="手动设置ip">手动设置ip</h6>
<p>请将以下代码复制到编辑的文件中，注意：IP等设置自己按照需要修改。不想手动设置ip可跳过这一步，使用下面自动获取ip的方法</p>
<p>auto lo</p>
<p>iface lo inet loopback</p>
<p>auto eth0</p>
<p>iface eth0 inet manual</p>
<p>auto br0</p>
<p>iface br0 inet static</p>
<p>address 192.168.200.130</p>
<p>network 192.168.200.0</p>
<p>netmask 255.255.255.0</p>
<p>broadcast 192.168.200.255</p>
<p>gateway 192.168.200.1</p>
<p>dns-nameservers 8.8.8.8</p>
<p>bridge_ports eth0</p>
<p>bridge_stp off</p>
<p>bridge_fd 0</p>
<p>bridge_maxwait 0</p>
<h6 id="自动从dhcp获取ip">自动从DHCP获取ip</h6>
<p>请将一下代码复制到编辑的文件中</p>
<p>auto lo</p>
<p>iface lo inet loopback</p>
<p>#auto eth0</p>
<p>#iface eth0 inet manual</p>
<p>auto br0</p>
<p>iface br0 inet dhcp</p>
<p>bridge_ports eth0</p>
<p>bridge_stp off</p>
<p>bridge_fd 0</p>
<h6 id="最后重新启动网络服务便可">最后：重新启动网络服务便可</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start network-manager.service</span><br></pre></td></tr></table></figure>
<h6 id="启用虚拟网络每次启动虚拟机报network相关错误就执行命令">启用虚拟网络(每次启动虚拟机报network相关错误就执行命令)</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh net-start default</span><br></pre></td></tr></table></figure>
<h2 id="x11获取设备信息">X11获取设备信息:</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152658407.png" alt="image-20230324152658407">
<figcaption aria-hidden="true">image-20230324152658407</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152721451.png" alt="image-20230324152721451">
<figcaption aria-hidden="true">image-20230324152721451</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152537663.png" alt="image-20230324152537663">
<figcaption aria-hidden="true">image-20230324152537663</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152549668.png" alt="image-20230324152549668">
<figcaption aria-hidden="true">image-20230324152549668</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152559927.png" alt="image-20230324152559927">
<figcaption aria-hidden="true">image-20230324152559927</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152609252.png" alt="image-20230324152609252">
<figcaption aria-hidden="true">image-20230324152609252</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152622996.png" alt="image-20230324152622996">
<figcaption aria-hidden="true">image-20230324152622996</figcaption>
</figure>
<p>这里上面的xcb_connection_t 里的fd应该是/tmp/.X11-unix/x:</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324153059779.png" alt="image-20230324153059779">
<figcaption aria-hidden="true">image-20230324153059779</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324153336357.png" alt="image-20230324153336357">
<figcaption aria-hidden="true">image-20230324153336357</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152958599.png" alt="image-20230324152958599">
<figcaption aria-hidden="true">image-20230324152958599</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324152829036.png" alt="image-20230324152829036">
<figcaption aria-hidden="true">image-20230324152829036</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230324153538211.png" alt="image-20230324153538211">
<figcaption aria-hidden="true">image-20230324153538211</figcaption>
</figure>
<h2 id="systemctl-is-enabled-返回-indirect-是什么意思">systemctl
is-enabled 返回 indirect 是什么意思？</h2>
<p>当你运行
<code>systemctl is-enabled &lt;unit&gt;</code>命令来检查指定的systemd服务单元的启用状态时，可能会得到"indirect"的结果。这表示指定的单元并没有直接启用，而是被其他服务单元所依赖而间接启用。</p>
<p>换句话说，如果一个服务单元A依赖于另一个服务单元B，并且B已经启用，那么A也会被间接地启用，即使它本身没有直接被启用。在这种情况下，当你运行
<code>systemctl is-enabled A</code>时，你会得到"indirect"的输出结果。</p>
<p>需要注意的是，间接启用并不意味着服务单元A可以独立地启动或停止。如果依赖于A的其他服务单元也被启用，那么A将保持运行状态。</p>
<h2 id="systemctl-enable-a.service后开机启动后并没有启动a.service只是起了a.socket这是为什么">systemctl
enable
A.service后，开机启动后并没有启动A.service，只是起了A.socket，这是为什么？</h2>
<p>当你运行
<code>systemctl enable A.service</code>命令来启用一个systemd服务单元时，它将创建一个符号链接，指向启用的服务单元文件（通常是位于
<code>/etc/systemd/system</code>或
<code>/usr/lib/systemd/system</code>目录下的
<code>.service</code>文件）到
<code>/etc/systemd/system</code>目录下的一个目标文件（通常是
<code>/etc/systemd/system/multi-user.target.wants</code>目录下的符号链接）。这将导致服务单元在系统启动时自动启动。</p>
<p>然而，<strong>在某些情况下，systemd服务单元本身并不是实际需要自动启动的程序，而是一种被动的服务单元（例如，一个.socket文件），它监听一个端口并等待传入的连接请求。这种情况下，systemd会自动创建一个与服务单元文件同名的.socket文件，并将其链接到启用的服务单元文件（即创建一个
<code>A.socket -&gt; A.service</code>的符号链接）。</strong></p>
<p>因此，<strong>在你运行
<code>systemctl enable A.service</code>命令后，如果A.service是一个被动的服务单元，那么systemd将自动创建一个与之同名的.socket文件，并将其链接到A.service文件。在系统启动时，systemd会启动这个.socket文件并等待传入的连接请求，而不是直接启动A.service文件。如果你想要启动A.service，你可以手动运行
<code>systemctl start A.service</code>命令来启动它。</strong></p>
<h2 id="怎么判断service是一个被动的服务单元">怎么判断service是一个被动的服务单元？</h2>
<p>一般来说，可以通过查看systemd服务单元文件的内容来判断它是否是一个被动的服务单元。</p>
<p>被动的服务单元通常是 <code>.socket</code>或
<code>.path</code>类型的服务单元。<code>.socket</code>服务单元用于监听一个网络端口或一个文件系统中的套接字文件，等待传入的连接请求。<code>.path</code>服务单元用于监视一个文件系统中的路径，当指定的文件或目录发生变化时触发服务单元的启动。</p>
<p>而普通的服务单元则通常是
<code>.service</code>类型的服务单元，它是一种主动的服务单元，通常用于执行某些操作或运行某些程序。</p>
<p>因此，如果一个systemd服务单元文件的名称以 <code>.socket</code>或
<code>.path</code>结尾，那么它很可能是一个被动的服务单元。另外，你还可以查看服务单元文件的内容，查看其中的
<code>[Socket]</code>或
<code>[Path]</code>部分是否存在，以确认服务单元是否是被动的服务单元。</p>
<h2 id="这个服务是被动服务单元吗-从哪个地方可以看出">这个服务是被动服务单元吗
？ 从哪个地方可以看出？</h2>
<p>[Unit] Description=PC/SC Smart Card Daemon Requires=pcscd.socket
Documentation=man:pcscd(8)</p>
<p>[Service] ExecStart=/usr/sbin/pcscd --foreground --auto-exit
ExecReload=/usr/sbin/pcscd --hotplug</p>
<p>[Install] Also=pcscd.socket</p>
<p>根据提供的systemd服务单元文件的内容，可以看出这是一个被动服务单元。原因如下：</p>
<ul>
<li>该服务单元文件的名称是 <code>pcscd.service</code>，而不是
<code>.socket</code>或 <code>.path</code>类型的服务单元文件。</li>
<li>在 <code>[Unit]</code>部分，它的描述（Description）是“PC/SC Smart
Card Daemon”，而不是“PC/SC Smart Card Socket”或“PC/SC Smart Card
Path”等名称，这进一步说明它是一个服务而不是一个socket或path服务单元。</li>
<li><strong>在 <code>[Unit]</code>部分，它有一个
<code>Requires=pcscd.socket</code>的依赖项，这意味着它依赖于一个
<code>.socket</code>类型的服务单元，这通常是被动服务单元</strong>。</li>
<li>在
<code>[Install]</code>部分，它有一个<strong><code>Also=pcscd.socket</code>的指令，这意味着如果该服务单元被启用，也会同时启用与之同名的
<code>.socket</code>服务单元，这也是被动服务单元的标志之一</strong>。</li>
</ul>
<p>综上所述，根据该服务单元文件的内容，可以判断它是一个被动服务单元，<strong>用于启动
<code>pcscd.socket</code>服务单元，监听一个网络端口，等待传入的连接请求</strong>。</p>
<h2 id="systemctl-enable-此服务会做什么-enable之后开机对此服务会做什么">systemctl
enable 此服务会做什么？ enable之后开机对此服务会做什么</h2>
<p><code>systemctl enable</code>命令用于将systemd服务单元设置为开机自动启动。具体来说，当你运行
<code>systemctl enable service_name</code>命令来启用一个systemd服务单元时，它会在
<code>/etc/systemd/system</code>目录下创建一个符号链接，指向该服务单元文件（通常是位于
<code>/etc/systemd/system</code>或
<code>/usr/lib/systemd/system</code>目录下的
<code>.service</code>文件）到
<code>/etc/systemd/system/multi-user.target.wants</code>目录下的一个目标文件（也是一个符号链接）。这将导致服务单元在系统启动时自动启动。</p>
<p>因此，当你运行
<code>systemctl enable service_name</code>命令来启用一个服务单元时，在系统下次启动时，systemd将自动启动该服务单元，以确保服务在系统启动后可用。这对于一些关键的系统服务，如网络服务、系统日志服务等非常重要，因为这些服务需要在系统启动时启动，以确保系统的正常运行。</p>
<p>总之，<code>systemctl enable</code>命令的作用是将指定的systemd服务单元设置为开机自动启动，以确保服务在系统启动时自动启动并运行。</p>
<p>[Unit] Description=PC/SC Smart Card Daemon Requires=pcscd.socket
Documentation=man:pcscd(8)</p>
<p>[Service] ExecStart=/usr/sbin/pcscd --foreground --auto-exit
ExecReload=/usr/sbin/pcscd --hotplug</p>
<p>[Install] Also=pcscd.socket</p>
<h2 id="systemctl-enable上面这个service会做什么-enable之后开机此服务会启动吗">systemctl
enable上面这个service会做什么？ enable之后开机此服务会启动吗</h2>
<p>这个服务单元的作用是启动 PC/SC 智能卡守护进程（PC/SC Smart Card
Daemon），并将其设置为开机自动启动。</p>
<p>具体来说，在 <code>[Service]</code> 部分中，指定了 PC/SC
智能卡守护进程的启动命令，即
<code>/usr/sbin/pcscd --foreground --auto-exit</code>。<code>--foreground</code>参数指定该服务以前台模式启动（即不以守护进程的方式运行），而
<code>--auto-exit</code>
参数指定当没有智能卡连接到系统时，服务将自动退出。</p>
<p>在 <code>[Install]</code> 部分中，使用了
<code>Also=pcscd.socket</code> 来指示 systemd 同时启用
<code>pcscd.socket</code> socket 服务单元。这表示当
<code>pcscd.service</code> 服务单元启动时，同时也会启动
<code>pcscd.socket</code> 服务单元。<code>pcscd.socket</code> 负责监听
PC/SC 客户端的连接请求，因此 <code>pcscd.service</code>
是一个被动的服务单元，它依赖于 <code>pcscd.socket</code>
服务单元的启动，以接受客户端连接请求。</p>
<p>当你运行 <code>systemctl enable pcscd.service</code>
命令启用此服务单元时，它将在
<code>/etc/systemd/system/multi-user.target.wants</code>
目录下创建一个符号链接，指向该服务单元文件。这将导致
<code>pcscd.service</code> 服务单元在系统启动时自动启动，并同时启动
<code>pcscd.socket</code> 服务单元。</p>
<p>因此，如果你启用了 <code>pcscd.service</code>
服务单元，则在下次系统启动时，该服务将自动启动，并以前台模式运行 PC/SC
智能卡守护进程，同时启动 <code>pcscd.socket</code> 服务单元，以便监听
PC/SC 客户端的连接请求。</p>
<h2 id="audit审计">audit审计：</h2>
<p>https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-defining_audit_rules_and_controls</p>
<p>1、查看进程被谁杀死：</p>
<p>sudo apt install auditd systemctl enable auditd.service systemctl
restart auditd.service 然后通过auditctrl添加规则： auditctl -a
exit,always -F arch=b64 -S kill -F a1=9（好像auditctl -a exit,always -S
kill就行了，-F参数表示额外匹配，这里选择匹配系统调用的第一个参数，参数内容是要监控进程的PID(这里要用16进制)。）
启动然后kill掉Python程序; 查看日志，即可发现kill发起的程序和用户；</p>
<p>sudo ausearch -sc kill</p>
<p>日志如下：</p>
<p>time-&gt;Thu Feb 24 04:00:08 2022</p>
<p>type=PROCTITLE msg=audit(1645675208.403:201): proctitle="htop"</p>
<p>type=OBJ_PID msg=audit(1645675208.403:201): opid=40099 oauid=1016
ouid=1016 oses=12951 obj==unconfined ocomm="nvtop"</p>
<p>type=SYSCALL msg=audit(1645675208.403:201): arch=c000003e syscall=62
success=yes exit=0 a0=9ca3 a1=9 a2=c1 a3=8 items=0 ppid=45939 pid=40129
auid=1016 uid=1016 gid=1016 euid=1016 suid=1016 fsuid=1016 egid=1016
sgid=1016 fsgid=1016 tty=pts4 ses=18035 comm="htop" exe="/usr/bin/htop"
subj==unconfined key=(null)</p>
<p>type=OBJ_PID 那一列是杀进程的命令（ocomm="nvtop" ）</p>
<p>type=SYSCALL 那一列是kill的调用者详情和系统命名码（syscall=62 ）</p>
<p>2、查看文件被谁删除</p>
<p>在/etc/audit/rules.d/audit.rules加上以下两行: -a always,exit -F
arch=b32 -S unlink -S unlinkat -S rename -S renameat -S rmdir -k delete
-a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat
-S rmdir -k delete</p>
<p>然后重启auditd服务:</p>
<p>systemctl restart auditd</p>
<p>检查规则是否生效:</p>
<p># auditctl -l -a always,exit -F arch=b32 -S
unlink,rename,rmdir,unlinkat,renameat -F key=delete -a always,exit -F
arch=b64 -S rename,rmdir,unlink,unlinkat,renameat -F key=delete</p>
<p>然后检查/var/log/audit/audit.log即可看到什么文件被什么程序删除</p>
<p>3、查看谁使用了某个文件</p>
<p>service auditd start</p>
<p>auditctl -w /proc/sys/vm/drop_caches -p rwxa （-w表示使用watch功能，
要watch的文件为 /proc/sys/vm/drop_caches，
观察的事件为文件的读写执行。通过man auditctl 可以知道，
audit是通过内核里面hook open系统调用实现的该功能。， -W是删除）</p>
<p>ausearch -f /proc/sys/vm/drop_caches</p>
<p>1.查看信息： 输入以下程序：</p>
<p>dmesg | egrep -i -B100 'killed process'
可以输出最近killed的信息。</p>
<p>2.设定kill优先度： （1）完全关掉oom（不建议）： sysctl
vm.overcommit_memory=2 echo “vm.overcommit_memory=2” &gt;&gt;
/etc/sysctl.conf （2）出现 Out of memory之后重启： sysctl
vm.panic_on_oom=1 sysctl kernel.panic=X echo “vm.panic_on_oom=1”
&gt;&gt; /etc/sysctl.conf echo “kernel.panic=X” &gt;&gt;
/etc/sysctl.conf （3）优先考虑kill这个进程： sudo echo
10&gt;/proc/[PID]/oom_adj （4）尽量不去kill这个进程： sudo echo
-15&gt;/proc/[PID]/oom_adj （5）不会kill这个进程： sudo echo
-17&gt;/proc/[PID]/oom_adj oom_adj的值在-16 到
+15之间，值越高被kill的优先度越高。当该值为-17时，系统将不会杀死指定pid的进程，而-16~15则会使得进程的/proc/[pid]/oom_adj值呈指数（）形式递增，即它们被杀掉的可能性呈指数递增。针对init（进程号为1）这个进程，无论该值设为多少都不会被杀。</p>
<p>3.若拒绝访问： 命令改为：</p>
<p>bash -c "echo '10' | tee /proc/[PID]/oom_adj" bash -c "echo '-15' |
tee /proc/[PID]/oom_adj" bash -c "echo '-17' | tee
/proc/[PID]/oom_adj"</p>
<h2 id="手动修改etcshadow中的用户密码">1.<a target="_blank" rel="noopener" href="http://www.cppblog.com/mydriverc/archive/2009/10/09/98196.html?spm=a2c6h.12873639.article-detail.4.28085ae6QTkYWD">手动修改/etc/shadow中的用户密码</a></h2>
<p>/etc/shadow文件</p>
<p>第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd
是相同的，这样就把passwd
和shadow中用的用户记录联系在一起；这个字段是非空的；
第二字段：密码（已被加密），这个字段是非空的；
第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），您可以通过passwd
来修改用户的密码，然后查看/etc/shadow中此字段的变化；
第四字段：两次修改口令间隔最少的天数；如果这个字段的值为空，帐号永久可用；</p>
<p>第五字段：两次修改口令间隔最多的天数；如果这个字段的值为空，帐号永久可用；</p>
<p>第六字段：提前多少天警告用户口令将过期；如果这个字段的值为空，帐号永久可用；</p>
<p>第七字段：在口令过期之后多少天禁用此用户；如果这个字段的值为空，帐号永久可用；</p>
<p>第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用；
第九字段：保留字段，目前为空，以备将来发展之用；</p>
<p>/etc/shadow中格式如下 #testaccount:<strong><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></span>acQMceF9$1SaCpG2qiKKA3eGolU4Fp0</strong>:13402:0:99999:7:::
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></span>acQMceF9$1SaCpG2qiKKA3eGolU4Fp0段为加密后的密码，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></span>表示采用的是md5加密，acQMceF9$是简单的字符串，1SaCpG2qiKKA3eGolU4Fp0为加密后的密码</p>
<p>只要删除 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></span>acQMceF9$1SaCpG2qiKKA3eGolU4Fp0
它后，就删除了密码</p>
<p>2.linux忘记登陆密码修改/etc/passwd也可以</p>
<p>很简单的一个技巧，给大家介绍一下 在这个界面 按任意键 按
e键(编辑命令之前启动) 选择第二项 在按e键(修改选定的命令在启动)
输入single (注意空格)进入单用户模式 选择b 启动 输入 vi /etc/passwd
root❌0:0:root:/root:/bin/bash 光标移至x下面按delete 键 删除它 输入：x！
输入reboot重启 重启后你会发现 没让你输密码，破译成功</p>
<p>原理解释： 在 /etc/passwd 的文件里 保存着用户的信息文件
root❌0:0:Administrator:/root:/bin/bash</p>
<p>在这一句中</p>
<p>root就是用户名，</p>
<p>x是密码标志，只是说明密码的存放位置，具体呢是放在/etc/passwd的
至于密码别想了 全 是密文保存，看不懂的</p>
<p>0 用户id号</p>
<p>0 组id号</p>
<p>administrator估计是我在装系统的时候，原来的名字没改（虚拟机默认用户名），是用户说
明的意思，</p>
<p>root 用户的家目录</p>
<p>/bin/bash 记录着用户登陆后所拥有的权限，即所拥有的shell</p>
<p>那么我们把密码标示删掉之后，自然就不会有问你密码的对话框了</p>
<p>当然</p>
<p>GRUB这个引导装载程序是可以设密码的</p>
<p>不过 设密码 我们可以光启 ，用安装光盘进入安全模式，在把密码清除</p>
<p>光启 是可以设BIOS密码的，</p>
<p>BIOS 密码是可以拆机箱 扣电池的</p>
<p>那这么说来 传说中的linux岂不是很不安全，通常所说的安全是基于网络的
，意思是连接互联网后，对方通过网络途径入侵你的linux计算机是很困难的，这种破译的方法只是以防万一，在万一你忘记密码的时候使用的，至于物理安全，那就看你怎么保护了.</p>
<h1 id="gdb调试宏定义并显示宏定义的值">gdb调试宏定义并显示宏定义的值</h1>
<p>https://blog.csdn.net/zhangjs0322/article/details/39666889</p>
<p>编译时需添加-gdwarf-2和-g3两个参数。</p>
<p>加了-g3的参数后，gcc编译的时候，会将扩展的debug
信息编译进二进制文件里面，包括宏定义信息。</p>
<h2 id="linux-aclaccess-control-list访问控制权限列表">Linux ACL(access
control list)访问控制权限列表</h2>
<p>在普通权限中，用户对文件只有三种身份，就是属主、属组和其他人；每种用户身份拥有读（read）、写（write）和执行（execute）三种权限。但是在实际工作中，这三种身份实在是不够用，我们举个例子来看看。</p>
<p>图 1 ACL权限简介</p>
<figure>
<img src="file:////tmp/wps-altnt/ksohtml/wpsEA32ZO.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>图 1 的根目录中有一个 /project
目录，这是班级的项目目录。班级中的每个学员都可以访问和修改这个目录，老师也需要对这个目录拥有访问和修改权限，其他班级的学员当然不能访问这个目录。需要怎么规划这个目录的权限呢？应该这样：老师使用
root 用户，作为这个目录的属主，权限为 rwx；班级所有的学员都加入 tgroup
组，使 tgroup 组作为 /project 目录的属组，权限是 rwx；其他人的权限设定为
0。这样这个目录的权限就可以符合我们的项目开发要求了。</p>
<p>有一天，班里来了一位试听的学员 st，她必须能够访问 /project
目录，所以必须对这个目录拥有 r 和 x
权限；但是她又没有学习过以前的课程，所以不能赋予她 w
权限，怕她改错了目录中的内容，所以学员 st 的权限就是
r-x。可是如何分配她的身份呢？变为属主？当然不行，要不 root
该放哪里？加入 tgroup 组？也不行，因为 tgroup 组的权限是
rwx，而我们要求学员 st 的权限是 r-x。如果把其他人的权限改为 r-x
呢？这样一来，其他班级的所有学员都可以访问 /project 目录了。</p>
<p>当出现这种情况时，普通权限中的三种身份就不够用了。ACL
权限就是为了解决这个问题的。在使用 ACL 权限给用户 st 陚予权限时，st
既不是 /project 目录的属主，也不是属组，仅仅赋予用户 st 针对此目录的 r-x
权限。这有些类似于 Windows
系统中分配权限的方式，单独指定用户并单独分配权限，这样就解决了用户身份不足的问题。</p>
<p>ACL是Access Control
List（访问控制列表）的缩写，不过在Linux系统中，ACL用于设定用户针对文件的权限，而不是在交换路由器中用来控制数据访问的功能（类似于防火墙）。</p>
<p><strong>开启ACL权限在 CentOS 6.x 系统中 ACL
权限默认是开启的，不需要手工开启。不过，如果你的操作系统不是 CentOS
6.x，那该如何查看 ACL 权限是否开启了呢？可以这样查看：</strong></p>
<p>[root@localhost ~]# mount</p>
<p>/dev/sda1 on /boot type ext4 (rw)</p>
<p>/dev/sda3 on I type ext4 (rw)</p>
<p>…省略部分输出…</p>
<p>#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</p>
<p>[root@localhost ~]# dumpe2fs -h /dev/sda3</p>
<p>#dumpe2fs是查询指定分区文件系统详细信息的命令</p>
<p>…省略部分输出…</p>
<p>Default mount options: user_xattr acl</p>
<p>…省略部分输出…其中，dumpe2fs 命令可选的选项及其含义如下：</p>
<p>-h：仅显示超级块中的信息，而不显示磁盘块组的详细信息；</p>
<p>使用 mount 命令可以査看到系统中已经挂载的分区，而使用 dumpe2fs
命令可以査看到这个分区文件系统的详细信息。大家可以看到，我们的 ACL
权限是 /dev/sda3 分区的默认挂载选项，所以不需要手工挂载。</p>
<p>不过我的 Linux
系统如果没有默认挂载，则可以手工挂载吗？当然可以，执行如下命令：</p>
<p>[root@localhost ~]# mount -o remount, acl /</p>
<p>#重新挂载根分区，并加入ACL权限使用 mount 命令重新挂载，并加入 ACL
权限。不过使用此命令是临时生效的。要想永久生效，需要修改 /etc/fstab
文件，命令如下：</p>
<p>[root@localhost ~]#vi /etc/fstab</p>
<p>UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 /ext4 defaults, acl 1 1</p>
<p>#加入ACL权限</p>
<p>[root@localhost ~]# mount -o remount /</p>
<p>#重新挂载文件系统或重启系统，使修改生效在你需要开启 ACL
权限的分区行上（也就是说 ACL 权限针对的是分区），手工在 defaults
后面加入"，acl"即可永久在此分区中开启 ACL 权限。</p>
<p><strong>ACL权限设置</strong></p>
<p><strong>1) ACL权限管理命令我们知道了 ACL 权限的作用，也知道了如何开启
ACL 权限，接下来学习如何査看和设定 ACL 权限。命令如下：</strong></p>
<p>[root@localhost ~]# getfacle 文件名</p>
<p>#查看ACL权限</p>
<p>[root@localhost ~]# setfacl 选项 文件名</p>
<p>#设定ACL权限选项：</p>
<p>-m：设定 ACL 权限。如果是给予用户 ACL
权限，则使用"u:用户名：权限"格式赋予；如果是给予组 ACL
权限，则使用"g:组名：权限" 格式赋予；</p>
<p>-x：删除指定的 ACL 权限；</p>
<p>-b：删除所有的 ACL 权限；</p>
<p>-d：设定默认 ACL
权限。只对目录生效，指目录中新建立的文件拥有此默认权限；</p>
<p>-k：删除默认 ACL 权限；</p>
<p>-R：递归设定 ACL 权限。指设定的 ACL
权限会对目录下的所有子文件生效；</p>
<p><strong>2) 给用户和用户组添加ACL权限举个例子，就来看看图 1
中的权限怎么分配。我们要求 root 是 /project 目录的属主，权限是
rwx；tgroup 是此目录的属组，tgroup 组中拥有班级学员 zhangsan 和
lisi，权限是 rwx；其他人的权限是 0。这时，试听学员 st 来了，她的权限是
r-x。我们来看具体的分配命令。</strong></p>
<p>[root@localhost ~]# useradd zhangsan</p>
<p>[root@localhost ~]# useradd lisi</p>
<p>[root@localhost ~]# useradd st</p>
<p>[root@localhost ~]# groupadd tgroup</p>
<p>#添加需要试验的用户和用户组，省略设定密码的过程</p>
<p>[root@localhost ~]# mkdir /project #建立需要分配权限的目录</p>
<p>[root@localhost ~]# chown root:tgroup /project/</p>
<p>#改变/project目录的属主和属组</p>
<p>[root@localhost ~]# chmod 770 /project/</p>
<p>#指定/project目录的权限</p>
<p>[root@localhost ~]# ll -d /project/</p>
<p>drwxrwx--- 2 root tgroup 4096 1月19 04:21 /project/</p>
<p>#查看一下权限，已经符合要求了</p>
<p>#这时st学员来试听了，如何给她分配权限</p>
<p>[root@localhost ~]# setfacl -m u:st:rx /project/</p>
<p>#给用户st赋予r-x权限，使用"u:用户名：权限" 格式</p>
<p>[root@localhost /]# cd /</p>
<p>[root@localhost /]# ll -d project/</p>
<p>drwxrwx---+ 3 root tgroup 4096 1月19 05:20 project/</p>
<p>#使用ls-l査询时会发现，在权限位后面多了一个"+"，表示此目录拥有ACL权限</p>
<p>[root@localhost /]# getfacl project</p>
<p>#查看/prpject目录的ACL权限</p>
<p>#file: project &lt;-文件名</p>
<p>#owner: root &lt;-文件的属主</p>
<p>#group: tgroup &lt;-文件的属组</p>
<p>user::rwx &lt;-用户名栏是空的，说明是属主的权限</p>
<p>user:st:r-x &lt;-用户st的权限</p>
<p>group::rwx &lt;-组名栏是空的，说明是属组的权限</p>
<p>mask::rwx &lt;-mask权限</p>
<p>other::--- &lt;-其他人的权限大家可以看到，st 用户既不是 /prpject
目录的属主、属组，也不是其他人，我们单独给 st 用户分配了 r-x
权限。这样分配权限太方便了，完全不用先辛苦地规划用户身份了。</p>
<p>我想给用户组赋予 ACL 权限可以吗？当然可以，命令如下：</p>
<p>[root@localhost /]# groupadd tgroup2</p>
<p>#添加测试组</p>
<p>[root@localhost /]# setfacl -m g:tgroup2:rwx project/</p>
<p>#为组tgroup2纷配ACL权限，使用"g:组名:权限"格式</p>
<p>[root@localhost /]# ll -d project/</p>
<p>drwxrwx---+ 2 root tgroup 4096 1月19 04:21 project/</p>
<p>#属组并没有更改</p>
<p>[root@localhost /]# getfacl project/</p>
<p>#file: project/</p>
<p>#owner: root</p>
<p>#group: tgroup</p>
<p>user::rwx</p>
<p>user:st:r-x</p>
<p>group::rwx</p>
<p>group:tgroup2:rwx &lt;-用户组tgroup2拥有了rwx权限</p>
<p>mask::rwx</p>
<p>other::--</p>
<p><strong>3) 最大有效权限maskmask 是用来指定最大有效权限的。mask
的默认权限是 rwx，如果我给 st 用户赋予了 r-x 的 ACL 权限，mj 需要和 mask
的 rwx 权限"相与"才能得到 st 的真正权限，也就是 r-x "相与"rwxtj 出的值是
r-x，所以 st 用户拥有 r-x 权限。</strong></p>
<p>如果把 mask 的权限改为 r--，和 st 用户的权限相与，也就是 r--"相与"r-x
得出的值是 r--，st
用户的权限就会变为只读。大家可以这么理解：用户和用户组所设定的权限必须在
mask 权限设定的范围之内才能生效，mask权限就是最大有效权限。</p>
<p>不过我们一般不更改 mask 权限，只要给予 mask 最大权限
rwx，那么任何权限和 mask
权限相与，得出的值都是权限本身。也就是说，我们通过给用户和用户组直接赋予权限，就可以生效，这样做更直观。</p>
<p>补充：逻辑与运算的运算符是"and"。可以理解为生活中所说的"并且"。也就是相与的两个值都为真，结果才为真；有一个值为假，与的结果就为假。比如
A 相与 B，结果入表 2 所示。</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>真</td>
<td>真</td>
<td>真</td>
</tr>
<tr>
<td>真</td>
<td>假</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>真</td>
<td>假</td>
</tr>
<tr>
<td>假</td>
<td>假</td>
<td>假</td>
</tr>
</tbody>
</table>
<p>那么两个权限相与和上面的结果类似，我们以读（r）权限为例，结果如表 3
所示。</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>and</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>r</td>
<td>r</td>
</tr>
<tr>
<td>r</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>r</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>所以，"rwx"相与"r-x"，结果是"r-x"；"r--"相与"r-x"，结果是"r--"。</p>
<p>修改最大有效权限的命令如下：</p>
<p>[root@localhost /]# setfacl -m m:rx project/</p>
<p>#设定mask权限为r-x，使用"m:权限"格式</p>
<p>[root@localhost /]# getfacl project/</p>
<p>#file：project/</p>
<p>#owner：root</p>
<p>#group：tgroup</p>
<p>user::rwx</p>
<p>group::rwx #effective:r-x</p>
<p>mask::r-x</p>
<p>#mask权限变为r-x</p>
<p>other::--</p>
<p><strong>4) 默认ACL权限和递归ACL权限我们已经给 /project 目录设定了 ACL
权限，那么，在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的
ACL 权限呢？我们试试吧。</strong></p>
<p>[root@localhost /]# cd /project/</p>
<p>[root@localhost prq'ect]# touch abc</p>
<p>[root@localhost prq'ect]# mkdir d1</p>
<p>#在/project目录中新建了abc文件和d1目录</p>
<p>[root@localhost project]#ll</p>
<p>总用量4</p>
<p>-rw-r--r-- 1 root root 01月19 05:20 abc</p>
<p>drwxr-xr-x 2 root root 4096 1月19 05:20 d1</p>
<p>#这两个新建立的文件权限位后面并没有"+"，表示它们没有继承ACL权限子文件
abc 和子目录 d1 因为是后建立的，所以并没有继承父目录的 ACL
权限。当然，我们可以手工给这两个文件分配 ACL
权限，但是如果在目录中再新建文件，都要手工指定，则显得过于麻烦。这时就需要用到默认
ACL 权限。</p>
<p>默认 ACL 权限的作用是：如果给父目录设定了默认 ACL
权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。默认 ACL
权限只对目录生效。命令如下：</p>
<p>[root@localhost /]# setfacl -m d:u:st:rx /project/</p>
<p>#使用"d:u:用户名：权限"格式设定默认ACL权限</p>
<p>[root@localhost project]# getfacl project/</p>
<p># file: project/</p>
<p># owner: root</p>
<p># group: tgroup</p>
<p>user:: rwx</p>
<p>user:st:r-x</p>
<p>group::rwx</p>
<p>group:tgroup2:rwx</p>
<p>mask::rwx</p>
<p>other::--</p>
<p>default:user::rwx &lt;-多出了default字段</p>
<p>default:user:st:r-x</p>
<p>default:group::rwx</p>
<p>default😷:rwx</p>
<p>default:other::--</p>
<p>[root@localhost /]# cd project/</p>
<p>[root@localhost project]# touch bcd</p>
<p>[root@localhost project]# mkdir d2</p>
<p>#新建子文件和子目录</p>
<p>[root@localhost project]# ll 总用量8</p>
<p>-rw-r--r-- 1 root root 01月19 05:20 abc</p>
<p>-rw-rw----+ 1 root root 01月19 05:33 bcd</p>
<p>drwxr-xr-x 2 root root 4096 1月19 05:20 d1</p>
<p>drwxrwx---+ 2 root root 4096 1月19 05:33 d2</p>
<p>#新建的bcd和d2已经继承了父目录的ACL权限大家发现了吗？原先的 abc 和 d1
还是没有 ACL 权限，因为默认 ACL 权限是针对新建立的文件生效的。</p>
<p>再说说递归 ACL 权限。递归是指父目录在设定 ACL
权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p>
<p>[root@localhost project]# setfacl -m u:st:rx -R/project/</p>
<p>#-R递归</p>
<p>[root@localhost project]# ll</p>
<p>总用量8</p>
<p>-rw-r-xr--+ 1 root root 01月19 05:20 abc</p>
<p>-rw-rwx--+ 1 root root 01月19 05:33 bcd</p>
<p>drwxr-xr-x+ 2 root root 4096 1月19 05:20 d1</p>
<p>drwxrwx--+ 2 root root 4096 1月19 05:33 d2</p>
<p>#abc和d1也拥有了ACL权限总结一下：默认 ACL
权限指的是针对父目录中新建立的文件和目录会继承父目录的 ACL
权限，格式是"setfacl-m d:u:用户名：权限 文件名"；递归 ACL
权限指的是针对父目录中已经存在的所有子文件和子目录继承父目录的 ACL
权限，格式是"setfacl-m u:用户名： 权限 -R 文件名"。</p>
<p><strong>5) 删除ACL权限我们来看看怎么删除 ACL
权限，命令如下：</strong></p>
<p>删除指定的ACL权限：</p>
<p>[root@localhost /]# setfacl -x u:st /project/</p>
<p>#删除指定用户和用户组的ACL权限</p>
<p>[root@localhost /]# getfacl project/</p>
<p># file:project/</p>
<p># owner: root</p>
<p># group: tgroup</p>
<p>user::rwx</p>
<p>group::rwx</p>
<p>group:tgroup2:rwx</p>
<p>mask::rwx</p>
<p>other::--</p>
<p>#st用户的权限已被删除</p>
<p>删除所有ACL权限：</p>
<p>[root@localhost /]# setfacl -b project/</p>
<p>#会删除文件的所有ACL权限</p>
<p>[root@localhost /]# getfacl project/</p>
<p>#file: project/</p>
<p>#owner: root</p>
<p># group: tgroup</p>
<p>user::rwx</p>
<p>group::rwx</p>
<p>other::--</p>
<p>#所有ACL权限已被删除</p>
<h2 id="丁昊的笔记">丁昊的笔记：</h2>
<p>丁昊 2-3 20:16:37 https://note.youdao.com/s/Pc3xVfF3 PXE安装</p>
<p>丁昊 2-3 20:20:54 https://note.youdao.com/s/FuARzknP</p>
<p>丁昊 2-3 20:21:18 https://note.youdao.com/s/EREk5WMt</p>
<p>丁昊 2-3 20:21:35 https://note.youdao.com/s/3CazyEHa</p>
<h2 id="tmux教程">tmux教程</h2>
<h3 id="新建会话">新建会话</h3>
<p><code>tmux new -s &lt;session-name&gt;</code></p>
<h3 id="分离会话退出当前-tmux-窗口但是会话和里面的进程仍然在后台运行">分离会话(退出当前
Tmux 窗口，但是会话和里面的进程仍然在后台运行)</h3>
<p>在 Tmux 窗口中，按下 <code>Ctrl+b d</code>或者输入
<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux detach</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令执行后，就会退出当前 Tmux
窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ tmux list-session</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="杀死会话">杀死会话</h3>
<p><code>tmux kill-session</code>命令用于杀死某个会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用会话编号</span></span><br><span class="line">$ tmux kill-session -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称</span></span><br><span class="line">$ tmux kill-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="切换会话">切换会话</h3>
<p><code>tmux switch</code>命令用于切换会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用会话编号</span></span><br><span class="line">$ tmux switch -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称</span></span><br><span class="line">$ tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="重命名会话">重命名会话</h3>
<p><code>tmux rename-session</code>命令用于重命名会话。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将0号会话重命名。</p>
<h3 id="关闭所有会话">关闭所有会话：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill</span><br></pre></td></tr></table></figure>
<h3 id="会话快捷键">会话快捷键</h3>
<p>下面是一些会话相关的快捷键。</p>
<blockquote>
<ul>
<li><code>Ctrl+b d</code>：分离当前会话。</li>
<li><code>Ctrl+b s</code>：列出所有会话。</li>
<li><code>Ctrl+b $</code>：重命名当前会话。</li>
<li>Ctrl+b %：划分左右两个窗格。 Ctrl+b "：划分上下两个窗格。 Ctrl+b
<code>&lt;arrow key&gt;</code>：光标切换到其他窗格。 Ctrl+b
;：光标切换到上一个窗格。 Ctrl+b o：光标切换到下一个窗格。 Ctrl+b
{：当前窗格与上一个窗格交换位置。 Ctrl+b
}：当前窗格与下一个窗格交换位置。 Ctrl+b
Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b
Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b
x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b
z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b
Ctrl+<code>&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。 Ctrl+b
q：显示窗格编号。</li>
</ul>
<p><strong>窗格滚动快捷键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+b pageUp：向上滚动窗格。</span><br><span class="line">Ctrl+b pageDown：向下滚动窗格。</span><br></pre></td></tr></table></figure>
<p>进入窗格滚动模式后，使用鼠标滚轮可上下移动光标。 此模式下，输入快捷键
<code>q</code> 即可退出滚动模式。</p>
</blockquote>
<h2 id="tmux文本复制模式">tmux文本复制模式</h2>
<table>
<thead>
<tr>
<th><code>Ctrl+b</code></th>
<th><code>[</code></th>
<th>进入复制模式，按 <code>q</code>退出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl+b</code></td>
<td><code>]</code></td>
<td>粘贴复制模式中复制的文本</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>按下三个按键进入文本复制模式 CTRL + b + [</li>
<li>按下 空格 按键进入文本开始复制的起始位置</li>
<li>上下左右键选择要复制的文本</li>
<li>选中了要复制的文本后，按下 Enter
按键，将文本保存到tmux的buffer中</li>
<li>按下三个按键将文本粘贴到某处 CTRL + b + ]</li>
</ol>
<h3 id="将上面缓冲区内的内容自动复制到系统剪切板">将上面缓冲区内的内容自动复制到系统剪切板</h3>
<h4 id="macos">macos</h4>
<p>将下面的内容添加到~/.tmux.conf(<strong>这个方法是我自己想的,因为
<code>-X copy-pipe-and-cancel</code> 是 Tmux 中 <code>bind-key</code>
命令的一个参数选项，它的作用是在执行复制操作时，将所选内容通过管道传递给外部命令（在这里是
<code>pbcopy</code>），并在复制完成后取消复制模式。</strong>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set-window-option -g mode-keys vi</span><br><span class="line">bind -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel "pbcopy"</span><br></pre></td></tr></table></figure>
<p>而macOS自带了 pbcopy 和 pbpaste
命令，用于与剪贴板进行交互。要将命令的输出复制到剪贴板，可以使用管道 |
将命令的输出传递给 pbcopy。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your-command | pbcopy</span><br></pre></td></tr></table></figure>
<p>这将把命令的输出复制到剪贴板，您可以随后使用粘贴操作（通常是Command +
V）将其粘贴到其他地方。</p>
<p>使用echo和重定向：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo "Hello, World" | pbcopy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这将 “Hello, World” 复制到剪贴板。</p>
<p>在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p>
<p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f
键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F
键达到相反的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vi             emacs        功能</span><br><span class="line">^              M-m          反缩进</span><br><span class="line">Escape         C-g          清除选定内容</span><br><span class="line">Enter          M-w          复制选定内容</span><br><span class="line">j              Down         光标下移</span><br><span class="line">h              Left         光标左移</span><br><span class="line">l              Right        光标右移</span><br><span class="line">L                           光标移到尾行</span><br><span class="line">M              M-r          光标移到中间行</span><br><span class="line">H              M-R          光标移到首行</span><br><span class="line">k              Up           光标上移</span><br><span class="line">d              C-u          删除整行</span><br><span class="line">D              C-k          删除到行末</span><br><span class="line">$              C-e          移到行尾</span><br><span class="line">:              g            前往指定行</span><br><span class="line">C-d            M-Down       向下滚动半屏</span><br><span class="line">C-u            M-Up         向上滚动半屏</span><br><span class="line">C-f            Page down    下一页</span><br><span class="line">w              M-f          下一个词</span><br><span class="line">p              C-y          粘贴</span><br><span class="line">C-b            Page up      上一页</span><br><span class="line">b              M-b          上一个词</span><br><span class="line">q              Escape       退出</span><br><span class="line">C-Down or J    C-Down       向下翻</span><br><span class="line">C-Up or K      C-Up         向下翻</span><br><span class="line">n              n            继续搜索</span><br><span class="line">?              C-r          向前搜索</span><br><span class="line">/              C-s          向后搜索</span><br><span class="line">0              C-a          移到行首</span><br><span class="line">Space          C-Space      开始选中</span><br><span class="line">               C-t          字符调序</span><br></pre></td></tr></table></figure>
<h4 id="linux">linux</h4>
<p>将下面的内容添加到~/.tmux.conf(<strong>这个我还没测试,不过我看没有问题,至于为什么mac不用xsel和xclip命令,是因为会报错“xsel:
Can't open display: (null) : Connection refused”</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set-window-option -g mode-keys vi</span><br><span class="line">bind -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel "xsel -i --clipboard"</span><br><span class="line">或者</span><br><span class="line">bind -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel "xclip -i -f -selection primary | xclip -i -selection clipboard"</span><br></pre></td></tr></table></figure>
<h2 id="ubuntu-tmux-启用鼠标滚动">Ubuntu Tmux 启用鼠标滚动</h2>
<p>在Ubuntu上使用Tmux是一件非常舒服的事，但有时使用鼠标滚轮时，和平时使用终端的习惯不怎么一致，因此可以设置启用鼠标滚轮。
具体方式： 按完前缀ctrl+B后，再按冒号：进入命令行模式，
输入以下命令：</p>
<p>set -g mouse on 1
就启用了鼠标滚轮，可以通过鼠标直接选择不同的窗口，也可以上下直接翻页。</p>
<p>Tip 但在以上设置下，会发现无法用中键向 tmux 中复制文本，也无法将 tmux
中选择好的文本中键复制到系统其他应用程序中。 这里有一个 trick，那就是在
tmux 中不论选择还是复制时，都按住 Shift 键，你会发现熟悉的中键又回来了 ?
此外，还可以使用 Shift+Insert 快捷键将系统剪切板中的内容输入 tmux 中。
相对于 tmux 原生的选择模式（不加 shift
键），使用系统选择有个缺陷，即当一行内存在多个面板时，无法选择单个面板中的内容，这时就必须使用
tmux 自带的复制粘贴系统了。</p>
<h2 id="qemu虚拟机的配置文件">qemu虚拟机的配置文件：</h2>
<p>在/etc/libvirt目录下，可以修改虚拟机路径等</p>
<p>修改好了好需要执行systemctl restart libvirtd.service</p>
<h2 id="my_log_info">my_log_info:</h2>
<p>void my_log_info(const char <em>fmt,...) { FILE</em> g_log_FP =
fopen("/tmp/1.log","a"); if (g_log_FP != 0) { va_list ap; va_start(ap,
fmt); vfprintf(g_log_FP, fmt, ap); va_end(ap); //fflush(g_log_FP);
fclose(g_log_FP); } }</p>
<p>udev读block块设备容量读的是/sys/devices/pci0000:00/0000:00:0a.0/virtio3/block/vdb/size
这种接口文件</p>
<h1 id="c语言打印函数堆栈方法">C语言打印函数堆栈方法</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#define STACK_SIZE 32</span><br><span class="line"></span><br><span class="line">static void printStack(void)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	void *trace[STACK_SIZE];</span><br><span class="line">	size_t size = backtrace(trace, STACK_SIZE);</span><br><span class="line">	char **symbols = (char **)backtrace_symbols(trace,size);</span><br><span class="line">	size_t i = 0;</span><br><span class="line">	for(; i&lt;size; i++)</span><br><span class="line">	{</span><br><span class="line">		printf("%ld---&gt;%s\n", i, symbols[i]);           //注意这个得改</span><br><span class="line">	}</span><br><span class="line">	return;</span><br><span class="line">}</span><br><span class="line">static void printStack(void)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	void *trace[STACK_SIZE];</span><br><span class="line">	size_t size = backtrace(trace, STACK_SIZE);</span><br><span class="line">	char **symbols = (char **)backtrace_symbols(trace,size);</span><br><span class="line">	size_t i = 0;</span><br><span class="line">	for(; i&lt;size; i++)</span><br><span class="line">	{</span><br><span class="line">		log_error("ly---%ld---&gt;%s\n", i, symbols[i]);           //注意这个得改</span><br><span class="line">	}</span><br><span class="line">	return;</span><br><span class="line">}</span><br><span class="line">static void printStack(void)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    void *bt[50];</span><br><span class="line">    int bt_size;</span><br><span class="line">    char **bt_syms;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    bt_size = backtrace(bt, 50);</span><br><span class="line">    bt_syms = backtrace_symbols(bt, bt_size);</span><br><span class="line">    for (i = 0; i &lt; bt_size; i++) {</span><br><span class="line">        Dl_info info;</span><br><span class="line">        if (dladdr(bt[i], &amp;info) &amp;&amp; info.dli_sname) {</span><br><span class="line">            log_error("ly---%d--%s", i, info.dli_sname);</span><br><span class="line">        } else {</span><br><span class="line">            log_error("ly---%d--%s\n", i,bt_syms[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    free(bt_syms);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这个错误提示是缺少动态链接库 libdl.so.2，可以尝试LDFLAGS加上 -ldl
参数来链接该库(改完之后得删掉原来的二进制文件)</p>
<p>#include &lt;execinfo.h&gt; #include &lt;dlfcn.h&gt;</p>
<p>static void print_backtrace(void) { void *bt[50]; int bt_size; char
**bt_syms; int i;</p>
<pre><code>bt_size = backtrace(bt, 50);
bt_syms = backtrace_symbols(bt, bt_size);
for (i = 0; i &lt; bt_size; i++) {
    Dl_info info;
    if (dladdr(bt[i], &amp;info) &amp;&amp; info.dli_sname) {
        printf("%s\n", info.dli_sname);
    } else {
        printf("???\n");
    }
}
free(bt_syms);</code></pre>
<p>}</p>
<h2 id="内网仓库">内网仓库：</h2>
<p>http://pools.uniontech.com/desktop-professional/pool/main/p/python-netaddr/</p>
<h2 id="blkid--l--t-uuid9cd72106-5e81-4860-a8e1-8285bc74a5ac--o-device">blkid
-l -t "UUID=9cd72106-5e81-4860-a8e1-8285bc74a5ac" -o device</h2>
<p>首先读/run/blkid/blkid.tab缓存文件，如果能找到直接返回</p>
<p>否则通过realpath(/dev/disk/by-uuid/af467362-9f82-4219-808f-fb23ca11a4ea)找到对应设备</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403181751780.png" alt="image-20230403181751780">
<figcaption aria-hidden="true">image-20230403181751780</figcaption>
</figure>
<p>realpath实际就是找/dev/disk/by-uuid/af467362-9f82-4219-808f-fb23ca11a4ea的软链接</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403181959316.png" alt="image-20230403181959316">
<figcaption aria-hidden="true">image-20230403181959316</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403181616823.png" alt="image-20230403181616823">
<figcaption aria-hidden="true">image-20230403181616823</figcaption>
</figure>
<h2 id="usrlibklibcbinfstype原理">/usr/lib/klibc/bin/fstype原理：</h2>
<p>搞一个静态数组然后遍历它，如果ip-&gt;identify能识别独处的
超级块，则返回对应的ip-&gt;name</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403184655148.png" alt="image-20230403184655148">
<figcaption aria-hidden="true">image-20230403184655148</figcaption>
</figure>
<p>这里针对"ext4"进行讨论：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230403184849483.png" alt="image-20230403184849483">
<figcaption aria-hidden="true">image-20230403184849483</figcaption>
</figure>
<h2 id="查看某个版本号对应的包的所以已安装包">查看某个版本号对应的包的所以已安装包：</h2>
<p>dpkg -l | grep 2:2.1.0-5+deb10u2 | cut -d ' ' -f 3|cut -d ":" -f 1 |
xargs</p>
<p>或dpkg -l | grep 2:2.1.0-5+deb10u2 | cut -d ' ' -f 3|cut -d ":" -f 1
| awk '{printf("%s ", $0)} END {printf("")}'</p>
<h2 id="查看dpkg安装过程的详细信息">查看dpkg安装过程的详细信息：</h2>
<p>dpkg -D333</p>
<h2 id="报这个错的解决方法pcie-bus-error">报这个错的解决方法(PCIe Bus
Error):</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/001f50367ab88be4530f8ac6919d9c26-16805757986091.jpg" alt="001f50367ab88be4530f8ac6919d9c26">
<figcaption aria-hidden="true">001f50367ab88be4530f8ac6919d9c26</figcaption>
</figure>
<p>pcie 物理链路层报错，应该是硬件出问题了</p>
<p>解决方法：启动参数加pcie_aspm=off</p>
<h2 id="开启coredump">开启coredump：</h2>
<p>建议卸载systemd-coredump使用内核自带的core机制（systemd-coredump不会生成systemd的core文件）</p>
<p>ulimit -c unlimited</p>
<p>（测试发现在普通用户下开启coredump和在root下开启coredump
时，在不同用户下执行ulimit -c以及coredumpctl
list显示的值不一样，如下面所示，所以最好在所有用户下都执行下）</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406134935521.png" alt="image-20230406134935521">
<figcaption aria-hidden="true">image-20230406134935521</figcaption>
</figure>
<p>如果进程已经在运行，可以设置指定pid的limit</p>
<ol type="1">
<li>临时修改进程 <code>prlimit --core=unlimited -p $PID</code></li>
</ol>
<p>注：上面的配置重启会失效，所以要永久启用请参考下面的：</p>
<p>2、永久修改</p>
<p>对于普通用户进程来说，编辑/etc/profile最后加上ulimit -c
unlimited就行了，但是测试对root不生效。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406135145550.png" alt="image-20230406135145550">
<figcaption aria-hidden="true">image-20230406135145550</figcaption>
</figure>
<p>注：实测对root用户，用户名替换为*未生效，所以最好是显示指定为root</p>
<p>最好改成这样<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230418165303527.png" alt="image-20230418165303527"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*               soft    core            unlimited</span><br><span class="line">*               hard    core            unlimited</span><br><span class="line">root            soft    core            unlimited</span><br><span class="line">root            hard    core            unlimited</span><br><span class="line">message+            soft    core            unlimited</span><br><span class="line">message+            hard    core            unlimited</span><br><span class="line">message            soft    core            unlimited</span><br><span class="line">message            hard    core            unlimited</span><br></pre></td></tr></table></figure>
<p>这个文件是由pam_limits模块来读的：</p>
<p>#define _PAM_LOGFILE "/var/run/pam-debug.log"</p>
<p>其他dbus-daemon服务等实测要修改这个地方：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230508112416923.png" alt="image-20230508112416923">
<figcaption aria-hidden="true">image-20230508112416923</figcaption>
</figure>
<h2 id="设置格式">设置格式：</h2>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"/tmp/core-%e-%p-%t"</span> &gt;<span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern</span><br><span class="line">echo <span class="string">"/home/uos/systemd-coredumps/core-%e-%p-%t"</span> &gt;<span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern</span><br><span class="line">echo <span class="string">"/var/log/systemd-coredumps/core-%e-%p-%t"</span> &gt;<span class="regexp">/proc/sys</span><span class="regexp">/kernel/core</span>_pattern</span><br></pre></td></tr></table></figure>
<p>这样更改只是临时的，要想永久生效可以通过更改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">添加一行：kernel.core_pattern=/home/uos/systemd-coredumps/core-%e-%p-%t</span><br><span class="line">kernel.core_pattern=/var/log/systemd-coredumps/core-%e-%p-%t</span><br></pre></td></tr></table></figure>
<p>对于dbus-daemon:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑 /etc/sysctl.conf 文件来设置 /proc/sys/fs/suid_dumpable 参数。在该文件中添加以下行：</span><br><span class="line">fs.suid_dumpable = 1</span><br></pre></td></tr></table></figure>
<p>如果您已经设置了
<code>ulimit -c unlimited</code>，并且仍然没有生成core文件，可能是因为以下原因之一：</p>
<ol type="1">
<li><p>内核可能已被配置为禁用生成core文件。您可以检查
<code>/proc/sys/kernel/core_pattern</code>文件的内容，以确定是否已禁用生成core文件。如果它是空的或包含“|/bin/false”之类的命令，则生成core文件已被禁用。您可以使用以下命令将其重置为默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">echo "/var/core/core-%e-%p-%t.core" &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></li>
<li><p>如果
<code>/var/core</code>目录不存在或不可写，则core文件可能无法写入。您可以尝试手动创建该目录，并确保该目录对当前用户可写。</p></li>
<li><p>如果您正在运行Systemd，可能需要将
<code>LimitCORE=infinity</code>添加到
<code>/etc/systemd/system.conf</code>或相关服务单元中。这将确保系统可以生成无限制大小的core文件。</p></li>
<li><p>另外，如果dbus-daemon在使用journald作为日志记录系统，则它可能会导致core文件无法生成。您可以尝试将其配置为使用其他日志记录系统，如syslog。</p></li>
</ol>
<p>如果您已经检查了以上问题，并且仍然无法生成core文件，请尝试重新启动系统，然后再次测试dbus-daemon崩溃是否可以生成core文件。</p>
<h3 id="查看某个运行中的进程对应的limit配置">查看某个运行中的进程对应的limit配置：</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/xxx/limits</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230418163539455.png" alt="image-20230418163539455">
<figcaption aria-hidden="true">image-20230418163539455</figcaption>
</figure>
<h2 id="使用内核机制生成coredump的过程">使用内核机制生成coredump的过程：</h2>
<p>1、堆栈如下（do_coredump）：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230419105156862.png" alt="image-20230419105156862">
<figcaption aria-hidden="true">image-20230419105156862</figcaption>
</figure>
<p>查看lz4的core文件：</p>
<p>1-先解压：lz4 -d sss.lz4 sss 2-查看：gdb 程序名 -c sss</p>
<h2 id="gvfs">gvfs:</h2>
<p>GVfs 是 GIO（GLib 中可用的库）的用户空间虚拟文件系统实现。GVfs
带有一组后端，包括垃圾支持、SFTP、SMB、HTTP、DAV 和<a target="_blank" rel="noopener" href="https://wiki.gnome.org/Projects/gvfs/schemes">许多其他后端</a>。GVfs
还包含用于实现卷监视器和持久元数据存储的 GIO 模块。还有 FUSE
支持，为不使用 GIO 的应用程序提供对 GVfs 文件系统的有限访问。</p>
<p>报这个问题的代码逻辑：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406145744572.png" alt="image-20230406145744572">
<figcaption aria-hidden="true">image-20230406145744572</figcaption>
</figure>
<p>首先借助gdb可以知道代码路径是在这里：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151216996.png" alt="image-20230406151216996">
<figcaption aria-hidden="true">image-20230406151216996</figcaption>
</figure>
<p>这个gvfsd的作用：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151534579.png" alt="image-20230406151534579">
<figcaption aria-hidden="true">image-20230406151534579</figcaption>
</figure>
<p>这里是有on_name_lost打印的日志，条件为connection==NULL</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406145835453.png" alt="image-20230406145835453">
<figcaption aria-hidden="true">image-20230406145835453</figcaption>
</figure>
<p>显然是g_bus_own_name失败时执行的on_name_lost</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151314396.png" alt="image-20230406151314396">
<figcaption aria-hidden="true">image-20230406151314396</figcaption>
</figure>
<p>g_bus_own_name(代码在glib2.0中)</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151715089.png" alt="image-20230406151715089">
<figcaption aria-hidden="true">image-20230406151715089</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406152046796.png" alt="image-20230406152046796">
<figcaption aria-hidden="true">image-20230406152046796</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406151835335.png" alt="image-20230406151835335">
<figcaption aria-hidden="true">image-20230406151835335</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406153412509.png" alt="image-20230406153412509">
<figcaption aria-hidden="true">image-20230406153412509</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g_bus_own_name{client-&gt;name_lost_handler = name_lost_handler;</span><br><span class="line">			  {g_bus_get（connection_get_cb）{g_task_new{task-&gt;callback = callback</span><br><span class="line">											{connection = get_uninitialized_connection</span><br><span class="line">											{g_async_initable_init_async（反正这里会执行connection_get_cb），g_async_initable_init_async中初始化的结果由g_bus_get_finish返回（这是代码的注释）</span><br><span class="line">connection_get_cb中，当client-&gt;connection返回为NULL时，执行call_lost_handler,进而打印该错误日志</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406145725352.png" alt="image-20230406145725352">
<figcaption aria-hidden="true">image-20230406145725352</figcaption>
</figure>
<p>g_bus_get_finish返回的 是res-&gt;result.pointer</p>
<h2 id="通过syslog过滤程序退出的日志可用来研究关机重启超时问题">通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-572921.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="切换java">切换java：</h2>
<p>sudo update-alternatives --config java</p>
<h2 id="切换iptable">切换iptable：</h2>
<p>sudo update-alternatives --set iptables /usr/sbin/iptables-legacy</p>
<p>当然用上面那个也行</p>
<p>xtables-nft — iptables using nftables kernel api</p>
<p>DESCRIPTION xtables-nft are versions of iptables that use the
nftables API. This is a set of tools to help the system administrator
mi‐ grate the ruleset from iptables(8), ip6tables(8), arptables(8), and
ebtables(8) to nftables(8).</p>
<p>xtables-legacy — iptables using old getsockopt/setsockopt-based
kernel api</p>
<p>DESCRIPTION xtables-legacy are the original versions of iptables that
use old getsockopt/setsockopt-based kernel interface. This kernel
interface has some limitations, therefore iptables can also be used with
the newer nf_tables based API. See xtables-nft(8) for information about
the xtables-nft variants of iptables.</p>
<h1 id="iptables">iptables</h1>
<p><strong>iptables命令</strong>
是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。</p>
<p>https://wangchujiang.com/linux-command/c/iptables.html</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-t, --table table 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通用匹配：源地址目标地址的匹配</span></span><br><span class="line">-p：指定要匹配的数据包协议类型；</span><br><span class="line">-s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。</span><br><span class="line">-d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。</span><br><span class="line">-i, --in-interface [!] &lt;网络接口name&gt; ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，"!" 表示取反。</span><br><span class="line">-o, --out-interface [!] &lt;网络接口name&gt; ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看管理命令</span></span><br><span class="line">-L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">规则管理命令</span></span><br><span class="line">-A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。</span><br><span class="line">-I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。</span><br><span class="line">-D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。</span><br><span class="line">-R num：Replays替换/修改第几条规则</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">链管理命令（这都是立即生效的）</span></span><br><span class="line">-P, --policy chain target ：为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的。</span><br><span class="line">-F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。</span><br><span class="line">-N, --new-chain chain 用指定的名字创建一个新的链。</span><br><span class="line">-X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。</span><br><span class="line">-E, --rename-chain old-chain new-chain ：用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响。</span><br><span class="line">-Z, --zero [chain] ：把指定链，或者表中的所有链上的所有计数器清零。</span><br><span class="line"></span><br><span class="line">-j, --jump target &lt;指定目标&gt; ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。</span><br><span class="line">-h：显示帮助信息；</span><br></pre></td></tr></table></figure>
<h2 id="基本参数">基本参数</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-P</td>
<td>设置默认策略:iptables -P INPUT (DROP</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I</td>
<td>num 在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D</td>
<td>num 删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号"!"表示除这个IP外。</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-i</td>
<td>网卡名称 匹配从这块网卡流入的数据</td>
</tr>
<tr>
<td>-o</td>
<td>网卡名称 匹配从这块网卡流出的数据</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议,如tcp,udp,icmp</td>
</tr>
<tr>
<td>--dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>--sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody>
</table>
<h4 id="命令选项输入顺序">命令选项输入顺序</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://www.iptables.info/en/structure-of-iptables.html#NATTABLE">NAT
表</a>：</p>
<blockquote>
<p>该表应该只用于不同数据包上的
NAT（网络地址转换）。换句话说，它应该只用于转换数据包的源字段或目标字段。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.iptables.info/en/structure-of-iptables.html#FILTERTABLE">过滤表</a>：</p>
<blockquote>
<p>过滤表主要用于过滤数据包。我们可以匹配数据包并以我们想要的任何方式过滤它们。这是我们实际对数据包采取行动并查看它们包含的内容并根据其内容丢弃或接受它们的地方。当然我们也可以做事前过滤；然而，这个特定的表是设计过滤的地方。</p>
<p>filter 的 FORWARD
链只被转发的数据包（来自网络和出去到网络的数据包）遍历，即你的计算机就像一个路由器，而
nat 的 PREROUTING
链被两个转发的数据包遍历目的是本地主机的数据包和数据包。</p>
<p>您应该仅使用 nat 的 PREROUTING 来更改数据包的目标地址，而过滤器的
FORWARD 仅用于过滤（丢弃/接受数据包）。</p>
</blockquote>
<h4 id="工作机制">工作机制</h4>
<p>规则链名包括(也被称为五个钩子函数（hook functions）)：</p>
<ul>
<li><strong>INPUT链</strong> ：处理输入数据包。</li>
<li><strong>OUTPUT链</strong> ：处理输出数据包。</li>
<li><strong>FORWARD链</strong> ：处理转发数据包。</li>
<li><strong>PREROUTING链</strong> ：用于目标地址转换（DNAT）。</li>
<li><strong>POSTOUTING链</strong> ：用于源地址转换（SNAT）。</li>
</ul>
<h4 id="防火墙的策略">防火墙的策略</h4>
<p>防火墙策略一般分为两种，一种叫 <code>通</code>策略，一种叫
<code>堵</code>策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，<code>所以通，是要全通，而堵，则是要选择</code>。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。</p>
<p>我们现在用的比较多个功能有3个：</p>
<ol type="1">
<li>filter 定义允许或者不允许的，只能做在3个链上：INPUT ，FORWARD
，OUTPUT</li>
<li>nat 定义地址转换的，也只能做在3个链上：PREROUTING ，OUTPUT
，POSTROUTING</li>
<li>mangle功能:修改报文原数据，是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li>
</ol>
<p>我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠mangle来实现的。</p>
<p>小扩展:</p>
<ul>
<li>对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT</li>
<li>对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT
，POSTROUTING</li>
<li>而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</li>
</ul>
<p>iptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。</p>
<p>iptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。</p>
<p>注意：规则的次序非常关键，<code>谁的规则越严格，应该放的越靠前</code>，而检查规则的时候，是按照从上往下的方式进行检查的。</p>
<p>表名包括：</p>
<ul>
<li><strong>raw</strong> ：高级功能，如：网址过滤。</li>
<li><strong>mangle</strong> ：数据包修改（QOS），用于实现服务质量。</li>
<li><strong>nat</strong> ：地址转换，用于网关路由器。</li>
<li><strong>filter</strong> ：包过滤，用于防火墙规则。</li>
</ul>
<p>动作包括：</p>
<ul>
<li><strong>ACCEPT</strong> ：接收数据包。</li>
<li><strong>DROP</strong> ：丢弃数据包。</li>
<li><strong>REDIRECT</strong> ：重定向、映射、透明代理。</li>
<li><strong>SNAT</strong> ：源地址转换。</li>
<li><strong>DNAT</strong> ：目标地址转换。</li>
<li><strong>MASQUERADE</strong> ：IP伪装（NAT），用于ADSL。</li>
<li><strong>LOG</strong> ：日志记录。</li>
<li><strong>SEMARK</strong> :
添加SEMARK标记以供网域内强制访问控制（MAC）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓</span><br><span class="line"> ┌───────────────┐           ┃    Network    ┃</span><br><span class="line"> │ table: filter │           ┗━━━━━━━┳━━━━━━━┛</span><br><span class="line"> │ chain: INPUT  │◀────┐             │</span><br><span class="line"> └───────┬───────┘     │             ▼</span><br><span class="line">         │             │   ┌───────────────────┐</span><br><span class="line">  ┌      ▼      ┐      │   │ table: nat        │</span><br><span class="line">  │local process│      │   │ chain: PREROUTING │</span><br><span class="line">  └             ┘      │   └─────────┬─────────┘</span><br><span class="line">         │             │             │</span><br><span class="line">         ▼             │             ▼              ┌─────────────────┐</span><br><span class="line">┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅    │     ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      │table: nat       │</span><br><span class="line"> Routing decision      └───── outing decision ─────▶│chain: PREROUTING│</span><br><span class="line">┅┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅┅          ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅      └────────┬────────┘</span><br><span class="line">         │                                                   │</span><br><span class="line">         ▼                                                   │</span><br><span class="line"> ┌───────────────┐                                           │</span><br><span class="line"> │ table: nat    │           ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅               │</span><br><span class="line"> │ chain: OUTPUT │    ┌─────▶ outing decision ◀──────────────┘</span><br><span class="line"> └───────┬───────┘    │      ┅┅┅┅┅┅┅┅┳┅┅┅┅┅┅┅┅</span><br><span class="line">         │            │              │</span><br><span class="line">         ▼            │              ▼</span><br><span class="line"> ┌───────────────┐    │   ┌────────────────────┐</span><br><span class="line"> │ table: filter │    │   │ chain: POSTROUTING │</span><br><span class="line"> │ chain: OUTPUT ├────┘   └──────────┬─────────┘</span><br><span class="line"> └───────────────┘                   │</span><br><span class="line">                                     ▼</span><br><span class="line">                             ┏╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓</span><br><span class="line">                             ┃    Network    ┃</span><br><span class="line">                             ┗━━━━━━━━━━━━━━━┛</span><br></pre></td></tr></table></figure>
<h3 id="实例-3">实例</h3>
<h4 id="清空当前的所有规则和计数">清空当前的所有规则和计数</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -F  # 清空所有的防火墙规则</span><br><span class="line">iptables -X  # 删除用户自定义的空链</span><br><span class="line">iptables -Z  # 清空计数</span><br></pre></td></tr></table></figure>
<h4 id="配置允许ssh端口连接">配置允许ssh端口连接</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求</span></span><br></pre></td></tr></table></figure>
<h4 id="允许本地回环地址可以正常使用">允许本地回环地址可以正常使用</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许</span></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br></pre></td></tr></table></figure>
<h4 id="设置默认的规则">设置默认的规则</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -P INPUT DROP # 配置默认的不让进</span><br><span class="line">iptables -P FORWARD DROP # 默认的不允许转发</span><br><span class="line">iptables -P OUTPUT ACCEPT # 默认的可以出去</span><br></pre></td></tr></table></figure>
<h4 id="配置白名单">配置白名单</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT  # 允许机房内网机器可以访问</span><br><span class="line">iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT  # 允许机房内网机器可以访问</span><br><span class="line">iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口</span><br></pre></td></tr></table></figure>
<h4 id="开启相应的服务端口">开启相应的服务端口</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口</span><br><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来</span><br></pre></td></tr></table></figure>
<h4 id="保存规则到配置文件中">保存规则到配置文件中</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line">cat /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>
<h4 id="列出已设置的规则">列出已设置的规则</h4>
<blockquote>
<p>iptables -L [-t 表名] [链名]</p>
</blockquote>
<ul>
<li>四个表名
<code>raw</code>，<code>nat</code>，<code>filter</code>，<code>mangle</code></li>
<li>五个规则链名
<code>INPUT</code>、<code>OUTPUT</code>、<code>FORWARD</code>、<code>PREROUTING</code>、<code>POSTROUTING</code></li>
<li>filter表包含
<code>INPUT</code>、<code>OUTPUT</code>、<code>FORWARD</code>三个规则链</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -t nat                  # 列出 nat 上面的所有规则</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">           ^ -t 参数指定，必须是 raw， nat，filter，mangle 中的一个</span></span><br><span class="line">iptables -L -t nat  --line-numbers  # 规则带编号</span><br><span class="line">iptables -L INPUT</span><br><span class="line"></span><br><span class="line">iptables -L -nv  # 查看，这个列表看起来更详细</span><br></pre></td></tr></table></figure>
<h4 id="清除已有规则">清除已有规则</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -F INPUT  # 清空指定链 INPUT 上面的所有规则</span><br><span class="line">iptables -X INPUT  # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。</span><br><span class="line">                   # 如果没有指定链名，则会删除该表中所有非内置的链。</span><br><span class="line">iptables -Z INPUT  # 把指定链，或者表中的所有链上的所有计数器清零。</span><br></pre></td></tr></table></figure>
<h4 id="删除已添加的规则">删除已添加的规则</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一条规则</span></span><br><span class="line">iptables -A INPUT -s 192.168.1.5 -j DROP</span><br></pre></td></tr></table></figure>
<p>将所有iptables以序号标记显示，执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure>
<p>比如要删除INPUT里序号为8的规则，执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -D INPUT 8</span><br></pre></td></tr></table></figure>
<h4 id="开放指定的端口">开放指定的端口</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行</span><br><span class="line">iptables -A OUTPUT -j ACCEPT         #允许所有本机向外的访问</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    #允许访问22端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT    #允许ftp服务的21端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT    #允许FTP服务的20端口</span><br><span class="line">iptables -A INPUT -j reject       #禁止其他未允许的规则访问</span><br><span class="line">iptables -A FORWARD -j REJECT     #禁止其他未允许的规则访问</span><br></pre></td></tr></table></figure>
<h4 id="屏蔽ip">屏蔽IP</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP  # 屏蔽恶意主机（比如，192.168.0.8</span><br><span class="line">iptables -I INPUT -s 123.45.6.7 -j DROP       #屏蔽单个IP的命令</span><br><span class="line">iptables -I INPUT -s 123.0.0.0/8 -j DROP      #封整个段即从123.0.0.1到123.255.255.254的命令</span><br><span class="line">iptables -I INPUT -s 124.45.0.0/16 -j DROP    #封IP段即从123.45.0.1到123.45.255.254的命令</span><br><span class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP    #封IP段即从123.45.6.1到123.45.6.254的命令是</span><br></pre></td></tr></table></figure>
<h4 id="指定数据包出去的网络接口">指定数据包出去的网络接口</h4>
<p>只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -o eth0</span><br></pre></td></tr></table></figure>
<h4 id="查看已添加的规则">查看已添加的规则</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n -v</span><br><span class="line">Chain INPUT (policy DROP 48106 packets, 2690K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"> 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line"> 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
<h4 id="启动网络转发规则">启动网络转发规则</h4>
<p>公网 <code>210.14.67.7</code>让内网
<code>192.168.188.0/24</code>上网</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127</span><br></pre></td></tr></table></figure>
<h4 id="端口映射">端口映射</h4>
<p>本机的 2222 端口映射到内网 虚拟机的22 端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222  -j DNAT --to-dest 192.168.188.115:22</span><br></pre></td></tr></table></figure>
<h4 id="字符串匹配">字符串匹配</h4>
<p>比如，我们要过滤所有TCP连接中的字符串
<code>test</code>，一旦出现它我们就终止这个连接，我们可以这么做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m string --algo kmp --string "test" -j REJECT --reject-with tcp-reset</span><br><span class="line">iptables -L</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Chain INPUT (policy ACCEPT)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target     prot opt <span class="built_in">source</span>               destination</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">REJECT     tcp  --  anywhere             anywhere            STRING match <span class="string">"test"</span> ALGO name kmp TO 65535 reject-with tcp-reset</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Chain FORWARD (policy ACCEPT)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target     prot opt <span class="built_in">source</span>               destination</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Chain OUTPUT (policy ACCEPT)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target     prot opt <span class="built_in">source</span>               destination</span></span><br></pre></td></tr></table></figure>
<h4 id="阻止windows蠕虫的攻击">阻止Windows蠕虫的攻击</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string "cmd.exe"</span><br></pre></td></tr></table></figure>
<h4 id="防止syn洪水攻击">防止SYN洪水攻击</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT</span><br></pre></td></tr></table></figure>
<h4 id="添加secmark记录">添加SECMARK记录</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t mangle -A INPUT -p tcp --src 192.168.1.2 --dport 443 -j SECMARK --selctx system_u:object_r:myauth_packet_t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向从 192.168.1.2:443 以TCP方式发出到本机的包添加MAC安全上下文 system_u:object_r:myauth_packet_t</span></span><br></pre></td></tr></table></figure>
<h2 id="查看iptables-加入规则的流程大概是这样的">查看iptables
加入规则的流程大概是这样的：</h2>
<p>1、执行命令后，iptabls通过一个netlink
socket像内核发送获取rules的命令，内核返回一个rules
list，iptables保存到一个cache_list中，
然后iptables再将新的规则加进去放到h-&gt;obj_list中，然后再通过构建一个msg再通过socket发送给内核，如果有错误再保存給
h-&gt;err_list.</p>
<h2 id="更多实例">更多实例</h2>
<blockquote>
<p>用iptables搭建一套强大的安全防护盾 http://www.imooc.com/learn/389</p>
</blockquote>
<p>iptables: linux 下应用层防火墙工具</p>
<p>iptables 5链: 对应 Hook point netfilter: linux
操作系统核心层内部的一个数据包处理模块 Hook point: 数据包在 netfilter
中的挂载点;
<code>PRE_ROUTING / INPUT / OUTPUT / FORWARD / POST_ROUTING</code></p>
<p>iptables &amp; netfilter <img src="http://7xq89b.com1.z0.glb.clouddn.com/netfilter&amp;iptables.jpg" alt="img"></p>
<p>iptables 4表5链 <img src="http://7xq89b.com1.z0.glb.clouddn.com/iptables-data-stream.jpg" alt="img"></p>
<p>iptables rules <img src="http://7xq89b.com1.z0.glb.clouddn.com/iptables-rules.jpg" alt="img"></p>
<ul>
<li>4表</li>
</ul>
<p><strong>filter</strong>: 访问控制 / 规则匹配 <strong>nat</strong>:
地址转发 mangle / raw</p>
<ul>
<li>规则</li>
</ul>
<p>数据访问控制: ACCEPT / DROP / REJECT 数据包改写(nat -&gt; 地址转换):
snat / dnat 信息记录: log</p>
<h2 id="使用场景实例">使用场景实例</h2>
<ul>
<li>场景一</li>
</ul>
<p>开放 tcp 10-22/80 端口 开放 icmp 其他未被允许的端口禁止访问</p>
<p>存在的问题: 本机无法访问本机; 本机无法访问其他主机</p>
<ul>
<li>场景二</li>
</ul>
<p>ftp: 默认被动模式(服务器产生随机端口告诉客户端,
客户端主动连接这个端口拉取数据) vsftpd: 使 ftp
支持主动模式(客户端产生随机端口通知服务器,
服务器主动连接这个端口发送数据)</p>
<ul>
<li>场景三</li>
</ul>
<p>允许外网访问: web http -&gt; 80/tcp; https -&gt; 443/tcp mail smtp
-&gt; 25/tcp; smtps -&gt; 465/tcp pop3 -&gt; 110/tcp; pop3s -&gt;
995/tcp imap -&gt; 143/tcp</p>
<p>内部使用: file nfs -&gt; 123/udp samba -&gt; 137/138/139/445/tcp ftp
-&gt; 20/21/tcp remote ssh -&gt; 22/tcp sql mysql -&gt; 3306/tcp oracle
-&gt; 1521/tcp</p>
<ul>
<li>场景四</li>
</ul>
<p>nat 转发</p>
<ul>
<li>场景五</li>
</ul>
<p>防CC攻击</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -F -A -D # list flush append delete</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景一</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT # 允许 tcp 80 端口</span><br><span class="line">iptables -I INPUT -p tcp --dport 10:22 -j ACCEPT # 允许 tcp 10-22 端口</span><br><span class="line">iptables -I INPUT -p icmp -j ACCEPT # 允许 icmp</span><br><span class="line">iptables -A INPUT -j REJECT # 添加一条规则, 不允许所有</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优化场景一</span></span><br><span class="line">iptables -I INPUT -i lo -j ACCEPT # 允许本机访问</span><br><span class="line">iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许访问外网</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -s 10.10.188.233 -j ACCEPT # 只允许固定ip访问80</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景二</span></span><br><span class="line">vi /etc/vsftpd/vsftpd.conf # 使用 vsftpd 开启 ftp 主动模式</span><br><span class="line">port_enable=yes</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">iptables -I INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line"></span><br><span class="line">vi /etc/vsftpd/vsftpd.conf # 建议使用 ftp 被动模式</span><br><span class="line">pasv_min_port=50000</span><br><span class="line">pasv_max_port=60000</span><br><span class="line">iptables -I INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 50000:60000 -j ACCEPT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">还可以使用 iptables 模块追踪来自动开发对应的端口</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景三</span></span><br><span class="line">iptables -I INPUT -i lo -j ACCEPT # 允许本机访问</span><br><span class="line">iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许访问外网</span><br><span class="line">iptables -I INPUT -s 10.10.155.0/24 -j ACCEPT # 允许内网访问</span><br><span class="line">iptables -I INPUT -p tcp -m multiport --dports 80,1723 -j ACCEPT # 允许端口, 80 -&gt; http, 1723 -&gt; vpn</span><br><span class="line">iptables -A INPUT -j REJECT # 添加一条规则, 不允许所有</span><br><span class="line"></span><br><span class="line">iptables-save # 保存设置到配置文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">场景四</span></span><br><span class="line">iptables -t nat -L # 查看 nat 配置</span><br><span class="line"></span><br><span class="line">iptables -t nat -A POST_ROUTING -s 10.10.177.0/24 -j SNAT --to 10.10.188.232 # SNAT</span><br><span class="line">vi /etc/sysconfig/network # 配置网关</span><br><span class="line"></span><br><span class="line">iptables -t nat -A POST_ROUTING -d 10.10.188.232 -p tcp --dport 80 -j DNAT --to 10.10.177.232:80 # DNAT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">场景五</span></span><br><span class="line">iptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 100 -j REJECT # 限制并发连接访问数</span><br><span class="line">iptables -I INPUT -m limit --limit 3/hour --limit-burst 10 -j ACCEPT # limit模块; --limit-burst 默认为5</span><br></pre></td></tr></table></figure>
<h1 id="iptables-legacy-与-iptables-nft-的关系与区别"><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#iptables-legacy-与-iptables-nft-的关系与区别">iptables-legacy
与 iptables-nft 的关系与区别</a></h1>
<h2 id="区别"><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#区别">区别</a></h2>
<ul>
<li>iptables-legacy 调用的是 iptables kernel API，iptables-nft 调用的是
nftables kernel API，所以它们的规则在不同内核模块中管理，nft 命令只读取
nftables 内核模块中的规则，所以 nft list ruleset 只能看到 iptables-nft
配置的规则。</li>
</ul>
<h2 id="共同点"><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#共同点">共同点</a></h2>
<ul>
<li>都兼容 iptables 命令配置规则的语法。</li>
<li>匹配报文逻辑共用的同一份代码(xtables match)，nft 配置的规则才会用
nftables match。</li>
</ul>
<h2 id="与-iptables-命令的关系"><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#与-iptables-命令的关系">与
iptables 命令的关系</a></h2>
<ul>
<li>通常在支持 nftables 的发行版中才会有 iptables-legacy 与
iptables-nft，而 iptables
命令本身是个软链，用户可以选择在两这者之间切换。</li>
<li>iptables-legacy 等同于不支持 nftables 发行版的 iptables
命令，即传统的 iptables。</li>
<li>较新发行版往往将 iptables 软链到 iptables-nft。</li>
</ul>
<h2 id="最佳实践"><a target="_blank" rel="noopener" href="https://imroc.cc/linux/network/nftables/iptables-legacy-and-iptables-nft.html#最佳实践">最佳实践</a></h2>
<ul>
<li>当系统支持 iptables-nft 时，可以取代 iptables-legacy。</li>
<li>不要两者混用，避免混淆。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--------------+     +--------------+     +--------------+</span><br><span class="line">|   iptables   |     |   iptables   |     |     nft      |   USER</span><br><span class="line">|    legacy    |     |     nft      |     |  (nftables)  |   SPACE</span><br><span class="line">+--------------+     +--------------+     +--------------+</span><br><span class="line">       |                          |         |</span><br><span class="line">====== | ===== KERNEL API ======= | ======= | =====================</span><br><span class="line">       |                          |         |</span><br><span class="line">+--------------+               +--------------+</span><br><span class="line">|   iptables   |               |   nftables   |              KERNEL</span><br><span class="line">|      API     |               |     API      |              SPACE</span><br><span class="line">+--------------+               +--------------+</span><br><span class="line">             |                    |         |</span><br><span class="line">             |                    |         |</span><br><span class="line">          +--------------+        |         |     +--------------+</span><br><span class="line">          |   xtables    |--------+         +-----|   nftables   |</span><br><span class="line">          |    match     |                        |    match     |</span><br><span class="line">          +--------------+                        +--------------+</span><br></pre></td></tr></table></figure>
<p>安装配置阶段进入tty配置用户以及修改默认启动程序的操作步骤 1
安装完成后不要重启 2 切tty2 crtl+alt+F2 3 lsblk -f
查看roota的设备节点名,本例中是sdd3 4 sudo mkdir /target 5 cd /target 6
sudo mount /dev/sdd3 /target 将roota挂载到新建的target 7 sudo chroot
/target 8 passwd root 修改root密码</p>
<h2 id="切wayland">切wayland :</h2>
<p>1、下载dde-dconfig-editor</p>
<p>2、修改
/usr/share/dsg/configs/org.deepin.dde.lightdm-deepin-greeter/org.deepin.dde.lightdm-deepin-greeter.json</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406174135280.png" alt="image-20230406174135280">
<figcaption aria-hidden="true">image-20230406174135280</figcaption>
</figure>
<h2 id="解压live系统">解压live系统：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406173901628.png" alt="image-20230406173901628">
<figcaption aria-hidden="true">image-20230406173901628</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230406173935523.png" alt="image-20230406173935523">
<figcaption aria-hidden="true">image-20230406173935523</figcaption>
</figure>
<p>简单来说就3点: \1. 在live系统中更新httpfs2并执行update-initramfs
-u更新initrd \2.
更新的initrd文件拷贝出来覆盖/var/www/html/iso/live/initrd.lz \3.
重新压缩filesystem.squashfs并覆盖/var/www/html/iso/live/下的同名文件</p>
<h2 id="查询socket">查询socket:</h2>
<p>netstat -nalp</p>
<p>sudo netstat -nalp | grep "/run/systemd/private"</p>
<h2 id="调试使用某个so文件的进程">调试使用某个so文件的进程：</h2>
<p>如果你想调试调用libinput库的进程，首先需要找到正在调用libinput的进程。可以使用命令
<code>lsof</code> 和 <code>grep</code>
来查找正在使用libinput库的进程，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perlCopy code</span><br><span class="line">sudo lsof -n | grep libinput</span><br></pre></td></tr></table></figure>
<p>该命令会列出所有正在使用libinput库的进程及其对应的PID和文件描述符。接下来，使用GDB调试这个进程的话，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy code</span><br><span class="line">sudo gdb -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;pid&gt;</code>
是你要调试的进程的PID。这会启动GDB并附加到指定的进程上。</p>
<p>通过上面的过程可以发现控制鼠标、触摸板等是被Xorg调用的</p>
<p>#0 0x00007f033060c168 in tp_palm_detect (tp=0x3374be0, t=0x33751a0,
time=1085585244) at ../src/evdev-mt-touchpad.c:1043 #1
0x00007f033060d7f2 in tp_process_state (tp=0x3374be0, time=1085585244)
at ../src/evdev-mt-touchpad.c:1789 #2 0x00007f033060dbde in
tp_handle_state (tp=0x3374be0, time=1085585244) at
../src/evdev-mt-touchpad.c:1915 #3 0x00007f033060dcf3 in
tp_interface_process (dispatch=0x3374be0, device=0x336f8c0,
e=0x7f02f37fcca0, time=1085585244) at ../src/evdev-mt-touchpad.c:1967 #4
0x00007f03305fe2dc istn evdev_process_event (device=0x336f8c0,
e=0x7f02f37fcca0) at ../src/evdev.c:873 #5 0x00007f03305fe321 in
evdev_device_dispatch_one (device=0x336f8c0, ev=0x7f02f37fcca0) at
../src/evdev.c:881 #6 0x00007f03305fe506 in evdev_device_dispatch
(data=0x336f8c0) at ../src/evdev.c:940 #7 0x00007f03305f82bc in
libinput_dispatch (libinput=0x32f9b80) at ../src/libinput.c:2070 #8
0x00007f033066ea18 in () at /usr/lib/xorg/modules/input/libinput_drv.so
#9 0x000000000059b913 in () #10 0x000000000059df01 in () #11
0x000000000059b75e in () #12 0x00007f0361147fa3 in start_thread
(arg=<code>&lt;optimized out&gt;</code>) at pthread_create.c:486 #13
0x00007f036107663f in clone () at
../sysdeps/unix/sysv/linux/x86_64/clone.S:95</p>
<p>使用手掌控制触摸板会进入这里然后goto out</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417110045540.png" alt="image-20230417110045540">
<figcaption aria-hidden="true">image-20230417110045540</figcaption>
</figure>
<p>#0 0x00007f033060b02f in tp_process_absolute (tp=0x3374be0,
e=0x7f02f37fcca0, time=2035521967) at ../src/evdev-mt-touchpad.c:509 #1
0x00007f033060dc93 in tp_interface_process (dispatch=0x3374be0,
device=0x336f8c0, e=0x7f02f37fcca0, time=2035521967) at
../src/evdev-mt-touchpad.c:1956 #2 0x00007f03305fe2dc in
evdev_process_event (device=0x336f8c0, e=0x7f02f37fcca0) at
../src/evdev.c:873 #3 0x00007f03305fe321 in evdev_device_dispatch_one
(device=0x336f8c0, ev=0x7f02f37fcca0) at ../src/evdev.c:881 #4
0x00007f03305fe506 in evdev_device_dispatch (data=0x336f8c0) at
../src/evdev.c:940 #5 0x00007f03305f82bc in libinput_dispatch
(libinput=0x32f9b80) at ../src/libinput.c:2070 #6 0x00007f033066ea18 in
() at /usr/lib/xorg/modules/input/libinput_drv.so #7 0x000000000059b913
in () #8 0x000000000059df01 in () #9 0x000000000059b75e in () #10
0x00007f0361147fa3 in start_thread
(arg=<code>&lt;optimized out&gt;</code>) at pthread_create.c:486 #11
0x00007f036107663f in clone () at
../sysdeps/unix/sysv/linux/x86_64/clone.S:95</p>
<h3 id="libinput防误触配置">libinput防误触配置：</h3>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417151650132.png" alt="image-20230417151650132">
<figcaption aria-hidden="true">image-20230417151650132</figcaption>
</figure>
<p>但是我看代码里默认是开启的，应该不需要开</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417151757687.png" alt="image-20230417151757687">
<figcaption aria-hidden="true">image-20230417151757687</figcaption>
</figure>
<h2 id="禁用域管">禁用域管：</h2>
<p>systemctl disable system-udcp-daemon.service 和 systemctl --user
disable session-udcp-daemon.service</p>
<h2 id="获取是否是笔记本">获取是否是笔记本：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230417165322081.png" alt="image-20230417165322081">
<figcaption aria-hidden="true">image-20230417165322081</figcaption>
</figure>
<p>代码来自 libdframeworkdbus2库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline const char* strempty(const char *s) {</span><br><span class="line"></span><br><span class="line">        return s ?: "";</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="service文件拒绝手动启动">service文件拒绝手动启动：</h2>
<p>放在【Unit】下</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230419102130173.png" alt="image-20230419102130173">
<figcaption aria-hidden="true">image-20230419102130173</figcaption>
</figure>
<h2 id="systemd-service-依赖">systemd service 依赖:</h2>
<h3 id="一自动依赖">一、自动依赖</h3>
<h4 id="隐含依赖">1、隐含依赖</h4>
<p>下列依赖关系是自动隐含的：</p>
<p>设置了 Type=dbus 的服务会自动添加 Requires=dbus.socket 与
After=dbus.socket 依赖。</p>
<p>基于套接字启动的服务会自动添加对关联的 .socket 单元的 After= 依赖。
服务单元还会为所有在 Sockets= 中列出的 .socket 单元自动添加 Wants= 与
After= 依赖。</p>
<p>还有一些 其他依赖关系是由 systemd.exec(5) 与
systemd.resource-control(5) 中的某些资源限制选项自动隐含添加的。</p>
<h4 id="默认依赖">2、默认依赖</h4>
<p>除非明确设置了 DefaultDependencies=no ，否则 service
单元将会自动添加下列依赖关系：</p>
<p>Requires=sysinit.target, After=sysinit.target, After=basic.target,
Conflicts=shutdown.target, Before=shutdown.target 。
这样可以确保普通的服务单元：
(1)在基础系统启动完毕之后才开始启动，(2)在关闭系统之前先被干净的停止。
只有那些需要在系统启动的早期就必须启动的服务，
以及那些必须在关机动作的结尾才能停止的服务才需要设置
DefaultDependencies=no 。</p>
<p>从同一个模版实例化出来的所有服务单元(单元名称中带有 "@" 字符)，
默认全部属于与模版同名的同一个 slice 单元(参见 systemd.slice(5))。
该同名 slice 一般在系统关机时，与所有模版实例一起停止。
如果你不希望像上面这样，那么可以在模版单元中明确设置
DefaultDependencies=no ， 并且：要么在该模版文件中明确定义特定的 slice
单元(同样也要明确设置 DefaultDependencies=no)、
要么在该模版文件中明确设置 Slice=system.slice (或其他合适的 slice)。
参见 systemd.resource-control(5) 手册。</p>
<h3 id="systemd-service中的before-和after代表的含义是什么">systemd
service中的Before= 和After=代表的含义是什么</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在systemd服务中，Before= 和After=用于定义服务之间的启动顺序。</span><br><span class="line"></span><br><span class="line">Before=用于指定一个服务应该在哪些服务之前启动。例如：</span><br><span class="line"></span><br><span class="line">Before=nginx.service httpd.service</span><br><span class="line">这将确保在启动nginx.service和httpd.service之前，该服务将被启动。</span><br><span class="line"></span><br><span class="line">相反，After=用于指定服务应该在哪些服务之后启动。例如：</span><br><span class="line"></span><br><span class="line">After=network.target syslog.target</span><br><span class="line">这将确保在network.target和syslog.target服务之后，该服务将被启动。</span><br><span class="line"></span><br><span class="line">需要注意的是，在同一级别的依赖关系中，Before和After并没有严格的先后顺序，因为systemd不保证在同一级别的依赖关系中按照任何特定的顺序启动服务。相反，它使用一种称为“启动、启用或激活控制”的机制来管理依赖性。</span><br></pre></td></tr></table></figure>
<h4 id="为什么systemd-machine-id-commit.service中明明设置了beforesysinit.target-shutdown.target但是systemctl-list-dependences却显示systemd-machine-id-commit.service依赖sysinit.target">为什么systemd-machine-id-commit.service中明明设置了Before=sysinit.target
shutdown.target，但是systemctl
list-dependences却显示systemd-machine-id-commit.service依赖sysinit.target</h4>
<p>在 Systemd 中，服务的依赖关系是根据单元文件中声明的 Before 和 After
关键字来计算的。如果一个服务 A 声明了 Before=B，那么在启动或停止服务 B
之前，服务 A 将被启动或停止。</p>
<p>然而，在显示服务的依赖关系时，Systemd
还会考虑单元文件中的其他信息，比如必需的<strong>配置文件和其他服务的启动状态</strong>等。这可能会导致某些服务与它们声明的依赖关系不一致，因为这些附加信息可能会修改启动顺序。</p>
<p>对于你提到的 systemd-machine-id-commit.service，尽管它声明了
Before=sysinit.target shutdown.target，但它实际上需要在 sysinit.target
启动后才能运行，因为它需要读取 /etc/machine-id 文件并将其写入
/var/lib/dbus/machine-id 文件，这些文件都由 sysinit.target
提供。因此，Systemd 在计算依赖关系时将 systemd-machine-id-commit.service
视为依赖于 sysinit.target，即使 Before 关键字声明了相反的顺序。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230420164920843.png" alt="image-20230420164920843">
<figcaption aria-hidden="true">image-20230420164920843</figcaption>
</figure>
<p>总之，单元文件中的 Before 和 After
关键字只是服务之间启动顺序的一部分，还有其他因素可能影响系统中服务的实际启动顺序。</p>
<h3 id="before-after和wantedby的区别是什么">before
After和Wantedby的区别是什么：</h3>
<p>Before 和 After 关键字用于定义服务之间的启动顺序，而 WantedBy
关键字用于指定 systemd 启动该服务的目标。</p>
<p>Before 和 After
关键字可以在系统中建立服务之间的启动顺序依赖关系。例如，如果一个服务 A
声明了 Before=B，那么在启动或停止服务 B 之前，服务 A
将被启动或停止。相反地，如果一个服务 A 声明了 After=B，则服务 B
将在启动或停止服务 A 之后启动或停止。</p>
<p>WantedBy 关键字用于指定 systemd 启动该服务的目标。这通常是一个 target
单元，如 multi-user.target 或 graphical.target。例如，如果一个服务声明了
WantedBy=multi-user.target，则该服务将在系统进入 multi-user.target
目标时启动。</p>
<p>因此，Before 和 After 关键字用于控制服务之间的启动顺序，而 WantedBy
关键字则指定 systemd
启动该服务的目标。这些关键字可以一起使用来创建复杂的启动依赖关系和目标层次结构。</p>
<h3 id="systemd-单元的dependenciesunit_referenced_by和dependenciesunit_references的区别是什么">systemd
单元的dependencies[UNIT_REFERENCED_BY]和dependencies[UNIT_REFERENCES]的区别是什么？</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencies[UNIT_REFERENCES] 属性用于记录一个单元所依赖的其他单元，而 dependencies[UNIT_REFERENCED_BY] 属性用于记录依赖该单元的其他单元。</span><br></pre></td></tr></table></figure>
<h2 id="systemctl-set-default关闭和开启图形化界面">systemctl
set-default(关闭和开启图形化界面):</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230424101610834.png" alt="image-20230424101610834">
<figcaption aria-hidden="true">image-20230424101610834</figcaption>
</figure>
<h2 id="tmp目录被清空实现">/tmp目录被清空实现</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230424102102208.png" alt="image-20230424102102208">
<figcaption aria-hidden="true">image-20230424102102208</figcaption>
</figure>
<p>把这一行注释掉/tmp下的内容就不会删除</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230424102117921.png" alt="image-20230424102117921">
<figcaption aria-hidden="true">image-20230424102117921</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230803071713337.png" alt="image-20230803071713337">
<figcaption aria-hidden="true">image-20230803071713337</figcaption>
</figure>
<h2 id="kms激活码">kms激活码：</h2>
<p>kms.uniontech.com:8900:nqYvXZXdNPKNn335</p>
<h2 id="sd_bus_add_match_async-函数">sd_bus_add_match_async 函数</h2>
<p><strong>sd_bus_add_match_async
函数的作用？“sd_bus_add_match_async(track-&gt;bus, &amp;n-&gt;slot,
match, on_name_owner_changed, NULL,
track);”这个的含义是什么？</strong></p>
<p><code>sd_bus_add_match_async</code>函数用于向DBus系统总线注册一个过滤规则，当满足该规则的消息到达总线时，DBus将会通知应用程序。该函数的原型如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sd_bus_add_match_async(sd_bus *bus, sd_bus_slot **slot, const <span class="built_in">char</span> *match, sd_bus_message_handler_t callback, void *userdata, sd_bus_slot **ret_slot);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bus</code>参数指向DBus系统总线。</li>
<li><code>slot</code>参数是一个指向
<code>sd_bus_slot</code>类型指针的指针，用于返回DBus总线的插槽。</li>
<li><code>match</code>参数是一个DBus过滤规则，用于匹配总线上的消息。具体规则可以参考DBus文档中的描述。</li>
<li><code>callback</code>参数是当DBus总线上有符合过滤规则的消息到达时应该调用的回调函数。</li>
<li><code>userdata</code>参数是传递给回调函数的用户数据指针。</li>
<li><code>ret_slot</code>参数是一个指向
<code>sd_bus_slot</code>类型指针的指针，用于返回DBus总线的插槽。</li>
</ul>
<p>所以，<code>sd_bus_add_match_async(track-&gt;bus, &amp;n-&gt;slot, match, on_name_owner_changed, NULL, track);</code>的含义是：向DBus系统总线注册一个过滤规则（<code>match</code>），当DBus总线上有符合该规则的消息到达时，调用
<code>on_name_owner_changed</code>函数，回调函数的用户数据指针为
<code>track</code>，并返回DBus总线的插槽。</p>
<h2 id="session-c1-device-226-0代表什么意思">session-c1-device-226-0代表什么意思:</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230428162455823.png" alt="image-20230428162455823">
<figcaption aria-hidden="true">image-20230428162455823</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230428161449272.png" alt="image-20230428161449272">
<figcaption aria-hidden="true">image-20230428161449272</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"4月 28 13:44:50 uos-PC systemd[1]: systemd-logind.service: Got notification message from PID 1239 (FDSTORE=1, FDNAME=session-4-device-226-0)</span><br><span class="line">4月 28 13:44:50 uos-PC systemd[1]: systemd-logind.service: Added fd 123 (session-4-device-226-0) to fd store." 这个日志是什么意思</span><br></pre></td></tr></table></figure>
<p>这个日志是系统的 <code>systemd-logind.service</code>
服务收到了一个来自进程 ID 为 1239
的进程的通知消息，该消息的内容是将一个名为
<code>session-4-device-226-0</code>
的文件描述符添加到文件描述符存储中。</p>
<p>具体来说，这个日志包含了以下两条系统日志信息：</p>
<p>第一条信息：
<code>systemd-logind.service: Got notification message from PID 1239 (FDSTORE=1, FDNAME=session-4-device-226-0)</code>。其中：</p>
<ul>
<li><code>systemd-logind.service</code>
是系统中用于控制用户登录和登出的服务。</li>
<li><code>Got notification message</code>
表示该服务收到了一个通知消息。</li>
<li><code>PID 1239</code> 表示发送该通知消息的进程 ID 是 1239。</li>
<li><code>(FDSTORE=1, FDNAME=session-4-device-226-0)</code>
表示通知消息的内容，其中 <code>FDSTORE=1</code>
表示将该文件描述符存储，<code>FDNAME=session-4-device-226-0</code>
表示文件描述符名为 <code>session-4-device-226-0</code>。</li>
</ul>
<p>第二条信息：<code>systemd-logind.service: Added fd 123 (session-4-device-226-0) to fd store.</code>。其中：</p>
<ul>
<li><code>Added fd 123</code>
表示成功将文件描述符添加到文件描述符存储中，并获得了一个文件描述符编号
123。</li>
<li><code>(session-4-device-226-0)</code>
表示被添加的文件描述符的名字。</li>
</ul>
<p>综上，这个日志记录了系统中一个进程向
<code>systemd-logind.service</code> 发送了一个消息，通知该服务将一个名为
<code>session-4-device-226-0</code>
的文件描述符存储到系统的文件描述符存储中。</p>
<h2 id="查看deb包dbg调试信息">查看deb包dbg调试信息：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230428174919715.png" alt="image-20230428174919715">
<figcaption aria-hidden="true">image-20230428174919715</figcaption>
</figure>
<h3 id="判断一个包是否已安装的代码">判断一个包是否已安装的代码：</h3>
<p>原理是遍历/var/lib/dpkg/info/packagename.list</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line">    ret = get_dpkg_file_count(packagename, &amp;num_pkg_files,&amp;package_dir_list); //获取应用相关的所有文件</span><br><span class="line"></span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        g_list_foreach(package_dir_list, (GFunc)free_glist_enum_memory, NULL);</span><br><span class="line"></span><br><span class="line">        g_list_free(package_dir_list);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 如果获取到与包相关的文件数为0,则认为该包名不正确，返回参数异常错误</span><br><span class="line"></span><br><span class="line">    SPM_LOG_ERR("#package:%s,num_pkg_files:%d", packagename, num_pkg_files);</span><br><span class="line"></span><br><span class="line">    if (num_pkg_files &lt;= 0)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">        g_list_foreach(package_dir_list, (GFunc)free_glist_enum_memory, NULL);</span><br><span class="line"></span><br><span class="line">        g_list_free(package_dir_list);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int get_dpkg_file_count(const char *packagename, int *num_pkg_files,GList **package_dir_list)</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    char info_file_name[MAX_PACKAGENAME_LEN] = {0}; //.list文件</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    char *buf = NULL;</span><br><span class="line"></span><br><span class="line">    buf = (char *)malloc(MAX_LINE_LEN);</span><br><span class="line"></span><br><span class="line">    if (buf == NULL)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        SPM_LOG_ERR("NOMEMORY:%m");</span><br><span class="line"></span><br><span class="line">        return SPM_RET_NOMEMORY;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    memset(buf, 0, MAX_LINE_LEN);</span><br><span class="line"></span><br><span class="line">    char *buf_long = NULL;</span><br><span class="line"></span><br><span class="line">    int readsize = MAX_LINE_LEN;</span><br><span class="line"></span><br><span class="line">    int len = 0;</span><br><span class="line"></span><br><span class="line">    int attr = 0;</span><br><span class="line"></span><br><span class="line">    struct stat sbuf;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    char script_file_name[MAX_PACKAGENAME_LEN]; //  dpkg/info目录中的脚本文件</span><br><span class="line"></span><br><span class="line">    int len_suffix_array = (sizeof(aux_files_suffix) / sizeof(aux_files_suffix[0]));</span><br><span class="line"></span><br><span class="line">    snprintf(info_file_name, MAX_PACKAGENAME_LEN, "%s/%s.%s", PKG_INFO_PATH, packagename, LISTFILE);</span><br><span class="line"></span><br><span class="line">    fp = fopen(info_file_name, "r");</span><br><span class="line"></span><br><span class="line">    if (fp == NULL)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        ret = -errno;</span><br><span class="line"></span><br><span class="line">        free(buf);</span><br><span class="line"></span><br><span class="line">        buf = NULL;</span><br><span class="line"></span><br><span class="line">        SPM_LOG_ERR("%s,failed :%m", info_file_name);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (fgets(&amp;buf[attr], readsize - len, fp) != NULL)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        if (!newline_terminated(&amp;buf[attr], readsize - len))</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            len = readsize;</span><br><span class="line"></span><br><span class="line">            attr = strlen(buf);</span><br><span class="line"></span><br><span class="line">            readsize = readsize * 2;</span><br><span class="line"></span><br><span class="line">            buf_long = (char *)malloc(readsize);</span><br><span class="line"></span><br><span class="line">            if (buf_long == NULL)</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                free(buf);</span><br><span class="line"></span><br><span class="line">                fclose(fp);</span><br><span class="line"></span><br><span class="line">                SPM_LOG_ERR("NOMEMORY:%m");</span><br><span class="line"></span><br><span class="line">                return SPM_RET_NOMEMORY;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            memset(buf_long, 0, readsize);</span><br><span class="line"></span><br><span class="line">            strncpy(buf_long, buf, len);</span><br><span class="line"></span><br><span class="line">            free(buf);</span><br><span class="line"></span><br><span class="line">            buf = NULL;</span><br><span class="line"></span><br><span class="line">            buf = buf_long;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            char *find = strchr(buf, '\n'); //末尾的"\n"</span><br><span class="line"></span><br><span class="line">            if (find)</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                *find = '\0'; //替换</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            ret = stat(buf, &amp;sbuf);</span><br><span class="line"></span><br><span class="line">            if (ret &lt; 0) //针对文件或目录不存在的容错处理</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // 2022-11-09 添加 对目录设置保护</span><br><span class="line"></span><br><span class="line">            if (!S_ISDIR(sbuf.st_mode) || check_package_dirname_and_addtolist(buf, packagename, package_dir_list))</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                *num_pkg_files = *num_pkg_files + 1;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            len = 0;</span><br><span class="line"></span><br><span class="line">            attr = 0;</span><br><span class="line"></span><br><span class="line">            readsize = MAX_LINE_LEN;</span><br><span class="line"></span><br><span class="line">            free(buf);</span><br><span class="line"></span><br><span class="line">            buf = NULL;</span><br><span class="line"></span><br><span class="line">            buf = (char *)malloc(readsize);</span><br><span class="line"></span><br><span class="line">            if (buf == NULL)</span><br><span class="line"></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                fclose(fp);</span><br><span class="line"></span><br><span class="line">                SPM_LOG_ERR("NOMEMORY:%m");</span><br><span class="line"></span><br><span class="line">                return SPM_RET_NOMEMORY;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            memset(buf, 0, readsize);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    free(buf);</span><br><span class="line"></span><br><span class="line">    buf = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len_suffix_array; i++)</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        snprintf(script_file_name, MAX_PACKAGENAME_LEN, "%s/%s.%s", PKG_INFO_PATH, packagename, aux_files_suffix[i]);</span><br><span class="line"></span><br><span class="line">        if (access(script_file_name, F_OK) != -1)</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            *num_pkg_files = *num_pkg_files + 1;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">\#define PKG_INFO_PATH "/var/lib/dpkg/info"</span><br><span class="line"></span><br><span class="line">\#define LISTFILE "list"</span><br><span class="line">// 判断一行是否读取完整</span><br><span class="line">static int newline_terminated(char *buf, size_t buflen)</span><br><span class="line">{</span><br><span class="line">    size_t len = strlen(buf);</span><br><span class="line">    if (len == buflen - 1 &amp;&amp; buf[len - 1] != '\r' &amp;&amp;</span><br><span class="line">        buf[len - 1] != '\n')</span><br><span class="line">        return 0;</span><br><span class="line">    return 1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="shell替换软件包版本号的shell命令">shell替换软件包版本号的shell命令</h3>
<p>dpkg -l|grep 2.28.23-deepin1|cut -d ' ' -f 3|cut -d ':' -f 1|sed
's/(.*)/\1=2.28.21-deepin1/g' | tr '' ' '</p>
<h3 id="echo--e-aaaa-sed-s.1xxg-tr">echo -e "aaaa" | sed
's/(.*)/\1=xx/g' | tr '' ' '</h3>
<p>``解释：</p>
<p>\1. <code>echo -e "aaaa\nbbbb"</code>：使用 <code>echo</code>
命令输出两行文本，<code>aaaa</code> 和 <code>bbbb</code>。 2
<code>sed 's/\(.*\)/\1=xx/g'</code>：使用 <code>sed</code>
命令在每个单词后面添加 <code>=xx</code>。 \3.
<code>tr '\n' ' '</code>：使用 <code>tr</code>
命令将换行符替换为空格。</p>
<p>运行此命令后，您将得到以下输出：</p>
<p>``aaaa=xx bbbb=xx</p>
<h2 id="usbip设置u盘重定向">usbip设置u盘重定向：</h2>
<p>1、可复现问题的机型：</p>
<p>任何两台x86或arm架构uos机器</p>
<p>2、设备详细信息（启动器-设备管理器-右键-导出）：</p>
<p><strong>如果事件单中已提供，可备注事件单中已提供。</strong></p>
<p>3、复现问题的镜像链接：</p>
<p>105x公版镜像</p>
<p>4、安装第3条中的镜像后，客户另外自行安装的应用列表（如果事定制版应用，请提供下载链接）：</p>
<p>从系统仓库安装usbip工具</p>
<p>5、故障发生时正在运行的应用列表（系统监视器-程序进程截屏）：</p>
<p><strong>eg.</strong></p>
<p>6、详细的复现步骤：</p>
<p><strong>uos1和uos2需要安装usbip工具，分别加载驱动，设置网卡延迟。</strong></p>
<p><strong>1、系统仓库安装usbip sudo apt install usbip</strong></p>
<p><strong>2、执行sudo modprobe vhci_hcd和sudo modprobe
usbip-host</strong></p>
<p><strong>3、执行sudo tc qdisc add dev enp2s0 root netem delay
30ms</strong></p>
<p><strong>备注：云厂商适配适配场景，主机和虚拟机环境一般会存在网络延迟，所有本地复现时需要将网络延迟设置30ms左右</strong></p>
<p><strong>Uos1</strong></p>
<p><strong>1、系统仓库安装usbip sudo apt install usbip</strong></p>
<p><strong>2、执行sudo modprobe vhci_hcd和sudo modprobe
usbip-host</strong></p>
<p><strong>3、执行sudo tc qdisc add dev 网卡名称1 root netem delay
30ms</strong></p>
<p><strong>4、物理设备端插入USB设备</strong></p>
<p><strong>5、物理设备端执行sudo usbip list -l
查询USB设备的busid</strong></p>
<p><strong>6、物理设备端执行sudo usbip bind -b
<code>&lt;busid&gt;</code> 进行绑定</strong></p>
<p><strong>7、物理设备端执行sudo usbipd -d -4 开启服务</strong></p>
<p><strong>Uos2</strong></p>
<p><strong>1、系统仓库安装usbip sudo apt install usbip</strong></p>
<p><strong>2、执行sudo modprobe vhci_hcd和sudo modprobe
usbip-host</strong></p>
<p><strong>3、执行sudo tc qdisc add dev 网卡名称2 root netem delay
30ms</strong></p>
<p><strong>4、虚拟设备端执行sudo usbip attach -r </strong><uos1_ip>**
<strong>-b</strong> <strong><code>&lt;busid&gt;</code>
进行连接</strong></uos1_ip></p>
<p><strong>5、打开文件管理，可以查看插入uos1的u盘数据</strong></p>
<p>虚拟设备执行usbip detach -p 0进行断开连接</p>
<p>物理设备端执行usbip unbind -b <code>&lt;busid&gt;</code>进行解绑</p>
<h2 id="调试dde-daemon">调试dde-daemon：</h2>
<p>pkill dde-session-dae ;/usr/lib/deepin-daaemon/dde-session-daemon</p>
<p>或者</p>
<p>killall dde-session-daemon;DDE_DEBUG_LEVEL=debug
/usr/lib/deepin-daemon/dde-session-daemon</p>
<h2 id="打补丁">打补丁</h2>
<p>git clone /<em> 如果目录上级没有源码文件 debuild -us -uc 然后取消 mv
代码目录 代码目录-版本号 dh_make --createorig -s 产生orig源码文件</em>/
这些有源代码不需要 dpkg-source -b ./ 或 dpkg-source --before-build .
应用补丁 ln -s debian/patches/ patches quilt new 补丁名
例如add-uos-support.patch quilt add 要修改的文件 例如Makefile 修改文件
quilt refresh 补丁就生成出来了 在debian/patches目录下 cd ../../
退到代码根目录 dch -i 改changelog git add debian/changelog git add
debian/patches/series git add debian/patches/生成的补丁 git commit
这里可以 debuild -b 编译进行测试；或者 dpkg-source --after-build .
dpkg-source --before-build . 测试补丁应用 最后 git reset --hard git
clean -df 将临时文件清除 git review -r origin
uos提交，最后面是要提交的分支名</p>
<p>debian目录不打patch，直接修改</p>
<p>quilt rename -P 给补丁改名字 quilt remove files 和add相反 必须先add
再改</p>
<h2 id="git撤销amend">git撤销amend:</h2>
<p>首先使用 <code>git reflog</code> 命令查看操作记录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">c1c1b21 HEAD@{0}: commit (amend): add blank line to index.html</span><br><span class="line">9ff821d HEAD@{1}: commit: add blank line to index.html</span><br><span class="line">b078331 HEAD@{2}: commit: no more commit!</span><br><span class="line">b86e902 HEAD@{3}: commit: so many commit</span><br><span class="line">77e6ce9 HEAD@{4}: commit: this is another commit</span><br><span class="line">ccde039 HEAD@{5}: commit: this is a commit</span><br><span class="line">a49dcf4 HEAD@{6}: <span class="built_in">clone</span>: from ssh://liux@xxx.xx.xx.xxx:29418/git_test.git</span><br></pre></td></tr></table></figure>
<p>看到 amend 操作之前的最后一个操作就是 <code>HEAD@{1}</code>.
现在可以用 <code>git reset</code> 将当前分支的 HEAD 指向
<code>HEAD@{1}</code>, 即可达到撤销 amend 的目的:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD@{1}</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 5 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure>
<h2 id="找socket对应的文件">找socket对应的文件：</h2>
<p>ls -l /proc/2546/fd/12 -&gt; socket:[52845]</p>
<p>cat /proc/net/unix | grep 52845 -&gt;
/run/user/1000/systemd/private</p>
<p>cat /proc/net/netlink| grep sockid</p>
<h2 id="lightdm到startdde的整个流程">lightdm到startdde的整个流程：</h2>
<p>lightdm启动greeter:</p>
<p>日志在/var/log/lightdm/lightdm.log</p>
<p>greeter 16:55:29创建会话（/var/log/lightdm/seat0-greater.log ）</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-675667.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-675667.png" alt="img"></a></p>
<p>kwin 16:55:33启动（~/.kwin.log）</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-675669.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-675669.png" alt="img"></a></p>
<p>startdde 16:55:50启动(journalctl /usr/bin/lightdm -b0)</p>
<p><a target="_blank" rel="noopener" href="https://pms.uniontech.com/file-read-675671.png"><img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/file-read-675671.png" alt="img"></a></p>
<p>代码：</p>
<p>lightdm-&gt;/usr/bin/deepin-greeter-&gt;/usr/share/dde-session-shell/greeters.d/x/*或者/usr/share/dde-session-shell/greeters.d/wayland/launch-kwin-wayland-&gt;/usr/bin/kwin_wayland
--drm --no-lockscreent
/usr/share/dde-session-shell/greeters.d/wayland/lightdm-deepin-greeter-wayland</p>
<h2 id="打印枚举值">打印枚举值：</h2>
<p>enum tp_gesture_state {</p>
<pre><code>GESTURE_STATE_NONE,

GESTURE_STATE_UNKNOWN,

GESTURE_STATE_SCROLL,

GESTURE_STATE_PINCH,

GESTURE_STATE_SWIPE,

GESTURE_STATE_TAP,</code></pre>
<p>};</p>
<p>#define CASE_RETURN_STRING(a) case a: return #a</p>
<p>static inline const char*</p>
<p>gesture_state_to_str(enum tp_gesture_state state)</p>
<p>{</p>
<pre><code>switch (state) {

CASE_RETURN_STRING(GESTURE_STATE_NONE);

CASE_RETURN_STRING(GESTURE_STATE_UNKNOWN);

CASE_RETURN_STRING(GESTURE_STATE_SCROLL);

CASE_RETURN_STRING(GESTURE_STATE_PINCH);

CASE_RETURN_STRING(GESTURE_STATE_SWIPE);

CASE_RETURN_STRING(GESTURE_STATE_TAP);

}

return NULL;</code></pre>
<p>}</p>
<h2 id="编译kwin遇到如下问题">编译kwin遇到如下问题：</h2>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e "override_dh_shlibdeps:\n\tdh_shlibdeps --dpkg-shlibdeps-params=--ignore-missing-info"|tee -a debian/rules</span><br></pre></td></tr></table></figure>
<h2 id="gdb-set-substitute-path命令用法">gdb set
substitute-path命令用法</h2>
<p><code>set substitute-path</code> 是 GDB
中的一个命令，用于设置源代码路径的替换规则。它可以帮助 GDB
在调试过程中正确地找到源代码文件。</p>
<p>该命令的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phpCopy code</span><br><span class="line">set substitute-path &lt;原始路径&gt; &lt;替换路径&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;原始路径&gt;</code>
是要被替换的源代码路径，<code>&lt;替换路径&gt;</code>
是替换后的路径。</p>
<p>例如，假设源代码路径为
<code>/home/user/project/src</code>，而实际代码所在的路径是
<code>/mnt/external_drive/project/src</code>，你可以使用以下命令进行路径替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">set substitute-path /home/user/project/src /mnt/external_drive/project/src</span><br></pre></td></tr></table></figure>
<p>这样，当 GDB 在调试过程中遇到源代码文件路径为
<code>/home/user/project/src/foo.c</code> 时，会自动将其替换为
<code>/mnt/external_drive/project/src/foo.c</code>。</p>
<p>你可以使用 <code>show substitute-path</code>
命令来查看当前设置的替换规则。如果需要取消替换规则，可以使用
<code>unset substitute-path</code> 命令。</p>
<p>请注意，<code>set substitute-path</code>
命令通常在调试会话开始之前使用，因为它会影响到后续的源代码查找和断点设置。</p>
<h2 id="查看一个文件夹占了哪个磁盘的-空间以及磁盘所占空间">查看一个文件夹占了哪个磁盘的
空间以及磁盘所占空间</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h /path/to/folder</span><br><span class="line">df -h /dev/sda</span><br></pre></td></tr></table></figure>
<h2 id="查看一个文件夹下各文件所占空间大小只算一层">查看一个文件夹下各文件所占空间大小，只算一层</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>
<h2 id="查看journal某次启动的日志">查看journal某次启动的日志：</h2>
<p>journalctl --directory
logsall/logs/var/log/journal/75ac2718a7824e04aca173da6d3c0277/
--list-boots</p>
<p>journalctl --directory
logsall/logs/var/log/journal/75ac2718a7824e04aca173da6d3c0277/
--list-boots | grep "2023-07-11 01:14:"</p>
<p>journalctl --directory
logsall/logs/var/log/journal/75ac2718a7824e04aca173da6d3c0277/ -b
-90</p>
<p>vim
logsall/logs/var/log/deepin/dde-dconfig-daemon/dde-dconfig-daemon.log</p>
<h2 id="开启dbus日志">开启dbus日志：</h2>
<p>dbus-damon里有很多调试log是 通过_dbus_verbose
打印的，这个打印必须打开DBUS_ENABLE_VERBOSE_MODE 才会打印。 而这个宏在
debian/rules
通过参数--enable-verbose-mode打开，dbus默认有个debug_configure_flags打开了这个宏，但是没有编译到包里，是在
dbus/debian/build-debug/bus/目录下。 必须用这个编译出来的debug版本，加上
DBUS_VERBOSE=1参数才能打开verbose
log，log是直接fprintf(stderr方式打印，所以要用nofork方式启动。
log非常多，为了不影响正常业务，可以单独的起一个dbus-daemon，然后对要调试的程序，通过环境变量
DBUS_SYSTEM_BUS_ADDRESS 或者DBUS_SESSION_BUS_ADDRESS指定地址的方式
让调试程序将dbus消息发到我们这个debug版本上，系统其他的进程还是发到原来的dbus-daemon上，这样对正常业务没有影响。</p>
<h2 id="如何用bpftrace跟踪ioctl调用">如何用BPFtrace跟踪ioctl调用</h2>
<p>要使用 BPFtrace 跟踪 <code>ioctl</code> 调用，你可以编写一个 BPFtrace
脚本，使用 <code>tracepoint:syscalls:sys_enter_ioctl</code> 事件来捕获
<code>ioctl</code> 系统调用的进入。</p>
<p>以下是一个简单的示例脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/bpftrace</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_ioctl</span><br><span class="line">{</span><br><span class="line">  printf("ioctl called: fd=%d, request=%lx\n", arg1, arg2);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>保存脚本为 <code>ioctl_trace.bt</code>，然后在终端中运行以下命令启动
BPFtrace：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">sudo bpftrace ioctl_trace.bt</span><br></pre></td></tr></table></figure>
<p>这将以超级用户权限运行 BPFtrace，并开始跟踪 <code>ioctl</code>
调用。每当有进程调用 <code>ioctl</code>
时，将打印相应的信息，包括文件描述符和请求参数。</p>
<p>请注意，运行 BPFtrace
需要具有适当的权限。在某些系统上，可能需要以超级用户身份运行
BPFtrace。另外，BPFtrace
的可用性和功能可能会因操作系统和内核版本的不同而有所差异。请确保你的系统满足
BPFtrace 的要求，并在运行脚本之前进行适当的测试和验证。</p>
<h2 id="tracepointsyscallssys_enter_ioctl这个tracepoint是什么意思">tracepoint:syscalls:sys_enter_ioctl这个tracepoint是什么意思？</h2>
<p>这个tracepoint定义了一个名为
<code>syscalls:sys_enter_ioctl</code>的跟踪事件。在内核中，tracepoint是用于跟踪和观察特定代码路径或系统调用的工具。</p>
<p>该tracepoint用于跟踪
<code>ioctl</code>系统调用的进入点。当应用程序调用
<code>ioctl</code>函数时，该tracepoint会被触发，并执行其中的代码块。代码块中的内容会被打印到控制台上，显示相关的信息，如文件描述符（fd）和ioctl请求（request）。</p>
<p>通过定义和使用tracepoint，可以在内核中注入自定义的代码逻辑，用于跟踪和监视系统的运行时行为。这对于调试、性能分析和问题排查非常有用。通过tracepoint，您可以观察特定的系统调用、函数调用或事件，并在它们发生时执行自定义的操作。</p>
<p>tracepoint和uprobe的区别？</p>
<p>Tracepoint和Uprobe都是Linux内核中的跟踪工具，但它们的实现和使用方式有所不同。</p>
<p>Tracepoint是内核中预定义的静态跟踪事件，用于跟踪和监视特定的代码路径、系统调用或事件。Tracepoint在内核代码中显式定义，并在运行时触发相应的事件。可以使用trace-cmd等工具捕获和分析这些事件，以了解系统的行为和性能。</p>
<p>Uprobe（User
Probe）是一种动态的用户空间探测工具，用于在用户空间代码中插入探针。Uprobe允许您在用户程序的指定位置设置探针，当程序执行到该位置时，探针会触发并执行相应的动作。通过Uprobe，您可以监视和分析用户空间代码的执行，收集关键指标和信息。</p>
<p>关键区别如下：</p>
<ol type="1">
<li>Tracepoint是内核中静态定义的事件，而Uprobe是在用户空间动态设置的探针。</li>
<li>Tracepoint用于跟踪和监视内核中的代码路径和事件，而Uprobe用于跟踪和监视用户空间程序的执行。</li>
<li>Tracepoint由内核开发人员定义和维护，而Uprobe由用户或开发人员在运行时设置和使用。</li>
<li>Tracepoint的触发是由内核事件驱动的，而Uprobe的触发是由用户空间程序的执行驱动的。</li>
</ol>
<p>总的来说，Tracepoint更适用于内核级别的跟踪和分析，而Uprobe更适用于用户空间程序的动态监测和调试。</p>
<p>objdump -tT /lib/x86_64-linux-gnu/libc.so.6 | grep nptl_setxid</p>
<p>objdump -tT /lib/x86_64-linux-gnu/libc.so.6 | grep setgid</p>
<p>bpftrace -e 'kprobe:__sys_setresgid { @[ustack] = count(); }'</p>
<p>bpftrace -e 'kprobe:__sys_setresgid { printf("%s",stack) }'</p>
<p>bpftrace -e 'kprobe:__sys_setresgid { printf("%s",ustack) }'</p>
<p>bpftrace -e 'kprobe:__sys_setresgid { printf("%s",ustack) }'</p>
<h2 id="pkexec提权">pkexec提权</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230719134624308.png" alt="image-20230719134624308">
<figcaption aria-hidden="true">image-20230719134624308</figcaption>
</figure>
<p>dconfig</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230721134554563.png" alt="image-20230721134554563">
<figcaption aria-hidden="true">image-20230721134554563</figcaption>
</figure>
<p>显卡驱动位置：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230725115356234.png" alt="image-20230725115356234">
<figcaption aria-hidden="true">image-20230725115356234</figcaption>
</figure>
<p>drm调试等级设定：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230725115602949.png" alt="image-20230725115602949">
<figcaption aria-hidden="true">image-20230725115602949</figcaption>
</figure>
<h2 id="查看某个服务为什么退出">查看某个服务为什么退出：</h2>
<p>stopping %s ....</p>
<p>gdb -p 1</p>
<p>b job_add_to_gc_queue 即可，放心，调的次数不算太多</p>
<h2 id="获取usb设备的idvendor和idproduct信息以下是几种常用的方法">获取USB设备的idVendor和idProduct信息。以下是几种常用的方法：</h2>
<ol type="1">
<li><p>使用lsusb命令： 在终端中运行
<code>lsusb</code>命令，它会列出当前连接到计算机的所有USB设备及其相应的idVendor和idProduct信息。示例输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yamlCopy codeBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 003: ID 0c45:670c Microdia </span><br><span class="line">Bus 001 Device 002: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader Controller</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>
<p>在这个输出中，"0c45"表示idVendor，"670c"表示idProduct。</p></li>
<li><p>使用udevadm命令： 在终端中运行
<code>udevadm info -a -n /dev/usbX</code>（将"usbX"替换为您要检查的USB设备路径，如"/dev/usb1"）。该命令将显示有关USB设备的详细信息，包括idVendor和idProduct。</p></li>
<li><p>使用dmesg命令： 在终端中运行
<code>dmesg</code>命令，它会显示Linux内核日志，其中包含有关连接的USB设备的信息，包括idVendor和idProduct。</p></li>
</ol>
<h2 id="检查二进制程序是否存在内存泄露">检查二进制程序是否存在内存泄露</h2>
<p>valgrind --leak-check=summary df</p>
<h2 id="查看安装器的日志">查看安装器的日志：</h2>
<p>cat /var/log/deepin-installer.log | base64 -d</p>
<h2 id="禁用-selinux-的强制执行">禁用 SELinux 的强制执行</h2>
<p>将启动参数 <code>enforcing=0</code> 添加到启动选项中，可以将 SELinux
安全政策设置为 "Permissive" 模式，从而禁用 SELinux 的强制执行</p>
<ol type="1">
<li><strong>Permissive 模式下的 SELinux
仅记录问题，但不阻止任何操作</strong>：在 Permissive 模式下，SELinux
仍会分析和评估进程的安全上下文，但不会阻止违反规则的操作。相反，它会生成警告和错误日志来记录安全问题，以帮助系统管理员进行故障排除和调试。</li>
<li><strong>Permissive 模式允许你查看 SELinux
引起的潜在问题</strong>：通过将 SELinux 设置为 Permissive
模式，你可以查看与 SELinux 相关的潜在问题，例如哪些操作违反了 SELinux
的规则或策略。这有助于确定哪些过程可能会受到 SELinux
的限制，并可以帮助你识别和调整相应的 SELinux 配置。</li>
</ol>
<p>其他方法：</p>
<ol type="1">
<li><p>打开终端以进入命令行界面。</p></li>
<li><p>以 root 用户或具有 sudo 权限的用户身份执行以下命令以编辑 SELinux
配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux.conf</span><br></pre></td></tr></table></figure>
<p>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/selinux/config</span><br></pre></td></tr></table></figure></li>
<li><p>找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX</span><br></pre></td></tr></table></figure>
<p>行，并将其值修改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permissive</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disabled</span><br></pre></td></tr></table></figure>
<p>。请注意，这将根据你的需求来决定如何配置 SELinux。</p>
<ul>
<li>如果将值设置为 <code>permissive</code>，SELinux
将记录异常但不阻止任何操作。</li>
<li>如果将值设置为 <code>disabled</code>，SELinux 将完全禁用。</li>
</ul></li>
<li><p>添加下面的行，以启用调试日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELINUX_LOGGING=all</span><br><span class="line">SELINUX_DEBUG=1</span><br></pre></td></tr></table></figure>
<p>这将开启 SELinux 的调试日志记录功能。</p></li>
<li><p>保存并关闭文件，退出编辑器。</p></li>
<li><p>重新启动系统或重新加载 SELinux 配置，使更改生效。</p></li>
</ol>
<h2 id="开启wine应用日志">开启wine应用日志:</h2>
<p>/opt/deepinwine/tools/log.sh &lt;Wine 应用包名&gt;
+pid,+tid,+timestamp,+seh,+process,+module</p>
<h2 id="arecord录制音频">arecord录制音频：</h2>
<p>arecord -vv -f dat -d 120 -D pulse -r 48000 -c 2 1.wav</p>
<p>arecord -Dhw:0,1 -d 10 -f cd -t wav test.wav</p>
<p>此问题出现的原因是厂商主板设计适配声卡方面有缺陷。
1、通过以下步骤进行测试： (1)执行 mv /usr/bin/pulseaudio
/usr/bin/pulseaudiobak, 重启让pulseaudio无法自启动 (2)命令行 执行
arecord -Dhw:0,1 -d 10 -f cd -t wav
test.wav通过alsa进行录音（hw:0,1为指定录音的设备，arecord命令的使用可以参考网上资料）
(3) 将生成的test.wav用audacity软件进行播放，查看是否有杂音。
此时依旧有杂音，基本可以确定是送上来的数据流有问题（中间音频驱动和alsa编解码的过程因为编解码过程都比较完善，一般不会出现问题）
2、此问题从现象上看就是将录制的音量提高到50%的时候，通过alsamixer查看此时Internal
Mic
boost开始有增强效果，导致噪音被放大。此问题在软件方面只能通过修改配置文件将Internal
Mic
boost设置为ignore来取消增强效果来减缓此问题，要根本解决还需要厂商进行适配。</p>
<h2 id="pulseaudio为什么不能以系统级运行">pulseaudio为什么不能以系统级运行：</h2>
<p>https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/WhatIsWrongWithSystemWide/</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230809110641829.png" alt="image-20230809110641829">
<figcaption aria-hidden="true">image-20230809110641829</figcaption>
</figure>
<h2 id="i2c总线">i2c总线：</h2>
<p>i2c_designware FTI20001:01: timeout waiting for bus ready</p>
<p>你提到的错误信息 "i2c_designware FTI20001:01: timeout waiting for bus
ready" 是关于 I2C 总线通信的错误。I2C
是一种常用的串行通信协议，用于连接各种外设和传感器。这个错误通常表示在等待
I2C 总线准备好时发生了超时。</p>
<p>这个错误可能由多种原因引起，以下是一些常见的可能性和解决方法：</p>
<ol type="1">
<li><strong>硬件连接问题</strong>：确保你的硬件连接是正确的，包括正确连接了
SDA（数据线）和 SCL（时钟线），以及正确设置了总线上的电源和地线。</li>
<li><strong>电源问题</strong>：确保你的设备以及所连接的外设都有足够的电源供应，并且电源稳定。</li>
<li><strong>信号干扰</strong>：I2C
总线对信号的稳定性要求较高，如果有其他干扰源，可能会导致通信问题。确保周围环境的电磁干扰较小。</li>
<li><strong>外设故障</strong>：如果你连接了外设到 I2C
总线上，外设本身可能出现故障，导致通信问题。</li>
<li><strong>总线速率设置</strong>：检查你的代码或配置文件中设置的 I2C
总线速率是否正确。如果速率设置不正确，可能会导致通信超时。</li>
<li><strong>驱动程序问题</strong>：检查操作系统内核中的 I2C
驱动程序是否正常加载，并且是否适用于你的硬件。</li>
<li><strong>硬件故障</strong>：如果一切都正确设置而仍然出现问题，可能是硬件本身出现了故障。</li>
</ol>
<p>解决问题的步骤可能因你的具体硬件和情况而异。首先，确保硬件连接正确，然后检查电源和信号干扰等可能性。如果问题仍然存在，可以查阅硬件供应商的文档，或者查看操作系统的日志以获取更多信息。</p>
<h2 id="wget下载">wget下载：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -O ~/.config/clash/config.yaml "订阅链接"</span><br><span class="line"></span><br><span class="line">wget -e use_proxy=yes -e http_proxy=http://127.0.0.1:9093 -e https_proxy=http://127.0.0.1:9093 https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.31/Clash.for.Windows-0.20.31-x64-linux.tar.gz</span><br><span class="line">带身份验证：</span><br><span class="line">wget -e use_proxy=yes -e http_proxy=http://username:password@proxy.example.com:8080 URL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dsdt-表">DSDT 表</h2>
<p>DSDT 表是电脑硬件设备在 ACPI（高级配置和电源接口） 中的描述。ACPI
是一种高级电源管理和配置标准，旨在提供操作系统与计算机硬件之间的通信接口，以实现电源管理、硬件配置和设备控制等功能。</p>
<p>DSDT 是 "Differentiated System Description Table"
的缩写，它包含了一份以AML（ACPI机器语言）编写的二进制数据，描述了主板上各种硬件设备的层次结构、功能、资源配置和控制方法。这些硬件设备可以包括
CPU、内存、外部设备（如
USB、声卡、网卡等）、电源管理以及其他扩展功能。</p>
<p>操作系统在引导过程中会加载 DSDT
表，并根据其中的信息来实现对硬件设备的正确配置和管理。例如，操作系统可以根据
DSDT 表中的信息来决定如何正确地使用电源管理特性，如休眠、唤醒以及调整
CPU 频率等。</p>
<p>在某些情况下，硬件制造商可能提供了不完整或不准确的 DSDT
表，这可能导致一些硬件功能在操作系统中无法正常工作，或者导致电源管理等方面的问题。为了解决这些问题，技术爱好者和操作系统开发人员可能会尝试自行编写或修改
DSDT 表，以使其适配特定的硬件配置和操作系统需求。</p>
<p>需要注意的是，修改 DSDT 表需要深入了解 ACPI
和操作系统内核的工作原理，因此这通常是一个较为高级的任务，适用于对操作系统和硬件有深入了解的开发人员。</p>
<h2 id="修改-dsdt-表">修改 DSDT 表</h2>
<p>修改 DSDT 表需要一些高级的技术知识和工具，以及对 ACPI
和操作系统内核的深入了解。以下是大致的步骤，但请注意这是一个复杂的任务，可能需要在特定的场景下进行，例如解决硬件兼容性问题。</p>
<ol type="1">
<li><strong>了解 ACPI 和 DSDT 表：</strong> 在开始之前，确保您对 ACPI 和
DSDT 表的基本概念有一定的了解。阅读 ACPI 规范和相关文档可以帮助您理解
DSDT 表的结构和作用。</li>
<li><strong>获取 DSDT 表：</strong> 您可以从操作系统中获取当前系统使用的
DSDT 表。在 Linux 系统中，您可以使用 <code>acpidump</code> 工具来导出
DSDT 表。</li>
<li><strong>使用 AML 编辑器：</strong> DSDT 表是使用 AML（ACPI Machine
Language）编写的。您需要使用 AML 编辑器来编辑二进制数据。常用的 AML
编辑器包括 iASL 和 SSDTTime。</li>
<li><strong>解码和分析 DSDT 表：</strong> 使用 AML 编辑器将 DSDT
表解码成易于阅读的源代码。这将使您能够分析 DSDT
表的内容，了解其中包含的硬件设备、资源配置和控制方法。</li>
<li><strong>修改 DSDT 表：</strong>
根据您的需求，您可以在源代码中修改设备描述、资源配置、控制方法等。这需要深入了解
ACPI 语法和设备的工作原理。</li>
<li><strong>编译和编译错误修复：</strong>
编辑完成后，您需要将修改后的源代码编译回二进制格式。AML
编辑器通常会提供编译工具。在此过程中可能会出现编译错误，您需要修复这些错误，确保编译通过。</li>
<li><strong>替换操作系统中的 DSDT 表：</strong> 一旦您编辑和编译好了
DSDT 表，您需要将修改后的 DSDT 表替换操作系统中的原始 DSDT
表。这可能涉及到操作系统的内核配置和加载过程。</li>
<li><strong>测试和验证：</strong> 修改 DSDT
表可能会影响硬件的行为和操作系统的稳定性。在进行实际部署之前，务必进行充分的测试和验证，确保修改不会导致系统出现问题。</li>
</ol>
<p>请注意，修改 DSDT
表是一项高风险的任务，可能会导致系统无法启动或出现其他严重问题。如果您没有足够的经验和知识，建议不要随意修改
DSDT
表。在特定的情况下，您也可以考虑与操作系统社区和硬件制造商合作，以获得更准确和可靠的解决方案。</p>
<p>替换操作系统中的 DSDT 表：</p>
<ol type="1">
<li><strong>备份原始 DSDT 表：</strong> 在进行替换之前，务必备份原始的
DSDT 表，以防止出现问题时能够恢复系统。您可以将原始 DSDT
表保存到一个安全的位置。</li>
<li><strong>编辑和编译 DSDT 表：</strong> 使用 AML
编辑器进行编辑和编译您的修改后的 DSDT 表。</li>
<li><strong>将修改后的 DSDT 表嵌入到内核：</strong> 您需要将修改后的
DSDT
表嵌入到操作系统内核中，以便内核能够在启动时使用它。这可能涉及到编译操作系统内核时的一些配置选项。</li>
<li><strong>更新操作系统引导选项：</strong>
您可能需要更新操作系统的引导选项，以确保内核能够加载您修改后的 DSDT
表。这可能涉及到引导加载程序的配置文件（如 GRUB 或 UEFI
引导管理器）。</li>
<li><strong>重启系统：</strong>
在完成上述步骤后，重启计算机以应用修改后的 DSDT 表。</li>
<li><strong>验证和测试：</strong>
在系统重新启动后，务必进行充分的测试和验证，确保修改后的 DSDT
表不会导致系统出现问题。</li>
</ol>
<p>请注意，上述步骤可能因操作系统和硬件而有所不同。修改 DSDT
表是一个风险较高的操作，可能会导致系统无法启动或出现其他严重问题。在进行操作之前，请务必充分了解操作系统和硬件的工作原理，最好在实验环境中进行测试。</p>
<p>如果您不确定如何操作或缺乏相关经验，请考虑寻求专业人士的帮助，或在相关的技术社区寻求建议。</p>
<h2 id="比较文件或路径是否相同抄systemd的代码">比较文件或路径是否相同（抄systemd的代码）：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// 比较两个文件是否相同</span><br><span class="line">int files_same(const char *filea, const char *fileb, int flags) {</span><br><span class="line">        struct stat a, b;</span><br><span class="line"></span><br><span class="line">        assert(filea);</span><br><span class="line">        assert(fileb);</span><br><span class="line"></span><br><span class="line">        if (fstatat(AT_FDCWD, filea, &amp;a, flags) &lt; 0)</span><br><span class="line">                return -errno;</span><br><span class="line"></span><br><span class="line">        if (fstatat(AT_FDCWD, fileb, &amp;b, flags) &lt; 0)</span><br><span class="line">                return -errno;</span><br><span class="line"></span><br><span class="line">        return a.st_dev == b.st_dev &amp;&amp;</span><br><span class="line">               a.st_ino == b.st_ino;</span><br><span class="line">}</span><br><span class="line">// 实现了对两个路径字符串的"排序比较"</span><br><span class="line">int path_compare(const char *a, const char *b) {</span><br><span class="line">        int d;</span><br><span class="line"></span><br><span class="line">        assert(a);</span><br><span class="line">        assert(b);</span><br><span class="line"></span><br><span class="line">        /* A relative path and an absolute path must not compare as equal.</span><br><span class="line">         * Which one is sorted before the other does not really matter.</span><br><span class="line">         * Here a relative path is ordered before an absolute path. */</span><br><span class="line">        d = (a[0] == '/') - (b[0] == '/');</span><br><span class="line">        if (d != 0)</span><br><span class="line">                return d;</span><br><span class="line"></span><br><span class="line">        for (;;) {</span><br><span class="line">                size_t j, k;</span><br><span class="line"></span><br><span class="line">                // 将路径指针 a 和 b 前进到下一个非 / 字符。</span><br><span class="line">                a += strspn(a, "/");</span><br><span class="line">                b += strspn(b, "/");</span><br><span class="line"></span><br><span class="line">                if (*a == 0 &amp;&amp; *b == 0)</span><br><span class="line">                        return 0;</span><br><span class="line"></span><br><span class="line">                /* Order prefixes first: "/foo" before "/foo/bar" */</span><br><span class="line">                if (*a == 0)</span><br><span class="line">                        return -1;</span><br><span class="line">                if (*b == 0)</span><br><span class="line">                        return 1;</span><br><span class="line">                // 这两行计算当前路径段的长度，即下一个 / 之前的字符数。</span><br><span class="line">                j = strcspn(a, "/");</span><br><span class="line">                k = strcspn(b, "/");</span><br><span class="line"></span><br><span class="line">                /* Alphabetical sort: "/foo/aaa" before "/foo/b" */</span><br><span class="line">                // 这行使用 memcmp 函数比较两个路径段的字节内容，最多比较 j 和 k 个字节。</span><br><span class="line">                d = memcmp(a, b, MIN(j, k));</span><br><span class="line">                if (d != 0)</span><br><span class="line">                        return (d &gt; 0) - (d &lt; 0); /* sign of d */</span><br><span class="line"></span><br><span class="line">                /* Sort "/foo/a" before "/foo/aaa" */</span><br><span class="line">                d = (j &gt; k) - (j &lt; k);  /* sign of (j - k) */</span><br><span class="line">                if (d != 0)</span><br><span class="line">                        return d;</span><br><span class="line">                // 这两行将路径指针 a 和 b 前进到下一个 / 之后的位置，以准备比较下一个路径段。</span><br><span class="line">                a += j;</span><br><span class="line">                b += k;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line">//比较路径是否相同</span><br><span class="line">bool path_equal(const char *a, const char *b) {</span><br><span class="line">        return path_compare(a, b) == 0;</span><br><span class="line">}</span><br><span class="line">bool path_equal_or_files_same(const char *a, const char *b, int flags) {</span><br><span class="line">        return path_equal(a, b) || files_same(a, b, flags) &gt; 0;</span><br><span class="line">}</span><br><span class="line">//判断是不是绝对路径</span><br><span class="line">bool path_is_absolute(const char *p) {</span><br><span class="line">        return p[0] == '/';</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="grub菜单显示风格问题">213277 grub菜单显示风格问题</h2>
<ul>
<li>主要原因: theme.txt为空.导致显示的实际是以图形界面显示字符菜单</li>
<li>有关theme.txt,
并没有控制菜单是否有边框的选项.https://www.gnu.org/software/grub/manual/grub/html_node/Theme-file-format.html</li>
</ul>
<h2 id="安装时使用lvm分区第二系统无法正确引导">213181
安装时使用lvm分区第二系统无法正确引导</h2>
<p>此问题关键在/etc/grub.d/30_os-prober:292,
这里是在第二系统中尝试生成menu entry中包含root=的那一行,
其中${LPARAMS}就是root=参数</p>
<p>$LPARAMS获取主要通过linux-boot-prober, 这是一个shell脚本,
在46行会遍历所有/usr/lib/linux-boot-probes/mounted目录下的脚本并尝试搜索grub.cfg,
LPARAMS其实就是linux那一行的运行参数</p>
<p>经过以上分析, 我们知道新生成的grub.cfg与原有的grub.cfg是有关联的.
那么问题的根因也就明了了.</p>
<h2 id="华为适配grub相关问题">华为适配grub相关问题</h2>
<p>主要在/etc/grub.d/00_header.in, 30_uefi-firmware.in
一般的arm设备是不支持背景图片的,华为除外.grub识别华为设备是通过dmidecode
一些调试手段: 其实grub.cfg可以看作是在grub命令行中的一个脚本,
其中所有条目都可以作为命令行在grub命令行中执行. 举例来说:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terminal_output gfxterm 设置图形界面</span><br><span class="line">terminal_output console 设置纯字符界面显示</span><br><span class="line">background_image /grub/themes/deepin/background.jpg 设置背景图片</span><br><span class="line">videoinfo 查看支持分辨率(有时候可能不准)</span><br><span class="line">loadfont ($root)/boot/grub/font.pf2 载入字体, 有时候字符界面出现异常字符可能会和字符集有关</span><br></pre></td></tr></table></figure>
<h2 id="systemd引导阶段出现问题的故障排查">systemd引导阶段出现问题的故障排查</h2>
<ol type="1">
<li><p>启用debug-shell, 此功能一般默认已被屏蔽,
参考https://gerrit.uniontech.com/c/base/systemd/+/23900</p>
<p>241.9-1+dde</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230816152845195.png" alt="image-20230816152845195">
<figcaption aria-hidden="true">image-20230816152845195</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230816152925334.png" alt="image-20230816152925334">
<figcaption aria-hidden="true">image-20230816152925334</figcaption>
</figure></li>
<li><p>systemd.confirm_spawn=1逐步调试 以212431为例进行展开.
此问题最终定位是由于laptop_mode引起, 我们可以尝试查看一下这个项目的代码,
全部由shell组成.</p></li>
</ol>
<p>问题关键点在于1234行, 此处由于使用了&amp;符号使得所有脚本同时执行.
我们可以去掉这个符号, 方便我们调试 需要注意的是,
启动阶段虽然开启了debug-shell, 但是由于启动的早期阶段本地磁盘并未挂载,
修改脚本操作需要在磁盘挂载后进行</p>
<h2 id="section">200217</h2>
<p>一个安全问题. 实际上只是因为合法文件损坏导致. 与其他文件格式相比,
TIFF格式没有CRC校验和字段. 这里可以提出两个问题.
CRC校验的内存占用进一步延伸出md5sum的内存占用是否比TIFF那种直接载入整个文件消耗要小</p>
<h2 id="locale-gen-命令"><code>locale-gen</code> 命令</h2>
<p>代码在glibc中</p>
<p><code>locale-gen</code> 命令主要的工作是根据
<code>/etc/locale.gen</code>
文件中的配置生成所需的本地化数据文件。这些数据文件包括区域设置相关的语言、字符集、货币符号等信息，供系统中的应用程序使用。</p>
<p>在执行 <code>locale-gen</code> 命令时，它会做以下事情：</p>
<ol type="1">
<li><p>读取 <code>/etc/locale.gen</code>
文件，该文件包含了一系列的区域设置配置行，每行表示一种区域设置。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230817141603929.png" alt="image-20230817141603929">
<figcaption aria-hidden="true">image-20230817141603929</figcaption>
</figure></li>
<li><p>对于每个配置行，如果未被注释掉，<code>locale-gen</code>
将根据配置生成对应的本地化数据文件。</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230817141634381.png" alt="image-20230817141634381">
<figcaption aria-hidden="true">image-20230817141634381</figcaption>
</figure></li>
<li><p>生成的本地化数据文件通常保存在 <code>/usr/lib/locale</code>
或类似的目录中，不同发行版可能有所不同。</p></li>
<li><p>在生成数据文件后，<code>locale-gen</code>
命令可能会更新一些系统相关的缓存，以便系统中的应用程序能够快速访问这些本地化数据。</p></li>
</ol>
<h2 id="修改init进程">修改init进程</h2>
<p>可以通过修改grub参数修改init进程,如init=/bin/bash这样的参数</p>
<h2 id="systemd的inhibit机制">systemd的inhibit机制：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230821143614643.png" alt="image-20230821143614643">
<figcaption aria-hidden="true">image-20230821143614643</figcaption>
</figure>
<h2 id="学习下lightdm获取给自己发送信号进程的机制">学习下lightdm获取给自己发送信号进程的机制：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static int signal_pipe[2];</span><br><span class="line"></span><br><span class="line">if (pipe (signal_pipe) != 0)</span><br><span class="line">        g_critical ("Failed to create signal pipe");</span><br><span class="line">    fcntl (signal_pipe[0], F_SETFD, FD_CLOEXEC);</span><br><span class="line">    fcntl (signal_pipe[1], F_SETFD, FD_CLOEXEC);</span><br><span class="line">    g_io_add_watch (g_io_channel_unix_new (signal_pipe[0]), G_IO_IN, handle_signal, NULL);</span><br><span class="line">    action.sa_sigaction = signal_cb;</span><br><span class="line">    sigemptyset (&amp;action.sa_mask);</span><br><span class="line">    action.sa_flags = SA_SIGINFO | SA_RESTART;</span><br><span class="line">    sigaction (SIGTERM, &amp;action, NULL);</span><br><span class="line">    sigaction (SIGINT, &amp;action, NULL);</span><br><span class="line">    sigaction (SIGUSR1, &amp;action, NULL);</span><br><span class="line">    sigaction (SIGUSR2, &amp;action, NULL);</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">signal_cb (int signum, siginfo_t *info, void *data)</span><br><span class="line">{</span><br><span class="line">    /* Check if we are from a forked process that hasn't updated the signal handlers or execed.</span><br><span class="line">       If so, then we should just quit */</span><br><span class="line">    if (getpid () != signal_pid)</span><br><span class="line">        _exit (EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    /* Write signal to main thread, if something goes wrong just close the pipe so it is detected on the other end */</span><br><span class="line">    if (write (signal_pipe[1], &amp;info-&gt;si_signo, sizeof (int)) &lt; 0 ||</span><br><span class="line">        write (signal_pipe[1], &amp;info-&gt;si_pid, sizeof (pid_t)) &lt; 0)</span><br><span class="line">        close (signal_pipe[1]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static gboolean</span><br><span class="line">handle_signal (GIOChannel *source, GIOCondition condition, gpointer data)</span><br><span class="line">{</span><br><span class="line">    errno = 0;</span><br><span class="line">    int signo;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if (read (signal_pipe[0], &amp;signo, sizeof (int)) != sizeof (int) ||</span><br><span class="line">        read (signal_pipe[0], &amp;pid, sizeof (pid_t)) != sizeof (pid_t))</span><br><span class="line">    {</span><br><span class="line">        g_warning ("Error reading from signal pipe: %s", strerror (errno));</span><br><span class="line">        return FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    g_debug ("Got signal %d from process %d", signo, pid);</span><br><span class="line"></span><br><span class="line">    Process *process = g_hash_table_lookup (processes, GINT_TO_POINTER (pid));</span><br><span class="line">    if (process == NULL)</span><br><span class="line">        process = process_get_current ();</span><br><span class="line">    if (process)</span><br><span class="line">        g_signal_emit (process, signals[GOT_SIGNAL], 0, signo);</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="开启和关闭安全管控">开启和关闭安全管控：</h2>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230823100312504.png" alt="image-20230823100312504">
<figcaption aria-hidden="true">image-20230823100312504</figcaption>
</figure>
<h2 id="设置允许任意应用安装">设置允许任意应用安装：</h2>
<p>两种方法：</p>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230823100448905.png" alt="image-20230823100448905">
<figcaption aria-hidden="true">image-20230823100448905</figcaption>
</figure>
<figure>
<img src="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/image-20230823100410141.png" alt="image-20230823100410141">
<figcaption aria-hidden="true">image-20230823100410141</figcaption>
</figure>
<h2 id="kill进程可以这么写函数">kill进程可以这么写函数：</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int kill_and_sigcont(pid_t pid, int sig) {</span><br><span class="line">        int r;</span><br><span class="line"></span><br><span class="line">        r = kill(pid, sig) &lt; 0 ? -errno : 0;</span><br><span class="line"></span><br><span class="line">        /* If this worked, also send SIGCONT, unless we already just sent a SIGCONT, or SIGKILL was sent which isn't</span><br><span class="line">         * affected by a process being suspended anyway. </span><br><span class="line">         如果这有效，也发送 SIGCONT，除非我们刚刚发送了 SIGCONT，或者发送了 SIGKILL，而该 SIGKILL 无论如何都不受进程挂起的影响。*/</span><br><span class="line"></span><br><span class="line">        //  SIGTERM信号会通知进程终止，但进程并不一定会立即终止。进程可能会忽略SIGTERM信号，或者它可能会终止，</span><br><span class="line">        // 但需要一些时间。发送SIGCONT信号可以确保进程在收到SIGTERM信号后立即终止，即使进程正在暂停状态。</span><br><span class="line">        if (r &gt;= 0 &amp;&amp; !IN_SET(sig, SIGCONT, SIGKILL))</span><br><span class="line">                (void) kill(pid, SIGCONT);</span><br><span class="line"></span><br><span class="line">        return r;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://blog.705553939.xyz">ALTNT</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/">http://blog.705553939.xyz/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%B5%84%E6%96%99/">资料</a></div><div class="post_share"><div class="social-share" data-image="/img/altnt.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="机器学习相关概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">机器学习相关概念</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/" title="数据库系统概论笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据库系统概论笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/07/27/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A42/" title="命令2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">命令2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/altnt.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ALTNT</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ALTNT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#hexo%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">hexo命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hexo%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.</span> <span class="toc-text">hexo添加对数学公式的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">docker 命令:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmacvlan%E7%BD%91%E7%BB%9C"><span class="toc-number">2.1.</span> <span class="toc-text">创建macvlan网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">制作docker镜像并创建容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">生成并运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97"><span class="toc-number">2.4.</span> <span class="toc-text">查看实时日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">进入容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%8B%E7%BC%93%E5%AD%98%E6%83%85%E5%86%B5"><span class="toc-number">2.7.</span> <span class="toc-text">查看一下缓存情况：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">2.8.</span> <span class="toc-text">docker国内镜像加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-pull-%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E6%97%B6%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-number">2.9.</span> <span class="toc-text">docker pull
拉取镜像时设置代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-%E9%95%9C%E5%83%8F%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86"><span class="toc-number">2.10.</span> <span class="toc-text">build 镜像时使用代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-docker-%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86"><span class="toc-number">2.11.</span> <span class="toc-text">设置 docker 全局代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.12.</span> <span class="toc-text">容器使用宿主机的代理的几种方法总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">git配置和取消代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clash%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">clash配置代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-proxy-manager%E8%BE%93%E5%85%A5%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%82%B9%E5%87%BB%E7%99%BB%E5%BD%95%E5%8D%B4%E9%81%87%E5%88%B0bad-gateway"><span class="toc-number">5.</span> <span class="toc-text">Nginx Proxy
Manager输入账号密码点击登录却遇到bad gateway</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%9B%98%E5%88%BB%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">光盘刻录：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.</span> <span class="toc-text">时区设置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tensorboard"><span class="toc-number">8.</span> <span class="toc-text">tensorboard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%B0%81%E6%89%A7%E8%A1%8C%E4%BA%86%E6%9F%90%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="toc-number">9.</span> <span class="toc-text">查看谁执行了某条命令:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quilt%E9%85%8D%E7%BD%AE"><span class="toc-number">10.</span> <span class="toc-text">quilt配置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wpa_cli"><span class="toc-number">11.</span> <span class="toc-text">wpa_cli:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%94%B5%E8%84%91%E6%94%AF%E4%B8%8D%E6%94%AF%E6%8C%81wpa"><span class="toc-number">12.</span> <span class="toc-text">查看电脑支不支持wpa：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">13.</span> <span class="toc-text">删除已连接的网络：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AAsignal_fd"><span class="toc-number">14.</span> <span class="toc-text">跟踪signal_fd:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">查找被隐藏的进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95"><span class="toc-number">16.</span> <span class="toc-text">配置ssh免密登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssh%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D"><span class="toc-number">17.</span> <span class="toc-text">ssh设置别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8root-ssh%E7%99%BB%E5%BD%95"><span class="toc-number">18.</span> <span class="toc-text">禁用root ssh登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pnpm%E5%92%8Cnpm%E4%BB%A5%E5%8F%8Ayarn"><span class="toc-number">19.</span> <span class="toc-text">pnpm和npm以及yarn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pnpm%E5%92%8Cnpm%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">19.1.</span> <span class="toc-text">pnpm和npm的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pnpm"><span class="toc-number">19.2.</span> <span class="toc-text">pnpm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85pnpm"><span class="toc-number">19.2.1.</span> <span class="toc-text">安装pnpm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="toc-number">19.2.2.</span> <span class="toc-text">pnpm安装依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm-tauri-dev"><span class="toc-number">19.2.3.</span> <span class="toc-text">pnpm tauri dev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm%E5%91%BD%E4%BB%A4"><span class="toc-number">19.2.4.</span> <span class="toc-text">pnpm命令:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tauri"><span class="toc-number">20.</span> <span class="toc-text">tauri</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm"><span class="toc-number">20.1.</span> <span class="toc-text">npm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3npm-err-request-to-httpsregistry.npm.taobao.orgpnpm-failed-reason-certificate-has-expired"><span class="toc-number">20.1.1.</span> <span class="toc-text">如何解决npm
ERR! request to https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;pnpm failed, reason:
certificate has expired</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm-cache-clean---force%E6%B8%85%E7%90%86%E7%9A%84%E6%98%AF%E5%93%AA%E9%87%8C%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">20.1.2.</span> <span class="toc-text">npm cache clean
--force清理的是哪里的缓存?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm-fund"><span class="toc-number">20.1.3.</span> <span class="toc-text">npm fund</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm-list"><span class="toc-number">20.1.4.</span> <span class="toc-text">npm list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm%E9%A1%B9%E7%9B%AE-package.json"><span class="toc-number">20.1.5.</span> <span class="toc-text">npm项目 package.json</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#scripts%E5%AD%97%E6%AE%B5"><span class="toc-number">20.1.5.1.</span> <span class="toc-text">scripts字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yarn"><span class="toc-number">20.2.</span> <span class="toc-text">yarn</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webview"><span class="toc-number">21.</span> <span class="toc-text">webview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webview%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">21.1.</span> <span class="toc-text">webview是什么?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rust"><span class="toc-number">22.</span> <span class="toc-text">Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cargo"><span class="toc-number">22.1.</span> <span class="toc-text">cargo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cargo-%E5%8A%9F%E8%83%BD"><span class="toc-number">22.1.1.</span> <span class="toc-text">Cargo 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84rust%E9%A1%B9%E7%9B%AE"><span class="toc-number">22.1.2.</span> <span class="toc-text">创建一个最简单的rust项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91rust%E4%BB%A3%E7%A0%81"><span class="toc-number">22.1.3.</span> <span class="toc-text">编译rust代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-vscode-%E4%B8%AD%E9%85%8D%E7%BD%AE-rust-%E5%B7%A5%E7%A8%8B"><span class="toc-number">22.1.4.</span> <span class="toc-text">在 VSCode 中配置 Rust 工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-number">22.1.5.</span> <span class="toc-text">rust声明变量:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust%E5%87%BD%E6%95%B0"><span class="toc-number">22.1.6.</span> <span class="toc-text">Rust函数:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">22.1.7.</span> <span class="toc-text">Rust 条件语句:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E5%BE%AA%E7%8E%AF"><span class="toc-number">22.1.8.</span> <span class="toc-text">Rust 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rust-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">22.1.8.1.</span> <span class="toc-text">rust while循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rust-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">22.1.8.2.</span> <span class="toc-text">rust for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rust-loop-%E5%BE%AA%E7%8E%AF%E7%9B%B8%E5%BD%93%E4%BA%8Ewhiletrue"><span class="toc-number">22.1.8.3.</span> <span class="toc-text">rust loop
循环(相当于while(true))</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">22.1.9.</span> <span class="toc-text">Rust 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-for-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">22.1.9.1.</span> <span class="toc-text">使用 for 循环遍历迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">22.1.9.2.</span> <span class="toc-text">消费迭代器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E9%97%AD%E5%8C%85"><span class="toc-number">22.1.10.</span> <span class="toc-text">Rust 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">22.1.10.1.</span> <span class="toc-text">使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">22.1.10.1.1.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">22.1.10.1.2.</span> <span class="toc-text">捕获外部变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="toc-number">22.1.10.1.3.</span> <span class="toc-text">移动与借用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">22.1.11.</span> <span class="toc-text">Rust 所有权</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">22.1.11.1.</span> <span class="toc-text">所有权规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">22.1.11.2.</span> <span class="toc-text">变量与数据交互的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8"><span class="toc-number">22.1.11.2.1.</span> <span class="toc-text">移动</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%8B%E9%9A%86"><span class="toc-number">22.1.11.2.2.</span> <span class="toc-text">克隆</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="toc-number">22.1.11.3.</span> <span class="toc-text">涉及函数的所有权机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="toc-number">22.1.11.4.</span> <span class="toc-text">函数返回值的所有权机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%9F%E5%80%9F"><span class="toc-number">22.1.11.5.</span> <span class="toc-text">引用与租借</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%82%E6%82%AC%E5%BC%95%E7%94%A8dangling-references"><span class="toc-number">22.1.11.6.</span> <span class="toc-text">垂悬引用（Dangling
References）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-slice%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B%E4%B8%8D%E9%9A%BE"><span class="toc-number">22.1.12.</span> <span class="toc-text">Rust Slice（切片）类型(不难)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">22.1.12.1.</span> <span class="toc-text">字符串切片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">22.1.12.2.</span> <span class="toc-text">非字符串切片</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">22.1.13.</span> <span class="toc-text">Rust 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">22.1.13.1.</span> <span class="toc-text">结构体定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B"><span class="toc-number">22.1.13.2.</span> <span class="toc-text">结构体实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">22.1.13.3.</span> <span class="toc-text">元组结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">22.1.13.4.</span> <span class="toc-text">结构体所有权</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">22.1.13.5.</span> <span class="toc-text">输出结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.13.6.</span> <span class="toc-text">结构体方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">22.1.13.7.</span> <span class="toc-text">结构体关联函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">22.1.13.8.</span> <span class="toc-text">单元结构体</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">22.1.14.</span> <span class="toc-text">Rust 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#match-%E8%AF%AD%E6%B3%95"><span class="toc-number">22.1.14.1.</span> <span class="toc-text">match 语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#option-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">22.1.14.2.</span> <span class="toc-text">Option 枚举类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if-let-%E8%AF%AD%E6%B3%95"><span class="toc-number">22.1.14.3.</span> <span class="toc-text">if let 语法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86"><span class="toc-number">22.1.15.</span> <span class="toc-text">Rust 组织管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%B1crate"><span class="toc-number">22.1.15.1.</span> <span class="toc-text">箱（Crate）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85package"><span class="toc-number">22.1.15.2.</span> <span class="toc-text">包（Package）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97module"><span class="toc-number">22.1.15.3.</span> <span class="toc-text">模块（Module）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">22.1.15.4.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%BE%E4%BB%A5%E5%8F%91%E7%8E%B0%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">22.1.15.5.</span> <span class="toc-text">难以发现的模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#use-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.1.15.6.</span> <span class="toc-text">use 关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">22.1.15.7.</span> <span class="toc-text">引用标准库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">22.1.16.</span> <span class="toc-text">Rust 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF"><span class="toc-number">22.1.16.1.</span> <span class="toc-text">不可恢复错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">22.1.16.2.</span> <span class="toc-text">可恢复的错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">22.1.16.3.</span> <span class="toc-text">可恢复的错误的传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kind-%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.16.4.</span> <span class="toc-text">kind 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-number">22.1.17.</span> <span class="toc-text">Rust 泛型与特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">22.1.17.1.</span> <span class="toc-text">在函数中定义泛型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">22.1.17.2.</span> <span class="toc-text">结构体与枚举类中的泛型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7trait"><span class="toc-number">22.1.17.3.</span> <span class="toc-text">特性（trait）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%89%B9%E6%80%A7"><span class="toc-number">22.1.17.4.</span> <span class="toc-text">默认特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E5%81%9A%E5%8F%82%E6%95%B0"><span class="toc-number">22.1.17.5.</span> <span class="toc-text">特性做参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">22.1.17.6.</span> <span class="toc-text">特性做返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.17.7.</span> <span class="toc-text">有条件实现方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">22.1.18.</span> <span class="toc-text">Rust 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A"><span class="toc-number">22.1.18.1.</span> <span class="toc-text">生命周期注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87%E5%BC%95%E7%94%A8"><span class="toc-number">22.1.18.2.</span> <span class="toc-text">结构体中使用字符串切片引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">22.1.18.3.</span> <span class="toc-text">静态生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8D%8F%E5%90%8C%E4%BD%9C%E6%88%98"><span class="toc-number">22.1.18.4.</span> <span class="toc-text">泛型、特性与生命周期协同作战</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.1.19.</span> <span class="toc-text">Rust 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">22.1.19.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">22.1.19.2.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E5%AE%8F"><span class="toc-number">22.1.20.</span> <span class="toc-text">Rust 宏</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">22.1.20.1.</span> <span class="toc-text">宏的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">22.1.20.2.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%AE%8Fprocedural-macros"><span class="toc-number">22.1.20.3.</span> <span class="toc-text">过程宏（Procedural Macros）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.</span> <span class="toc-text">Rust 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#box-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.1.</span> <span class="toc-text">Box &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rc-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.2.</span> <span class="toc-text">Rc &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arc-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.3.</span> <span class="toc-text">Arc &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#refcell-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.4.</span> <span class="toc-text">RefCell &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mutex-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.5.</span> <span class="toc-text">Mutex &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rwlock-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.6.</span> <span class="toc-text">RwLock &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#weak-t-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">22.1.21.7.</span> <span class="toc-text">Weak &lt;T&gt; 智能指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">22.1.21.8.</span> <span class="toc-text">智能指针的生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">22.1.21.8.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">22.1.21.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">22.1.22.</span> <span class="toc-text">Rust 并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">22.1.22.1.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#join-%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.22.2.</span> <span class="toc-text">join 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#move-%E5%BC%BA%E5%88%B6%E6%89%80%E6%9C%89%E6%9D%83%E8%BF%81%E7%A7%BB"><span class="toc-number">22.1.22.3.</span> <span class="toc-text">move 强制所有权迁移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">22.1.22.4.</span> <span class="toc-text">消息传递</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rust-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-asyncawait"><span class="toc-number">22.1.23.</span> <span class="toc-text">Rust 异步编程 async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">22.1.23.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">22.1.23.2.</span> <span class="toc-text">异步编程说明</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#async-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.1.23.2.1.</span> <span class="toc-text">async 关键字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#await-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.1.23.2.2.</span> <span class="toc-text">await 关键字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">22.1.23.2.3.</span> <span class="toc-text">异步函数返回值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9D%97"><span class="toc-number">22.1.23.2.4.</span> <span class="toc-text">异步块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">22.1.23.2.5.</span> <span class="toc-text">异步任务执行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">22.1.23.2.6.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-trait-%E6%96%B9%E6%B3%95"><span class="toc-number">22.1.23.2.7.</span> <span class="toc-text">异步 trait 方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">22.1.23.2.8.</span> <span class="toc-text">异步上下文</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%8F"><span class="toc-number">22.1.23.2.9.</span> <span class="toc-text">异步宏</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-io"><span class="toc-number">22.1.23.2.10.</span> <span class="toc-text">异步 I&#x2F;O</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">22.1.23.2.11.</span> <span class="toc-text">异步通道</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode-%E4%B8%ADtasks.json%E5%92%8Claunch.json%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">23.</span> <span class="toc-text">.vscode
中tasks.json和launch.json的作用是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bpfcc%E5%9C%A85.10%E5%86%85%E6%A0%B8%E4%B8%8A%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3"><span class="toc-number">24.</span> <span class="toc-text">bpfcc在5.10内核上不可用解决:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#curl"><span class="toc-number">25.</span> <span class="toc-text">curl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91"><span class="toc-number">26.</span> <span class="toc-text">内核编译：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#whether-in-the-real-environment"><span class="toc-number">27.</span> <span class="toc-text">Whether in the real
environment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDwpa%E6%9C%80%E4%B8%8A%E6%B8%B8%E6%BA%90%E7%A0%81"><span class="toc-number">28.</span> <span class="toc-text">下载wpa最上游源码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8wpa%E5%BC%80%E7%83%AD%E7%82%B9"><span class="toc-number">29.</span> <span class="toc-text">使用wpa开热点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BD%91%E7%BB%9C-1"><span class="toc-number">30.</span> <span class="toc-text">删除已连接的网络：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vim%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">31.</span> <span class="toc-text">vim快捷键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vim%E5%BF%AB%E9%80%9F%E8%B7%B3%E8%BD%AC"><span class="toc-number">31.1.</span> <span class="toc-text">vim快速跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.%E6%8C%89%E5%8D%95%E8%AF%8D%E8%B7%B3%E8%BD%AC%E5%8F%AF%E4%BB%A5%E8%B7%A8%E8%A1%8C%E8%B7%B3%E8%BD%AC"><span class="toc-number">32.</span> <span class="toc-text">一.按单词跳转(可以跨行跳转)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C.%E8%A1%8C%E5%86%85%E8%B7%B3%E8%BD%AC"><span class="toc-number">32.0.1.</span> <span class="toc-text">二.行内跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89.%E8%A1%8C%E5%86%85%E6%9F%A5%E6%89%BE%E5%B9%B6%E8%B7%B3%E8%BD%AC"><span class="toc-number">32.0.2.</span> <span class="toc-text">三.行内查找并跳转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-%E8%B7%B3%E8%BD%AC%E6%8C%87%E5%AE%9A%E8%A1%8C"><span class="toc-number">32.0.3.</span> <span class="toc-text">四、 跳转指定行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">32.1.</span> <span class="toc-text">vim替换模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim%E4%B8%AD%E5%90%AF%E7%94%A8%E9%BC%A0%E6%A0%87"><span class="toc-number">32.2.</span> <span class="toc-text">Vim中启用鼠标:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bvim%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%89%AA%E5%88%87%E6%9D%BF"><span class="toc-number">33.</span> <span class="toc-text">查看vim是否支持剪切板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpio%E6%A0%BC%E5%BC%8F-initrd-%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9"><span class="toc-number">34.</span> <span class="toc-text">cpio格式 initrd 的解压与压缩:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86initrdinitramfs"><span class="toc-number">35.</span> <span class="toc-text">第二部分：initrd、initramfs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debian-linux-%E5%86%85%E6%A0%B8%E6%89%8B%E5%86%8C"><span class="toc-number">36.</span> <span class="toc-text">Debian Linux 内核手册：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E5%99%A8-gdb-%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86"><span class="toc-number">37.</span> <span class="toc-text">Linux
下常用的程序调试器 gdb 是什么原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">38.</span> <span class="toc-text">断点的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E8%8B%B1%E4%BC%9F%E8%BE%BE%E9%A9%B1%E5%8A%A8"><span class="toc-number">39.</span> <span class="toc-text">重新安装英伟达驱动：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nvidia%E5%BC%80%E5%90%AFdrm%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">40.</span> <span class="toc-text">nvidia开启drm的设置：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dbus-send"><span class="toc-number">41.</span> <span class="toc-text">dbus-send：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-d-bus-%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E8%B7%9Fd-feet%E6%89%93%E5%8D%B0%E7%9A%84%E7%B1%BB%E4%BC%BC"><span class="toc-number">42.</span> <span class="toc-text">通过 D-Bus
访问接口，跟d-feet打印的类似：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E6%89%93%E5%8D%B0%E9%9D%9E%E4%BB%A50%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">42.1.</span> <span class="toc-text">一种打印非以&#39;\0&#39;结尾的字符串的方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libinput"><span class="toc-number">43.</span> <span class="toc-text">Libinput：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libevdev%E4%B8%ADlibevdev-events.c%E6%96%87%E4%BB%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="toc-number">43.1.</span> <span class="toc-text">libevdev中libevdev-events.c文件对应的命令是什么？怎么使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9Adevinputeventx%E5%91%A2%E6%AF%94%E5%A6%82%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E8%A7%A6%E6%91%B8%E6%9D%BF%E8%AE%BE%E5%A4%87%E5%AF%B9%E5%BA%94%E5%93%AA%E4%B8%AAevent%E5%AE%9E%E9%99%85%E4%B8%8A%E6%B2%A1%E8%BF%99%E4%B9%88%E9%BA%BB%E7%83%A6%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8libinput-debug-events%E7%84%B6%E5%90%8E%E7%A7%BB%E5%8A%A8%E9%BC%A0%E6%A0%87%E5%B0%B1%E8%A1%8C%E4%BA%86"><span class="toc-number">43.2.</span> <span class="toc-text">如何确定&#x2F;dev&#x2F;input&#x2F;eventx呢？比如我想知道触摸板设备对应哪个event（实际上没这么麻烦，直接使用libinput
debug-events然后移动鼠标就行了）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldconfig"><span class="toc-number">44.</span> <span class="toc-text">ldconfig:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F"><span class="toc-number">45.</span> <span class="toc-text">安装双系统：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA%E6%9C%BA%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">46.</span> <span class="toc-text">华为机型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd-analyze%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%BC%80%E6%9C%BA%E6%97%B6%E9%97%B4%E7%9A%84"><span class="toc-number">47.</span> <span class="toc-text">systemd-analyze是如何统计开机时间的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#firmware%E5%92%8Cloader"><span class="toc-number">47.1.</span> <span class="toc-text">firmware和loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel"><span class="toc-number">47.2.</span> <span class="toc-text">kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmake%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="toc-number">48.</span> <span class="toc-text">CMake基础学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mount"><span class="toc-number">49.</span> <span class="toc-text">Mount:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gdb%E6%89%93%E5%8D%B0%E6%89%80%E6%9C%89%E5%A0%86%E6%A0%88"><span class="toc-number">50.</span> <span class="toc-text">GDB打印所有堆栈：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B2%E7%8F%91%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-number">51.</span> <span class="toc-text">玲珑包工具：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trace-cmd"><span class="toc-number">52.</span> <span class="toc-text">trace-cmd:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apparmor%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-number">53.</span> <span class="toc-text">apparmor官方文档：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scsi%E8%AE%BE%E5%A4%87%E6%89%AB%E6%8F%8F"><span class="toc-number">54.</span> <span class="toc-text">scsi设备扫描：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">55.</span> <span class="toc-text">休眠的实现：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openssl-%E8%B0%83%E8%AF%95"><span class="toc-number">56.</span> <span class="toc-text">openssl 调试:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8Crtc%E9%97%AE%E9%A2%98%E5%8F%82%E8%80%83190897"><span class="toc-number">57.</span> <span class="toc-text">双rtc问题（参考190897）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shutdownreboot"><span class="toc-number">58.</span> <span class="toc-text">Shutdown&#x2F;reboot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd%E5%B8%B8%E8%A7%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">59.</span> <span class="toc-text">systemd常规启动流程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initrdinitial-ram-disk-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">60.</span> <span class="toc-text">initrd(Initial RAM Disk)
启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%9C%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">61.</span> <span class="toc-text">关机流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0d%E7%8A%B6%E6%80%81%E7%A8%8B%E5%BA%8F%E5%90%8E%E6%89%93%E5%8D%B0%E5%86%85%E6%A0%B8%E5%A0%86%E6%A0%88"><span class="toc-number">62.</span> <span class="toc-text">出现D状态程序后打印内核堆栈：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E5%8F%98%E9%87%8D%E5%90%AF%E9%97%AE%E9%A2%98"><span class="toc-number">63.</span> <span class="toc-text">休眠变重启问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BA"><span class="toc-number">64.</span> <span class="toc-text">虚拟机搭建：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E6%A1%A5%E6%8E%A5"><span class="toc-number">64.0.1.</span> <span class="toc-text">设置网络桥接</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E8%A6%81%E5%81%9C%E6%AD%A2%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="toc-number">64.0.1.0.1.</span> <span class="toc-text">首先：要停止网络服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E6%AC%A1%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">64.0.1.0.2.</span> <span class="toc-text">其次：修改网络配置文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AEip"><span class="toc-number">64.0.1.0.3.</span> <span class="toc-text">手动设置ip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E4%BB%8Edhcp%E8%8E%B7%E5%8F%96ip"><span class="toc-number">64.0.1.0.4.</span> <span class="toc-text">自动从DHCP获取ip</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E4%BE%BF%E5%8F%AF"><span class="toc-number">64.0.1.0.5.</span> <span class="toc-text">最后：重新启动网络服务便可</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E6%AF%8F%E6%AC%A1%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%A5network%E7%9B%B8%E5%85%B3%E9%94%99%E8%AF%AF%E5%B0%B1%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">64.0.1.0.6.</span> <span class="toc-text">启用虚拟网络(每次启动虚拟机报network相关错误就执行命令)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x11%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">65.</span> <span class="toc-text">X11获取设备信息:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-is-enabled-%E8%BF%94%E5%9B%9E-indirect-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">66.</span> <span class="toc-text">systemctl
is-enabled 返回 indirect 是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-enable-a.service%E5%90%8E%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%90%8E%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%90%AF%E5%8A%A8a.service%E5%8F%AA%E6%98%AF%E8%B5%B7%E4%BA%86a.socket%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">67.</span> <span class="toc-text">systemctl
enable
A.service后，开机启动后并没有启动A.service，只是起了A.socket，这是为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%ADservice%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A2%AB%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8D%95%E5%85%83"><span class="toc-number">68.</span> <span class="toc-text">怎么判断service是一个被动的服务单元？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%98%AF%E8%A2%AB%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%8D%95%E5%85%83%E5%90%97-%E4%BB%8E%E5%93%AA%E4%B8%AA%E5%9C%B0%E6%96%B9%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA"><span class="toc-number">69.</span> <span class="toc-text">这个服务是被动服务单元吗
？ 从哪个地方可以看出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-enable-%E6%AD%A4%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88-enable%E4%B9%8B%E5%90%8E%E5%BC%80%E6%9C%BA%E5%AF%B9%E6%AD%A4%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">70.</span> <span class="toc-text">systemctl
enable 此服务会做什么？ enable之后开机对此服务会做什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-enable%E4%B8%8A%E9%9D%A2%E8%BF%99%E4%B8%AAservice%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88-enable%E4%B9%8B%E5%90%8E%E5%BC%80%E6%9C%BA%E6%AD%A4%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%90%AF%E5%8A%A8%E5%90%97"><span class="toc-number">71.</span> <span class="toc-text">systemctl
enable上面这个service会做什么？ enable之后开机此服务会启动吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#audit%E5%AE%A1%E8%AE%A1"><span class="toc-number">72.</span> <span class="toc-text">audit审计：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E4%BF%AE%E6%94%B9etcshadow%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">73.</span> <span class="toc-text">1.手动修改&#x2F;etc&#x2F;shadow中的用户密码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">gdb调试宏定义并显示宏定义的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-aclaccess-control-list%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">Linux ACL(access
control list)访问控制权限列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%81%E6%98%8A%E7%9A%84%E7%AC%94%E8%AE%B0"><span class="toc-number">2.</span> <span class="toc-text">丁昊的笔记：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tmux%E6%95%99%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">tmux教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.1.</span> <span class="toc-text">新建会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E4%BC%9A%E8%AF%9D%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D-tmux-%E7%AA%97%E5%8F%A3%E4%BD%86%E6%98%AF%E4%BC%9A%E8%AF%9D%E5%92%8C%E9%87%8C%E9%9D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BB%8D%E7%84%B6%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">3.2.</span> <span class="toc-text">分离会话(退出当前
Tmux 窗口，但是会话和里面的进程仍然在后台运行)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%80%E6%AD%BB%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.3.</span> <span class="toc-text">杀死会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.4.</span> <span class="toc-text">切换会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.5.</span> <span class="toc-text">重命名会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%89%80%E6%9C%89%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.6.</span> <span class="toc-text">关闭所有会话：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.7.</span> <span class="toc-text">会话快捷键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tmux%E6%96%87%E6%9C%AC%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">tmux文本复制模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%B8%8A%E9%9D%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E7%9A%84%E5%86%85%E5%AE%B9%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF"><span class="toc-number">4.1.</span> <span class="toc-text">将上面缓冲区内的内容自动复制到系统剪切板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#macos"><span class="toc-number">4.1.1.</span> <span class="toc-text">macos</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux"><span class="toc-number">4.1.2.</span> <span class="toc-text">linux</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ubuntu-tmux-%E5%90%AF%E7%94%A8%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8"><span class="toc-number">5.</span> <span class="toc-text">Ubuntu Tmux 启用鼠标滚动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">qemu虚拟机的配置文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#my_log_info"><span class="toc-number">7.</span> <span class="toc-text">my_log_info:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">C语言打印函数堆栈方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E4%BB%93%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">内网仓库：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blkid--l--t-uuid9cd72106-5e81-4860-a8e1-8285bc74a5ac--o-device"><span class="toc-number">2.</span> <span class="toc-text">blkid
-l -t &quot;UUID&#x3D;9cd72106-5e81-4860-a8e1-8285bc74a5ac&quot; -o device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usrlibklibcbinfstype%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">&#x2F;usr&#x2F;lib&#x2F;klibc&#x2F;bin&#x2F;fstype原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E7%9A%84%E6%89%80%E4%BB%A5%E5%B7%B2%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">查看某个版本号对应的包的所以已安装包：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdpkg%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">查看dpkg安装过程的详细信息：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E8%BF%99%E4%B8%AA%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95pcie-bus-error"><span class="toc-number">6.</span> <span class="toc-text">报这个错的解决方法(PCIe Bus
Error):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFcoredump"><span class="toc-number">7.</span> <span class="toc-text">开启coredump：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">设置格式：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%AF%B9%E5%BA%94%E7%9A%84limit%E9%85%8D%E7%BD%AE"><span class="toc-number">8.1.</span> <span class="toc-text">查看某个运行中的进程对应的limit配置：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%E7%94%9F%E6%88%90coredump%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">使用内核机制生成coredump的过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gvfs"><span class="toc-number">10.</span> <span class="toc-text">gvfs:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87syslog%E8%BF%87%E6%BB%A4%E7%A8%8B%E5%BA%8F%E9%80%80%E5%87%BA%E7%9A%84%E6%97%A5%E5%BF%97%E5%8F%AF%E7%94%A8%E6%9D%A5%E7%A0%94%E7%A9%B6%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">通过syslog过滤程序退出的日志（可用来研究关机重启超时问题）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2java"><span class="toc-number">12.</span> <span class="toc-text">切换java：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2iptable"><span class="toc-number">13.</span> <span class="toc-text">切换iptable：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iptables"><span class="toc-number"></span> <span class="toc-text">iptables</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">基本参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9%E8%BE%93%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">命令选项输入顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.2.</span> <span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.3.</span> <span class="toc-text">防火墙的策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">1.1.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E5%BD%93%E5%89%8D%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%84%E5%88%99%E5%92%8C%E8%AE%A1%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">清空当前的所有规则和计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%85%81%E8%AE%B8ssh%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">配置允许ssh端口连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E6%9C%AC%E5%9C%B0%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">允许本地回环地址可以正常使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.4.</span> <span class="toc-text">设置默认的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%99%BD%E5%90%8D%E5%8D%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">配置白名单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E7%9B%B8%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">开启相应的服务端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E8%A7%84%E5%88%99%E5%88%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.1.7.</span> <span class="toc-text">保存规则到配置文件中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%B7%B2%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.8.</span> <span class="toc-text">列出已设置的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%B7%B2%E6%9C%89%E8%A7%84%E5%88%99"><span class="toc-number">1.1.9.</span> <span class="toc-text">清除已有规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.10.</span> <span class="toc-text">删除已添加的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.1.11.</span> <span class="toc-text">开放指定的端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E8%94%BDip"><span class="toc-number">1.1.12.</span> <span class="toc-text">屏蔽IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%8C%85%E5%87%BA%E5%8E%BB%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.13.</span> <span class="toc-text">指定数据包出去的网络接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.14.</span> <span class="toc-text">查看已添加的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99"><span class="toc-number">1.1.15.</span> <span class="toc-text">启动网络转发规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-number">1.1.16.</span> <span class="toc-text">端口映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.17.</span> <span class="toc-text">字符串匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2windows%E8%A0%95%E8%99%AB%E7%9A%84%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.18.</span> <span class="toc-text">阻止Windows蠕虫的攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2syn%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.19.</span> <span class="toc-text">防止SYN洪水攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0secmark%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.20.</span> <span class="toc-text">添加SECMARK记录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Biptables-%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99%E7%9A%84%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%A6%82%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">查看iptables
加入规则的流程大概是这样的：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">更多实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.</span> <span class="toc-text">使用场景实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iptables-legacy-%E4%B8%8E-iptables-nft-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">iptables-legacy
与 iptables-nft 的关系与区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-iptables-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.</span> <span class="toc-text">与
iptables 命令的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87wayland"><span class="toc-number">5.</span> <span class="toc-text">切wayland :</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8Blive%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">解压live系统：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2socket"><span class="toc-number">7.</span> <span class="toc-text">查询socket:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AAso%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">调试使用某个so文件的进程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libinput%E9%98%B2%E8%AF%AF%E8%A7%A6%E9%85%8D%E7%BD%AE"><span class="toc-number">8.1.</span> <span class="toc-text">libinput防误触配置：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E5%9F%9F%E7%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">禁用域管：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%98%AF%E5%90%A6%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC"><span class="toc-number">10.</span> <span class="toc-text">获取是否是笔记本：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service%E6%96%87%E4%BB%B6%E6%8B%92%E7%BB%9D%E6%89%8B%E5%8A%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">11.</span> <span class="toc-text">service文件拒绝手动启动：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd-service-%E4%BE%9D%E8%B5%96"><span class="toc-number">12.</span> <span class="toc-text">systemd service 依赖:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96"><span class="toc-number">12.1.</span> <span class="toc-text">一、自动依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E4%BE%9D%E8%B5%96"><span class="toc-number">12.1.1.</span> <span class="toc-text">1、隐含依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E4%BE%9D%E8%B5%96"><span class="toc-number">12.1.2.</span> <span class="toc-text">2、默认依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd-service%E4%B8%AD%E7%9A%84before-%E5%92%8Cafter%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.2.</span> <span class="toc-text">systemd
service中的Before&#x3D; 和After&#x3D;代表的含义是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88systemd-machine-id-commit.service%E4%B8%AD%E6%98%8E%E6%98%8E%E8%AE%BE%E7%BD%AE%E4%BA%86beforesysinit.target-shutdown.target%E4%BD%86%E6%98%AFsystemctl-list-dependences%E5%8D%B4%E6%98%BE%E7%A4%BAsystemd-machine-id-commit.service%E4%BE%9D%E8%B5%96sysinit.target"><span class="toc-number">12.2.1.</span> <span class="toc-text">为什么systemd-machine-id-commit.service中明明设置了Before&#x3D;sysinit.target
shutdown.target，但是systemctl
list-dependences却显示systemd-machine-id-commit.service依赖sysinit.target</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#before-after%E5%92%8Cwantedby%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.3.</span> <span class="toc-text">before
After和Wantedby的区别是什么：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemd-%E5%8D%95%E5%85%83%E7%9A%84dependenciesunit_referenced_by%E5%92%8Cdependenciesunit_references%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.4.</span> <span class="toc-text">systemd
单元的dependencies[UNIT_REFERENCED_BY]和dependencies[UNIT_REFERENCES]的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl-set-default%E5%85%B3%E9%97%AD%E5%92%8C%E5%BC%80%E5%90%AF%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="toc-number">13.</span> <span class="toc-text">systemctl
set-default(关闭和开启图形化界面):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tmp%E7%9B%AE%E5%BD%95%E8%A2%AB%E6%B8%85%E7%A9%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.</span> <span class="toc-text">&#x2F;tmp目录被清空实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kms%E6%BF%80%E6%B4%BB%E7%A0%81"><span class="toc-number">15.</span> <span class="toc-text">kms激活码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sd_bus_add_match_async-%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">sd_bus_add_match_async 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session-c1-device-226-0%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">17.</span> <span class="toc-text">session-c1-device-226-0代表什么意思:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdeb%E5%8C%85dbg%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-number">18.</span> <span class="toc-text">查看deb包dbg调试信息：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8C%85%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">18.1.</span> <span class="toc-text">判断一个包是否已安装的代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E6%9B%BF%E6%8D%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84shell%E5%91%BD%E4%BB%A4"><span class="toc-number">18.2.</span> <span class="toc-text">shell替换软件包版本号的shell命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#echo--e-aaaa-sed-s.1xxg-tr"><span class="toc-number">18.3.</span> <span class="toc-text">echo -e &quot;aaaa&quot; | sed
&#39;s&#x2F;(.*)&#x2F;\1&#x3D;xx&#x2F;g&#39; | tr &#39;&#39; &#39; &#39;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#usbip%E8%AE%BE%E7%BD%AEu%E7%9B%98%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">19.</span> <span class="toc-text">usbip设置u盘重定向：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95dde-daemon"><span class="toc-number">20.</span> <span class="toc-text">调试dde-daemon：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E8%A1%A5%E4%B8%81"><span class="toc-number">21.</span> <span class="toc-text">打补丁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E6%92%A4%E9%94%80amend"><span class="toc-number">22.</span> <span class="toc-text">git撤销amend:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BEsocket%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">23.</span> <span class="toc-text">找socket对应的文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lightdm%E5%88%B0startdde%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">24.</span> <span class="toc-text">lightdm到startdde的整个流程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="toc-number">25.</span> <span class="toc-text">打印枚举值：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91kwin%E9%81%87%E5%88%B0%E5%A6%82%E4%B8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">26.</span> <span class="toc-text">编译kwin遇到如下问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gdb-set-substitute-path%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95"><span class="toc-number">27.</span> <span class="toc-text">gdb set
substitute-path命令用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%A0%E4%BA%86%E5%93%AA%E4%B8%AA%E7%A3%81%E7%9B%98%E7%9A%84-%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%8F%8A%E7%A3%81%E7%9B%98%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4"><span class="toc-number">28.</span> <span class="toc-text">查看一个文件夹占了哪个磁盘的
空间以及磁盘所占空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E6%96%87%E4%BB%B6%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E5%8F%AA%E7%AE%97%E4%B8%80%E5%B1%82"><span class="toc-number">29.</span> <span class="toc-text">查看一个文件夹下各文件所占空间大小，只算一层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bjournal%E6%9F%90%E6%AC%A1%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">30.</span> <span class="toc-text">查看journal某次启动的日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFdbus%E6%97%A5%E5%BF%97"><span class="toc-number">31.</span> <span class="toc-text">开启dbus日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8bpftrace%E8%B7%9F%E8%B8%AAioctl%E8%B0%83%E7%94%A8"><span class="toc-number">32.</span> <span class="toc-text">如何用BPFtrace跟踪ioctl调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tracepointsyscallssys_enter_ioctl%E8%BF%99%E4%B8%AAtracepoint%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">33.</span> <span class="toc-text">tracepoint:syscalls:sys_enter_ioctl这个tracepoint是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pkexec%E6%8F%90%E6%9D%83"><span class="toc-number">34.</span> <span class="toc-text">pkexec提权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%80%E5%87%BA"><span class="toc-number">35.</span> <span class="toc-text">查看某个服务为什么退出：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96usb%E8%AE%BE%E5%A4%87%E7%9A%84idvendor%E5%92%8Cidproduct%E4%BF%A1%E6%81%AF%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">36.</span> <span class="toc-text">获取USB设备的idVendor和idProduct信息。以下是几种常用的方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">37.</span> <span class="toc-text">检查二进制程序是否存在内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%89%E8%A3%85%E5%99%A8%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">38.</span> <span class="toc-text">查看安装器的日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8-selinux-%E7%9A%84%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">39.</span> <span class="toc-text">禁用 SELinux 的强制执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFwine%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97"><span class="toc-number">40.</span> <span class="toc-text">开启wine应用日志:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arecord%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91"><span class="toc-number">41.</span> <span class="toc-text">arecord录制音频：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pulseaudio%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BB%A5%E7%B3%BB%E7%BB%9F%E7%BA%A7%E8%BF%90%E8%A1%8C"><span class="toc-number">42.</span> <span class="toc-text">pulseaudio为什么不能以系统级运行：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i2c%E6%80%BB%E7%BA%BF"><span class="toc-number">43.</span> <span class="toc-text">i2c总线：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wget%E4%B8%8B%E8%BD%BD"><span class="toc-number">44.</span> <span class="toc-text">wget下载：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dsdt-%E8%A1%A8"><span class="toc-number">45.</span> <span class="toc-text">DSDT 表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-dsdt-%E8%A1%A8"><span class="toc-number">46.</span> <span class="toc-text">修改 DSDT 表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%E6%8A%84systemd%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">47.</span> <span class="toc-text">比较文件或路径是否相同（抄systemd的代码）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#grub%E8%8F%9C%E5%8D%95%E6%98%BE%E7%A4%BA%E9%A3%8E%E6%A0%BC%E9%97%AE%E9%A2%98"><span class="toc-number">48.</span> <span class="toc-text">213277 grub菜单显示风格问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%97%B6%E4%BD%BF%E7%94%A8lvm%E5%88%86%E5%8C%BA%E7%AC%AC%E4%BA%8C%E7%B3%BB%E7%BB%9F%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%BC%95%E5%AF%BC"><span class="toc-number">49.</span> <span class="toc-text">213181
安装时使用lvm分区第二系统无法正确引导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8E%E4%B8%BA%E9%80%82%E9%85%8Dgrub%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">50.</span> <span class="toc-text">华为适配grub相关问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd%E5%BC%95%E5%AF%BC%E9%98%B6%E6%AE%B5%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5"><span class="toc-number">51.</span> <span class="toc-text">systemd引导阶段出现问题的故障排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section"><span class="toc-number">52.</span> <span class="toc-text">200217</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locale-gen-%E5%91%BD%E4%BB%A4"><span class="toc-number">53.</span> <span class="toc-text">locale-gen 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9init%E8%BF%9B%E7%A8%8B"><span class="toc-number">54.</span> <span class="toc-text">修改init进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemd%E7%9A%84inhibit%E6%9C%BA%E5%88%B6"><span class="toc-number">55.</span> <span class="toc-text">systemd的inhibit机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E4%B8%8Blightdm%E8%8E%B7%E5%8F%96%E7%BB%99%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">56.</span> <span class="toc-text">学习下lightdm获取给自己发送信号进程的机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD%E5%AE%89%E5%85%A8%E7%AE%A1%E6%8E%A7"><span class="toc-number">57.</span> <span class="toc-text">开启和关闭安全管控：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%81%E8%AE%B8%E4%BB%BB%E6%84%8F%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85"><span class="toc-number">58.</span> <span class="toc-text">设置允许任意应用安装：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">59.</span> <span class="toc-text">kill进程可以这么写函数：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/crop_classification/Climate-adaptiveemergencycropmonitoringin1inaccessibleregionswithsatelliteimagery/" title="Climate-adaptive emergency crop monitoring in inaccessible regions with satellite imagery">Climate-adaptive emergency crop monitoring in inaccessible regions with satellite imagery</a><time datetime="2024-08-21T13:10:08.777Z" title="Created 2024-08-21 21:10:08">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/%E8%B5%84%E6%96%99/git/" title="git">git</a><time datetime="2024-08-14T06:43:06.646Z" title="Created 2024-08-14 14:43:06">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/%E8%B5%84%E6%96%99/Docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Docker快速入门">Docker快速入门</a><time datetime="2024-08-14T03:51:21.076Z" title="Created 2024-08-14 11:51:21">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/%E8%B5%84%E6%96%99/markdown/" title="Markdown 特殊符号及数学公式整理">Markdown 特殊符号及数学公式整理</a><time datetime="2024-08-14T03:47:51.740Z" title="Created 2024-08-14 11:47:51">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/%E8%B5%84%E6%96%99/k8s/" title="k8s">k8s</a><time datetime="2024-08-14T03:43:57.520Z" title="Created 2024-08-14 11:43:57">2024-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ALTNT</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>