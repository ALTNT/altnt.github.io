<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>vscode插件开发 | ALTNT's Hexo Blog</title><meta name="author" content="ALTNT"><meta name="copyright" content="ALTNT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="参考开发文档:https:&#x2F;&#x2F;liiked.github.io&#x2F;VS-Code-Extension-Doc-ZH&#x2F;#&#x2F; TypeScript和VS Code TypeScript起初是微软开发的以JavaScript为基础的编程语言，他兼容JavaScript的所有特性，并扩展了JS的类型系统，使得用户在大型系统开发中更加游刃有余，VS Code天然支持TypeScript，帮助开发者写出更加稳定">
<meta property="og:type" content="article">
<meta property="og:title" content="vscode插件开发">
<meta property="og:url" content="http://blog.705553939.xyz/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="ALTNT&#39;s Hexo Blog">
<meta property="og:description" content="参考开发文档:https:&#x2F;&#x2F;liiked.github.io&#x2F;VS-Code-Extension-Doc-ZH&#x2F;#&#x2F; TypeScript和VS Code TypeScript起初是微软开发的以JavaScript为基础的编程语言，他兼容JavaScript的所有特性，并扩展了JS的类型系统，使得用户在大型系统开发中更加游刃有余，VS Code天然支持TypeScript，帮助开发者写出更加稳定">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://blog.705553939.xyz/img/altnt.jpeg">
<meta property="article:published_time" content="2024-06-28T06:47:30.251Z">
<meta property="article:modified_time" content="2024-06-28T07:28:05.615Z">
<meta property="article:author" content="ALTNT">
<meta property="article:tag" content="vscode插件开发, javascript, TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.705553939.xyz/img/altnt.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.705553939.xyz/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vscode插件开发',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-28 15:28:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/altnt.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ALTNT's Hexo Blog"><span class="site-name">ALTNT's Hexo Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vscode插件开发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-28T06:47:30.251Z" title="Created 2024-06-28 14:47:30">2024-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-28T07:28:05.615Z" title="Updated 2024-06-28 15:28:05">2024-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vscode插件开发"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>参考开发文档:<br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://liiked.github.io/VS-Code-Extension-Doc-ZH/%23/">https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/</a></p>
<h2 id="TypeScript和VS-Code"><a href="#TypeScript和VS-Code" class="headerlink" title="TypeScript和VS Code"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/first-step?id=typescript%e5%92%8cvs-code">TypeScript和VS Code</a></h2><hr>
<p>TypeScript起初是微软开发的以JavaScript为基础的编程语言，他兼容JavaScript的所有特性，并扩展了JS的类型系统，使得用户在大型系统开发中更加游刃有余，VS Code天然支持TypeScript，帮助开发者写出更加稳定、安全的代码。因此所有文档的示例，包括插件本身，绝大部分都是使用TypeScript开发的，俗话说“不积跬步无以至千里”，当你足够了插件的基础之后，阅读文档才会更加顺利。</p>
<p>由于VS Code已经禁用了CSS和HTML，因此本章不会介绍这些内容，有兴趣的读者可参阅<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web">MDN文档</a></p>
<h1 id="认识TypeScript-变量和类型"><a href="#认识TypeScript-变量和类型" class="headerlink" title="认识TypeScript-变量和类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e8%ae%a4%e8%af%86typescript-%e5%8f%98%e9%87%8f%e5%92%8c%e7%b1%bb%e5%9e%8b">认识TypeScript-变量和类型</a></h1><p>本节将介绍基础的TypeScript变量以及它的类型系统，它本质上和JavaScript是一样的，不过东西会更多一点，对于非js开发者来说，你可能会遇到熟悉的“枚举”、“元组”类型，了解了这点，或许能让你安心并更快地掌握TS，但是这并不意味着你就可以高枕无忧了，虽然TS扩展了JS的类型能力，但它本质上依旧是一门弱类型语言，请在书写代码时遵循社区的最佳实践并保持谨慎。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e7%b1%bb%e5%9e%8b">类型</a></h2><hr>
<p>变量声明的基础规则请自行参考JavaScript，JavaScript支持加分号和不加分号两种风格，方便起见，本章的所有示例代码都不会刻意添加分号，有关分号风格，请参阅<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics#%E5%8F%98%E9%87%8F%EF%BC%88variable%EF%BC%89">MDN</a>。</p>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e7%b1%bb%e5%9e%8b%e6%b3%a8%e8%a7%a3">类型注解</a></h3><p>TS扩展了JS的语法格式，规则：在变量、声明的后面立即加上冒号 <code>:</code>，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 字符串注解</span><br><span class="line">const XXX: string = &#x27;string type&#x27;</span><br><span class="line">// 布尔值注解</span><br><span class="line">let true_or_false: boolean = false</span><br><span class="line">// 函数参数类型注解</span><br><span class="line">function params (value: string) &#123;</span><br><span class="line">    console.log(value) // 返回string类型</span><br><span class="line">&#125;</span><br><span class="line">// 函数返回值类型注解</span><br><span class="line">function returnValue (): string &#123;</span><br><span class="line">    return &#x27;value is stirng&#x27;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>请注意，类型注释应使用小写，而不是使用首字母大写的JavaScript的衍生类型（应使用 <code>string</code>，而不是 <code>String</code>）</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%b8%83%e5%b0%94%e5%80%bc">布尔值</a></h4><p>最基本的数据类型就是简单的true&#x2F;false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e6%95%b0%e5%ad%97">数字</a></h4><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。非JS开发者需要注意的是，TS和JS一样，没有区分数字类型（如Int，Long），如果你需要整数，需使用 <code>Number.parseInt()</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">let octalLiteral: number = 0o744;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%ad%97%e7%ac%a6%e4%b8%b2">字符串</a></h4><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name: string = &quot;bob&quot;;</span><br><span class="line">name = &quot;smith&quot;;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>），并且以</code>${ expr }&#96;这种形式嵌入表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name: string = `Gene`;</span><br><span class="line">let age: number = 37;</span><br><span class="line">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class="line">I&#x27;ll be $&#123; age + 1 &#125; years old next month.`;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这与下面定义 <code>sentence</code>的方式效果相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sentence: string = &quot;Hello, my name is &quot; + name + &quot;.\n\t&quot; +</span><br><span class="line">    &quot;I&#x27;ll be &quot; + (age + 1) + &quot; years old next month.&quot;;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e6%95%b0%e7%bb%84">数组</a></h4><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: Array&lt;number&gt; = [1, 2, 3];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%85%83%e7%bb%84-tuple">元组 Tuple</a></h4><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个元组</span><br><span class="line">let x: [string, number];</span><br><span class="line">// 将其初始化</span><br><span class="line">x = [&#x27;hello&#x27;, 10]; // OK</span><br><span class="line">// 将其错误地初始化</span><br><span class="line">x = [10, &#x27;hello&#x27;]; // Error</span><br><span class="line">当访问一个已知索引的元素，会得到正确的类型：</span><br><span class="line"></span><br><span class="line">console.log(x[0].substr(1)); // OK</span><br><span class="line">console.log(x[1].substr(1)); // Error, &#x27;number&#x27;类型没有&#x27;substr&#x27;方法复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e6%9e%9a%e4%b8%be">枚举</a></h4><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>或者，全部都采用手动赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</span><br><span class="line">let c: Color = Color.Green;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;</span><br><span class="line">let colorName: string = Color[2];</span><br><span class="line"></span><br><span class="line">console.log(colorName);  // 显示&#x27;Green&#x27;因为上面代码里它的值是2复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=any">Any</a></h4><p>有时候，我们会想要为那些在编写阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = &quot;maybe a string instead&quot;;</span><br><span class="line">notSure = false; // 合法, 定义了一个布尔值复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line"></span><br><span class="line">list[1] = 100;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=void">Void</a></h4><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=object">Object</a></h4><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<p>使用object类型，就可以更好的表示像 <code>Object.create</code>这样的API。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: 0 &#125;); // OK</span><br><span class="line">create(null); // OK</span><br><span class="line"></span><br><span class="line">create(42); // Error</span><br><span class="line">create(&quot;string&quot;); // Error</span><br><span class="line">create(false); // Error</span><br><span class="line">create(undefined); // Error复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript类型表"><a href="#TypeScript类型表" class="headerlink" title="TypeScript类型表"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=typescript%e7%b1%bb%e5%9e%8b%e8%a1%a8">TypeScript类型表</a></h2><hr>
<table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本类型</strong></td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td><code>x: boolean = false</code></td>
</tr>
<tr>
<td>number</td>
<td><code>x: number = 10</code></td>
</tr>
<tr>
<td>string</td>
<td><code>x: string = &#39;10&#39;</code></td>
</tr>
<tr>
<td>undefined</td>
<td><code>x: undefined = undefined</code></td>
</tr>
<tr>
<td>null</td>
<td><code>x: null = null</code></td>
</tr>
<tr>
<td><strong>引用类型以及其他类型</strong></td>
<td></td>
</tr>
<tr>
<td>object</td>
<td><code>x: object = &#123; age: &#39;14&#39;, name: &#39;John&#39; &#125;</code></td>
</tr>
<tr>
<td>array</td>
<td><code>x: array = [1, &#39;2&#39;, 3.0]</code></td>
</tr>
<tr>
<td>function</td>
<td><code>x: function = (args) =&gt; &#123; console.log(args) &#125;</code></td>
</tr>
<tr>
<td>symbol</td>
<td><code>x: symbol = Symbol(&#39;id&#39;)</code></td>
</tr>
<tr>
<td><strong>TypeScript 补充类型</strong></td>
<td></td>
</tr>
<tr>
<td>any</td>
<td><code>x: any = null</code></td>
</tr>
<tr>
<td>never</td>
<td><code>function error (msg): never =&gt; &#123; throw new Error(msg) &#125;</code></td>
</tr>
<tr>
<td>enum</td>
<td><code>enum Color &#123;Red = 1, Green, Blue&#125;</code></td>
</tr>
<tr>
<td>tuple</td>
<td><code>x: [string, number] = [&#39;name&#39;, 12]</code></td>
</tr>
</tbody></table>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80">类型断言</a></h2><hr>
<p>有时候你会遇到这样的情况，你比TypeScript更了解某个值的具体信息。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。TypeScript会假设你——程序员——已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>另一个为as语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意：本章全部采用了let，const关键字，以及你接下来可以见到的所有例子中，都不再使用var声明变量，为了避免var带来的副作用和影响，我们更提倡使用新的关键字。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e">变量声明</a></h2><hr>
<h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=let%e5%a3%b0%e6%98%8e">let声明</a></h3><p>由于本章侧重于帮助读者流畅地阅读文档中出现的TS代码，因此本节不再赘述var和新关键字之间的区别，读者如有兴趣可自行参考<a target="_blank" rel="noopener" href="https://www.tslang.cn/">TypeScript文档</a>。</p>
<p>let的声明格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let hello = &quot;Hello!&quot;;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f">块作用域</a></h5><p>当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f(input: boolean) &#123;</span><br><span class="line">    let a = 100;</span><br><span class="line"></span><br><span class="line">    if (input) &#123;</span><br><span class="line">        // 你在这里还可以访问到a</span><br><span class="line">        let b = a + 1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 错误: &#x27;b&#x27;不存在</span><br><span class="line">    return b;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这里我们定义了2个变量 <code>a</code>和 <code>b</code>。 <code>a</code>的作用域在 <code>f</code>函数体内，而 <code>b</code>的作用域只在 <code>if</code>语句块里。</p>
<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于  <em>暂时性死区</em> 。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++; // illegal to use &#x27;a&#x27; before it&#x27;s declared;</span><br><span class="line">let a;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，运行时会抛出一个错误；然而，目前TypeScript是不会报错的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    // okay to capture &#x27;a&#x27;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span><br><span class="line">// 运行时会抛出错误</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">let a;</span><br><span class="line">复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e9%87%8d%e5%ae%9a%e4%b9%89%e5%8f%8a%e5%b1%8f%e8%94%bd">重定义及屏蔽</a></h4><p>你不可以重复定义同一个变量，在使用 <code>var</code>时，这是被允许的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = 10;</span><br><span class="line">let x = 20; // 错误，不能在1个作用域里多次声明`x`复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>以下情况，TypeScript均会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(x) &#123;</span><br><span class="line">    let x = 100; // error: interferes with parameter declaration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function g() &#123;</span><br><span class="line">    let x = 100;</span><br><span class="line">    var x = 100; // error: can&#x27;t have both declarations of &#x27;x&#x27;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意函数作用域和块作用域不同，你可以在函数作用域里嵌套块作用域，作用域之间的变量声明互不影响，同时，块作用域是允许嵌套的。</p>
<p>在一个嵌套作用域里引入一个新名字的行为称做 <strong>屏蔽</strong> 。 它是一把双刃剑，它可能会不小心地引入新问题，还可能会遮蔽掉一些错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f(condition, x) &#123;</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        let x = 100;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(false, 0); // returns 0</span><br><span class="line">f(true, 0);  // returns 100复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=const%e5%a3%b0%e6%98%8e">const声明</a></h3><p><code>const</code>声明是声明变量的另一种方式。它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p>
<p>这很好理解，它们引用的值是不可变的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const numLivesForCat = 9;</span><br><span class="line">const kitty = &#123;</span><br><span class="line">    name: &quot;Aurora&quot;,</span><br><span class="line">    numLives: numLivesForCat,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Error</span><br><span class="line">kitty = &#123;</span><br><span class="line">    name: &quot;Danielle&quot;,</span><br><span class="line">    numLives: numLivesForCat</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// all &quot;okay&quot;</span><br><span class="line">kitty.name = &quot;Rory&quot;;</span><br><span class="line">kitty.name = &quot;Kitty&quot;;</span><br><span class="line">kitty.name = &quot;Cat&quot;;</span><br><span class="line">kitty.numLives--;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。</p>
<h2 id="访问-设置对象的属性和方法"><a href="#访问-设置对象的属性和方法" class="headerlink" title="访问&#x2F;设置对象的属性和方法"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e8%ae%bf%e9%97%ae%e8%ae%be%e7%bd%ae%e5%af%b9%e8%b1%a1%e7%9a%84%e5%b1%9e%e6%80%a7%e5%92%8c%e6%96%b9%e6%b3%95">访问&#x2F;设置对象的属性和方法</a></h2><hr>
<p>我们在前面已经看过很多对象的例子了，而且JavaScript的各种衍生类型都是基于Object构造出来的，所以本小节介绍的内容也同时适用数组、元组等数据类型。</p>
<h4 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e7%82%b9%e8%a1%a8%e7%a4%ba%e6%b3%95">点表示法</a></h4><p>对象的名字表现为一个命名空间(namespace)，它必须写在第一位——当你想访问对象内部的属性或方法时，然后是一个点 <code>.</code>，紧接着是你想要访问的项目，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.interests[1]</span><br><span class="line">person.bio()复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>创建一个对象在TypeScript中非常简单，在赋值语句右侧使用形如 <code>&#123;&#125;</code>的方式就能创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const name = &#123;</span><br><span class="line">  first : &#x27;Bob&#x27;,</span><br><span class="line">  last : &#x27;Smith&#x27;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>用点表示法访问对象属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name.first</span><br><span class="line">name.last复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="中括号表示法"><a href="#中括号表示法" class="headerlink" title="中括号表示法"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e4%b8%ad%e6%8b%ac%e5%8f%b7%e8%a1%a8%e7%a4%ba%e6%b3%95">中括号表示法</a></h4><p>另外一种访问属性的方式是使用括号表示法(bracket notation)，替代这样的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.name.first复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person[&#x27;age&#x27;]</span><br><span class="line">person[&#x27;name&#x27;][&#x27;first&#x27;]复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>同样，创建一个数组也非常容易</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const name = [&#x27;Bob&#x27;, &#x27;Smith&#x27;]复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>用中括号表示法访问数组元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name[0]</span><br><span class="line">name[1]</span><br><span class="line"></span><br><span class="line">// 数组或类数组格式的数据只能用括号表示法访问元素，不可以使用`name.0`方式访问复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="设置对象成员"><a href="#设置对象成员" class="headerlink" title="设置对象成员"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e8%ae%be%e7%bd%ae%e5%af%b9%e8%b1%a1%e6%88%90%e5%91%98">设置对象成员</a></h4><p>分别用点表示法和中括号表示法设置对象成员的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.age = 45</span><br><span class="line">person[&#x27;name&#x27;][&#x27;last&#x27;] = &#x27;Cratchit&#x27;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>设置成员并不意味着你只能更新已经存在的属性的值，你完全可以创建新的成员，尝试以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person[&#x27;eyes&#x27;] = &#x27;hazel&#x27;</span><br><span class="line">person.farewell = function() &#123; alert(&quot;Bye everybody!&quot;) &#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>现在你可以测试你新创建的成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person[&#x27;eyes&#x27;]</span><br><span class="line">person.farewell()复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h2 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%8f%98%e9%87%8f%e8%a7%a3%e6%9e%84">变量解构</a></h2><hr>
<p>ES2015的变量解构参照了名为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">模式匹配</a>的设计模式，本质来说是一种便利的语法糖</p>
<h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e8%a7%a3%e6%9e%84%e6%95%b0%e7%bb%84">解构数组</a></h3><p>最简单的解构莫过于数组的解构赋值了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let input = [1, 2];</span><br><span class="line">let [first, second] = input;</span><br><span class="line">console.log(first); // outputs 1</span><br><span class="line">console.log(second); // outputs 2复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>上面的例子等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = input[0];</span><br><span class="line">second = input[1];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>作用于函数参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f([first, second]: [number, number]) &#123; // 注意后面部分[number, number]是typescript的类型注解</span><br><span class="line">    console.log(first);</span><br><span class="line">    console.log(second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const input = [12, 44]</span><br><span class="line"></span><br><span class="line">f(input);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你可以在数组里使用 <code>...</code>语法创建剩余变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [first, ...rest] = [1, 2, 3, 4];</span><br><span class="line">console.log(first); // outputs 1</span><br><span class="line">console.log(rest); // outputs [ 2, 3, 4 ]复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [first] = [1, 2, 3, 4];</span><br><span class="line">console.log(first); // outputs 1复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>或其它元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [, second, , fourth] = [1, 2, 3, 4];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%af%b9%e8%b1%a1%e8%a7%a3%e6%9e%84">对象解构</a></h3><p>你也可以解构对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let o = &#123;</span><br><span class="line">    a: &quot;foo&quot;,</span><br><span class="line">    b: 12,</span><br><span class="line">    c: &quot;bar&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; a, b &#125; = o;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你可以在对象里使用 <code>...</code>语法创建剩余变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; a, ...passthrough &#125; = o;</span><br><span class="line">let total = passthrough.b + passthrough.c.length;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你也可以给属性以不同的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123; a: newName1, b: newName2 &#125; = o;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这里的语法开始有些混乱。 你可以将 <code>a: newName1</code> 读做讲 “a” 取出作为 “newName1”。 方向是从左到右，好像你写成了以下样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let newName1 = o.a;</span><br><span class="line">let newName2 = o.b;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>令你困惑的可能是&#x3D;这里的冒号不是指示类型的，我们前面说，以冒号后跟的是 <em>类型注解</em> 。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">let &#123;a, b&#125;: &#123;a: string, b: number&#125; = o;</span><br><span class="line">// 错误</span><br><span class="line">let &#123;a: n1, b: n2&#125;: &#123;n1: string, n2: number&#125; = o;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e9%bb%98%e8%ae%a4%e5%80%bc">默认值</a></h3><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class="line">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， keepWholeObject 函数的变量 <code>wholeObject</code> 的属性 a 和 b 都会有值。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e">函数声明</a></h3><p>解构也能用于函数声明。 看以下简单的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type C = &#123; a: string, b?: number &#125;</span><br><span class="line">// 普通写法</span><br><span class="line">function f(C) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// 解构</span><br><span class="line">function f(&#123; a, b &#125;: C): void &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="变量展开"><a href="#变量展开" class="headerlink" title="变量展开"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/variable-and-type?id=%e5%8f%98%e9%87%8f%e5%b1%95%e5%bc%80">变量展开</a></h3><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let first = [1, 2];</span><br><span class="line">let second = [3, 4];</span><br><span class="line">let bothPlus = [0, ...first, ...second, 5];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这会令bothPlus的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 first和second的一份 <strong>浅拷贝</strong> 。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;</span><br><span class="line">let search = &#123; ...defaults, food: &quot;rich&quot; &#125;;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>search的值为 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在 <strong>展开对象后面的属性会覆盖前面的属性</strong> 。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;</span><br><span class="line">let search = &#123; food: &quot;rich&quot;, ...defaults &#125;;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>那么，defaults里的food属性会重写 <code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=%e7%b1%bb">类</a></h1><p>传统的JavaScript程序使用<strong>函数</strong>和基于<strong>原型</strong>的继承来创建可重用的组件。Typescript则在此基础上加入了语法糖 <strong>类</strong> 。</p>
<p>了解Javascript的基础内容请参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">对象原型</a>。</p>
<h2 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=%e5%a3%b0%e6%98%8e%e7%b1%bb">声明类</a></h2><p>我们首先来看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    constructor(message: string) &#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return &quot;Hello, &quot; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter = new Greeter(&quot;world&quot;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=%e7%bb%a7%e6%89%bf">继承</a></h2><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    move(distance: number = 0) &#123;</span><br><span class="line">        console.log(`Animal moved $&#123;distance&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        console.log(&#x27;Woof! Woof!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。这里，<code>Dog</code>是一个  <em>派生类</em> ，通过 <code>extends</code>关键字使它从 <code>Animal</code> 基类中派生出来。 派生类通常被称作 子类，基类通常被称作 超类或父类。</p>
<p>因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</p>
<p>下面我们来看个更加复杂的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line"></span><br><span class="line">    move(distance: number = 0) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;m.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line"></span><br><span class="line">    move(distance = 5) &#123;</span><br><span class="line">        console.log(&quot;Slithering...&quot;);</span><br><span class="line">        super.move(distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123; super(name); &#125;</span><br><span class="line"></span><br><span class="line">    move(distance = 45) &#123;</span><br><span class="line">        console.log(&quot;Galloping...&quot;);</span><br><span class="line">        super.move(distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam = new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>与前一个例子的不同点是，这次两个派生类包含了一个构造函数，它 <strong>必须调用 <code>super()</code></strong> ，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 <strong>必须</strong>要调用 super()，这个是TypeScript强制规定的。</p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=%e4%bf%ae%e9%a5%b0%e7%ac%a6">修饰符</a></h2><h4 id="public"><a href="#public" class="headerlink" title="public"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=public">public</a></h4><p>如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code>来做修饰；例如，C#要求必须明确地使用 <code>public</code>指定成员是可见的。 在TypeScript里，成员都默认为 <code>public</code>。在上面的例子里，我们可以自由的访问程序里定义的成员。</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=private">private</a></h4><p>当成员被标记成 <code>private</code>时，它就不能在声明它的类的外部访问。比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Animal(&quot;Cat&quot;).name; // 错误: &#x27;name&#x27; 是私有的.复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=protected">protected</a></h4><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(name: string) &#123; this.name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person &#123;</span><br><span class="line">    private department: string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, department: string) &#123;</span><br><span class="line">        super(name)</span><br><span class="line">        this.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public getElevatorPitch() &#123;</span><br><span class="line">        return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);</span><br><span class="line">console.log(howard.getElevatorPitch());</span><br><span class="line">console.log(howard.name); // 错误复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意，我们不能在 <code>Person</code>类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code>类的<strong>实例方法</strong>访问，因为 <code>Employee</code>是由 <code>Person</code>派生而来的。</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=readonly">readonly</a></h4><p>你可以使用 <code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Octopus &#123;</span><br><span class="line">    readonly name: string;</span><br><span class="line">    readonly numberOfLegs: number = 8;</span><br><span class="line">    constructor (theName: string) &#123;</span><br><span class="line">        this.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);</span><br><span class="line">dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的.复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="get-set"><a href="#get-set" class="headerlink" title="get&#x2F;set"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=getset">get&#x2F;set</a></h4><p>TypeScript支持通过 <code>getters/setters</code>来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 <code>get</code>和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Employee &#123;</span><br><span class="line">    fullName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let employee = new Employee();</span><br><span class="line">employee.fullName = &quot;Bob Smith&quot;;</span><br><span class="line">if (employee.fullName) &#123;</span><br><span class="line">    console.log(employee.fullName);</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 <code>fullName</code>的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let passcode = &quot;secret passcode&quot;;</span><br><span class="line"></span><br><span class="line">class Employee &#123;</span><br><span class="line">    private _fullName: string;</span><br><span class="line"></span><br><span class="line">    get fullName(): string &#123;</span><br><span class="line">        return this._fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set fullName(newName: string) &#123;</span><br><span class="line">        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) &#123;</span><br><span class="line">            this._fullName = newName;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            console.log(&quot;Error: Unauthorized update of employee!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let employee = new Employee();</span><br><span class="line">employee.fullName = &quot;Bob Smith&quot;;</span><br><span class="line">if (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName);</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="static"><a href="#static" class="headerlink" title="static"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=static">static</a></h4><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Router &#123;</span><br><span class="line">    static baseRoute = &#x27;/basePath&#x27;;</span><br><span class="line">    calculateRoute(path: string) &#123;</span><br><span class="line">        return Router.baseRoute + this.commonPrefix  + path;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor (public commonPrefix: string) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let route1 = new Router(&#x27;/api&#x27;);  // 一级路径为/api</span><br><span class="line">let route2 = new Router(&#x27;/page&#x27;);  // 一级路径为/page</span><br><span class="line"></span><br><span class="line">console.log(route1.calculateRoute(&#x27;/main&#x27;));  // 最终路径/basePath/api/main</span><br><span class="line">console.log(route2.calculateRoute(&#x27;/user&#x27;));  // 最终路径/basePath/page/user复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/class?id=abstract">abstract</a></h4><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(&#x27;roaming the earch...&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="认识TypeScript-类型接口和命名空间"><a href="#认识TypeScript-类型接口和命名空间" class="headerlink" title="认识TypeScript-类型接口和命名空间"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e8%ae%a4%e8%af%86typescript-%e7%b1%bb%e5%9e%8b%e6%8e%a5%e5%8f%a3%e5%92%8c%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4">认识TypeScript-类型接口和命名空间</a></h1><p>TypeScript的核心原则之一是对数据的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，<strong>接口</strong>的作用就是为这些类型命名和为你的代码或第三方代码定义 <strong>契约</strong> 。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e6%8e%a5%e5%8f%a3">接口</a></h2><hr>
<h3 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e6%8e%a5%e5%8f%a3%e5%88%9d%e6%8e%a2">接口初探</a></h3><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function printLabel(labelledObj: &#123; label: string &#125;) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123; size: 10, label: &quot;Size 10 Object&quot; &#125;;</span><br><span class="line">printLabel(myObj);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>类型检查器会检查 <code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为 <code>label</code>类型为 <code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个 <code>label</code>属性且类型为 <code>string</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">  console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myObj = &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;;</span><br><span class="line">printLabel(myObj);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为 <code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%8f%af%e9%80%89%e5%b1%9e%e6%80%a7">可选属性</a></h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123;</span><br><span class="line">  let newSquare = &#123;color: &quot;white&quot;, area: 100&#125;;</span><br><span class="line">  if (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  if (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  return newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;color: &quot;black&quot;&#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">  let newSquare = &#123;color: &quot;white&quot;, area: 100&#125;;</span><br><span class="line">  if (config.clor) &#123;</span><br><span class="line">    // Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span><br><span class="line">    newSquare.color = config.clor;</span><br><span class="line">  &#125;</span><br><span class="line">  if (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  return newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;color: &quot;black&quot;&#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>



<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%8f%aa%e8%af%bb%e5%b1%9e%e6%80%a7">只读属性</a></h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p1: Point = &#123; x: 10, y: 20 &#125;;</span><br><span class="line">p1.x = 5; // error!复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>TypeScript具有 <code>ReadonlyArray&lt;T&gt;</code>类型，它与 <code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a: number[] = [1, 2, 3, 4];</span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[0] = 12; // error!</span><br><span class="line">ro.push(5); // error!</span><br><span class="line">ro.length = 100; // error!</span><br><span class="line">a = ro; // error!复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro as number[];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h4 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=readonly-vs-const">readonly vs const</a></h4><p>最简单判断该用<strong>readonly</strong>还是<strong>const</strong>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e9%a2%9d%e5%a4%96%e7%9a%84%e5%b1%9e%e6%80%a7%e6%a3%80%e6%9f%a5">额外的属性检查</a></h3><p>我们在第一个例子里使用了接口，TypeScript让我们传入 <code>&#123; size: number; label: string; &#125;</code>到仅期望得到 <code>&#123; label: string; &#125;</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code>例子来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意传入 <code>createSquare</code>的参数拼写为 <code>colour</code>而不是 <code>color</code>。 在JavaScript里，这会导致静默失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在 <code>color</code>属性，而且额外的 <code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的 <code>color</code>和 <code>width</code>属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">    color?: string;</span><br><span class="line">    width?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>我们稍后会讲到索引签名，但在这我们要表示的是 <code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是 <code>color</code>和 <code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let squareOptions = &#123; colour: &quot;red&quot;, width: 100 &#125;;</span><br><span class="line">let mySquare = createSquare(squareOptions);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code>或 <code>colour</code>属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code>定义来体现出这一点。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b">函数类型</a></h3><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src: string, sub: string): boolean &#123;</span><br><span class="line">  let result = src.search(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>函数的参数会 <strong>逐个进行检查</strong> ，要求 <strong>对应位置上的参数类型是兼容的</strong> 。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code>接口中的定义不匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src, sub) &#123;</span><br><span class="line">    let result = src.search(sub);</span><br><span class="line">    return result &gt; -1;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>


<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%8f%af%e7%b4%a2%e5%bc%95%e7%9a%84%e7%b1%bb%e5%9e%8b">可索引的类型</a></h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code>或 <code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个  <em>索引签名</em> ，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray: StringArray;</span><br><span class="line">myArray = [&quot;Bob&quot;, &quot;Fred&quot;];</span><br><span class="line"></span><br><span class="line">let myStr: string = myArray[0];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>上面例子里，我们定义了 <code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code>去索引 <code>StringArray</code>时会得到 <code>string</code>类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成 <code>string</code>然后再去索引对象。 也就是说用 100（一个 <code>number</code>）去索引等同于使用”100”（一个 <code>string</code>）去索引，因此两者需要保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">    [x: number]: Animal;</span><br><span class="line">    [x: string]: Dog;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和 <code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface NumberDictionary &#123;</span><br><span class="line">  [index: string]: number;</span><br><span class="line">  length: number;    // 可以，length是number类型</span><br><span class="line">  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface ReadonlyStringArray &#123;</span><br><span class="line">    readonly [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];</span><br><span class="line">myArray[2] = &quot;Mallory&quot;; // error!复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你不能设置 <code>myArray[2]</code>，因为索引签名是只读的。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e7%b1%bb%e7%b1%bb%e5%9e%8b">类类型</a></h3><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确或强制一个类去符合某种契约。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code>方法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date) &#123;</span><br><span class="line">        this.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类的静态部分和实例部分"><a href="#类的静态部分和实例部分" class="headerlink" title="类的静态部分和实例部分"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e7%b1%bb%e7%9a%84%e9%9d%99%e6%80%81%e9%83%a8%e5%88%86%e5%92%8c%e5%ae%9e%e4%be%8b%e9%83%a8%e5%88%86">类的静态部分和实例部分</a></h3><p>当你在类上面使用接口时，你需要注意一个<strong>类</strong>是由两部分构成的：类的静态部分和实例部分。如果你的接口上面声明了构造器签名，然后将这个接口应用在类上，你会看到报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">    new (hour: number, minute: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockConstructor &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这是因为一个类实现某个接口时，接口只检查<strong>类</strong>的实例部分，而 <code>constructor</code>构造器方法是类的静态部分，因此它不包含在类型检查之内。</p>
<p>所以，我们其实只要直接操作类的静态部分就可以了。在下述例子中，我们定义2个接口，一个 <code>ClockConstructor</code>给构造器使用，一个 <code>ClockInterface</code>供实例方法使用。方便起见，我们再定义一个构造器函数 <code>createClock</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">    new (hour: number, minute: number): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">    tick(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;</span><br><span class="line">    return new ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DigitalClock implements ClockInterface &#123;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        console.log(&quot;beep beep&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AnalogClock implements ClockInterface &#123;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        console.log(&quot;tick tock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>因为 <code>createClock</code>的第一个参数是 <code>ClockConstructor</code>类型，在 <code>createClock(AnalogClock, 7, 32)</code>里，会检查 <code>AnalogClock</code>是否符合构造函数签名。</p>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf">接口继承</a></h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">    penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br><span class="line">square.penWidth = 5.0;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e6%b7%b7%e5%90%88%e7%b1%bb%e5%9e%8b">混合类型</a></h3><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string;</span><br><span class="line">    interval: number;</span><br><span class="line">    reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">    let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class="line">    counter.interval = 123;</span><br><span class="line">    counter.reset = function () &#123; &#125;;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4">命名空间</a></h2><hr>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e7%ac%ac%e4%b8%80%e6%ad%a5">第一步</a></h3><p>我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>
<p>所有的验证器都放在一个文件里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface StringValidator &#123;</span><br><span class="line">    isAcceptable(s: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lettersRegexp = /^[A-Za-z]+$/;</span><br><span class="line">let numberRegexp = /^[0-9]+$/;</span><br><span class="line"></span><br><span class="line">class LettersOnlyValidator implements StringValidator &#123;</span><br><span class="line">    isAcceptable(s: string) &#123;</span><br><span class="line">        return lettersRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ZipCodeValidator implements StringValidator &#123;</span><br><span class="line">    isAcceptable(s: string) &#123;</span><br><span class="line">        return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个使用例子</span><br><span class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</span><br><span class="line"></span><br><span class="line">// 可以使用的校验器</span><br><span class="line">let validators: &#123; [s: string]: StringValidator; &#125; = &#123;&#125;;</span><br><span class="line">validators[&quot;ZIP code&quot;] = new ZipCodeValidator();</span><br><span class="line">validators[&quot;Letters only&quot;] = new LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line">// 每个strings是否都能找到对应的校验器</span><br><span class="line">for (let s of strings) &#123;</span><br><span class="line">    for (let name in validators) &#123;</span><br><span class="line">        let isMatch = validators[name].isAcceptable(s);</span><br><span class="line">        console.log(`&#x27;$&#123; s &#125;&#x27; $&#123; isMatch ? &quot;matches&quot; : &quot;does not match&quot; &#125; &#x27;$&#123; name &#125;&#x27;.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4-1">命名空间</a></h3><p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。</p>
<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做 <code>Validation</code>的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 <code>export</code>。 相反的，变量 <code>lettersRegexp</code>和 <code>numberRegexp</code>是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p>
<p>使用命名空间的验证器:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">namespace Validation &#123;</span><br><span class="line">    export interface StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string): boolean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const lettersRegexp = /^[A-Za-z]+$/;</span><br><span class="line">    const numberRegexp = /^[0-9]+$/;</span><br><span class="line"></span><br><span class="line">    export class LettersOnlyValidator implements StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string) &#123;</span><br><span class="line">            return lettersRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    export class ZipCodeValidator implements StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string) &#123;</span><br><span class="line">            return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一个例子</span><br><span class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</span><br><span class="line"></span><br><span class="line">let validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class="line">validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();</span><br><span class="line">validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line">for (let s of strings) &#123;</span><br><span class="line">    for (let name in validators) &#123;</span><br><span class="line">        console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125;$&#123; name &#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="分离文件"><a href="#分离文件" class="headerlink" title="分离文件"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/interface-and-namespace?id=%e5%88%86%e7%a6%bb%e6%96%87%e4%bb%b6">分离文件</a></h3><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p>
<p>现在，我们把 <code>Validation</code>命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。</p>
<p><code>Validation.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace Validation &#123;</span><br><span class="line">    export interface StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string): boolean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><code>LettersOnlyValidator.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class="line">namespace Validation &#123;</span><br><span class="line">    const lettersRegexp = /^[A-Za-z]+$/;</span><br><span class="line">    export class LettersOnlyValidator implements StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string) &#123;</span><br><span class="line">            return lettersRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><code>ZipCodeValidator.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class="line">namespace Validation &#123;</span><br><span class="line">    const numberRegexp = /^[0-9]+$/;</span><br><span class="line">    export class ZipCodeValidator implements StringValidator &#123;</span><br><span class="line">        isAcceptable(s: string) &#123;</span><br><span class="line">            return s.length === 5 &amp;&amp; numberRegexp.test(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><code>Test.ts</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// Some samples to try</span><br><span class="line">let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];</span><br><span class="line"></span><br><span class="line">// Validators to use</span><br><span class="line">let validators: &#123; [s: string]: Validation.StringValidator; &#125; = &#123;&#125;;</span><br><span class="line">validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();</span><br><span class="line">validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();</span><br><span class="line"></span><br><span class="line">// Show whether each string passed each validator</span><br><span class="line">for (let s of strings) &#123;</span><br><span class="line">    for (let name in validators) &#123;</span><br><span class="line">        console.log(`&quot;$&#123; s &#125;&quot; - $&#123; validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; &#125;$&#123; name &#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</p>
<p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用–outFile标记：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sample.js Test.ts复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过 <code>&lt;script&gt;</code>标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class="line">&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class="line">&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br><span class="line">&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</span><br></pre></td></tr></table></figure>



<h1 id="认识Typescript-泛型"><a href="#认识Typescript-泛型" class="headerlink" title="认识Typescript-泛型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e8%ae%a4%e8%af%86typescript-%e6%b3%9b%e5%9e%8b">认识Typescript-泛型</a></h1><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像C#和Java这样的语言中，可以使用<strong>泛型</strong>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<h2 id="泛型之Hello-World"><a href="#泛型之Hello-World" class="headerlink" title="泛型之Hello World"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e6%b3%9b%e5%9e%8b%e4%b9%8bhello-world">泛型之Hello World</a></h2><hr>
<p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code>命令。</p>
<p>不用泛型的话，这个函数可能是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity(arg: number): number &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>或者，我们使用any类型来定义函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity(arg: any): any &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>使用 <code>any</code>类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>
<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 <strong>类型变量</strong> ，它是一种特殊的变量， <em>只用于表示类型而不是值</em> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>我们给identity添加了类型变量 <code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>
<p>我们把这个版本的 <code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let output = identity&lt;string&gt;(&quot;myString&quot;);  // type of output will be &#x27;string&#x27;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这里我们明确的指定了 <code>T</code>是 <code>string</code>类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code>括起来而不是 <code>()</code>。</p>
<p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let output = identity(&quot;myString&quot;);  // type of output will be &#x27;string&#x27;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code>的值，然后把 <code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code>的类型，在一些复杂的情况下，这是可能出现的。</p>
<h2 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e4%bd%bf%e7%94%a8%e6%b3%9b%e5%9e%8b%e5%8f%98%e9%87%8f">使用泛型变量</a></h2><hr>
<p>使用泛型创建像 <code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>看下之前identity例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>如果我们想同时打印出arg的长度。 我们很可能会这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Error: T doesn&#x27;t have .length</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>如果这么做，编译器会报错说我们使用了 <code>arg</code>的 <code>.length</code>属性，但是没有地方指明 <code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code>属性的。</p>
<p>现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以 <code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123;</span><br><span class="line">    console.log(arg.length);  // Array has a .length, so no more error</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你可以这样理解 <code>loggingIdentity</code>的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code>和参数 <code>arg</code>，它是个元素类型是 <code>T</code>的数组，并返回元素类型是 <code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code>的的类型为number。 这可以让我们把泛型变量 <code>T</code>当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>
<p>我们也可以这样实现上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;</span><br><span class="line">    console.log(arg.length);  // Array has a .length, so no more error</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像 Array一样。</p>
<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e6%b3%9b%e5%9e%8b%e7%b1%bb%e5%9e%8b">泛型类型</a></h2><hr>
<p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>
<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myIdentity: GenericIdentityFn = identity;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myIdentity: GenericIdentityFn&lt;number&gt; = identity;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>
<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e6%b3%9b%e5%9e%8b%e7%b1%bb">泛型类</a></h2><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let stringNumeric = new GenericNumber&lt;string&gt;();</span><br><span class="line">stringNumeric.zeroValue = &quot;&quot;;</span><br><span class="line">stringNumeric.add = function(x, y) &#123; return x + y; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;));复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f">泛型约束</a></h2><hr>
<p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code>的 <code>length</code>属性，但是编译器并不能证明每种类型都有 <code>length</code>属性，所以就报错了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Error: T doesn&#x27;t have .length</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>相比于操作any所有类型，我们想要限制函数去处理任意带有 <code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p>
<p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和extends关键字来实现约束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Now we know it has a .length property, so no more error</span><br><span class="line">    return arg;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(3);  // Error, number doesn&#x27;t have a .length property复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: 10, value: 3&#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/generics?id=%e5%9c%a8%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0">在泛型约束中使用类型参数</a></h3><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getProperty(obj: T, key: K) &#123;</span><br><span class="line">    return obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, &quot;a&quot;); // okay</span><br><span class="line">getProperty(x, &quot;m&quot;); // error: Argument of type &#x27;m&#x27; isn&#x27;t assignable to &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;.</span><br></pre></td></tr></table></figure>


<h1 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%a3%b0%e6%98%8e%e6%96%87%e4%bb%b6">声明文件</a></h1><p>当你在使用VS Code编写TypeScript文件时，你不太可能在每个文件上都标明 <code>interface</code>字样的接口，一旦某个文件的方法或者变量比较多，你的代码可能就会被非常多的类型注解占据，在大型项目或者是你生成的库文件中为了保持代码的整洁，你就可能需要<strong>声明文件</strong>的帮助。</p>
<h2 id="创建一个声明文件"><a href="#创建一个声明文件" class="headerlink" title="创建一个声明文件"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%a3%b0%e6%98%8e%e6%96%87%e4%bb%b6">创建一个声明文件</a></h2><hr>
<p>声明文件以 <code>.d.ts</code>结尾，与TypeScript文件 <code>.ts</code>稍有区别。当你的项目目录中出现了 <code>.d.ts</code>结尾的文件时，所有与之关联的规则都会自动应用。声明文件支持我们前面介绍的各类语法，但是你得在语法前面加上 <code>declare</code>。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e4%be%8b%e5%ad%90">例子</a></h2><hr>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f">全局变量</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>全局变量foo包含了存在组件总数。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Half the number of widgets is &quot; + (foo / 2));复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>使用declare var声明变量。 如果变量是只读的，那么可以使用 declare const。 你还可以使用 declare let如果变量拥有块级作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** 组件总数 */</span><br><span class="line">declare var foo: number;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%85%a8%e5%b1%80%e5%87%bd%e6%95%b0">全局函数</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>用一个字符串参数调用greet函数向用户显示一条欢迎信息。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greet(&quot;hello, world&quot;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>使用declare function声明函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare function greet(greeting: string): void;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="带属性的对象"><a href="#带属性的对象" class="headerlink" title="带属性的对象"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%b8%a6%e5%b1%9e%e6%80%a7%e7%9a%84%e5%af%b9%e8%b1%a1">带属性的对象</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>全局变量myLib包含一个makeGreeting函数， 还有一个属性 numberOfGreetings指示目前为止欢迎数量。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let result = myLib.makeGreeting(&quot;hello, world&quot;);</span><br><span class="line">console.log(&quot;The computed greeting is:&quot; + result);</span><br><span class="line"></span><br><span class="line">let count = myLib.numberOfGreetings;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>使用declare namespace描述用点表示法访问的类型或值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare namespace myLib &#123;</span><br><span class="line">    function makeGreeting(s: string): string;</span><br><span class="line">    let numberOfGreetings: number;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd">函数重载</a></h3><p><strong>文档</strong></p>
<p>getWidget函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x: Widget = getWidget(43);</span><br><span class="line"></span><br><span class="line">let arr: Widget[] = getWidget(&quot;all of them&quot;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare function getWidget(n: number): Widget;</span><br><span class="line">declare function getWidget(s: string): Widget[];复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="可重用类型（接口）"><a href="#可重用类型（接口）" class="headerlink" title="可重用类型（接口）"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%8f%af%e9%87%8d%e7%94%a8%e7%b1%bb%e5%9e%8b%ef%bc%88%e6%8e%a5%e5%8f%a3%ef%bc%89">可重用类型（接口）</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>当指定一个欢迎词时，你必须传入一个GreetingSettings对象。 这个对象具有以下几个属性：</p>
<p>1- greeting：必需的字符串</p>
<p>2- duration: 可选的时长（毫秒表示）</p>
<p>3- color: 可选字符串，比如‘#ff00ff’</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet(&#123;</span><br><span class="line">  greeting: &quot;hello world&quot;,</span><br><span class="line">  duration: 4000</span><br><span class="line">&#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>使用interface定义一个带有属性的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface GreetingSettings &#123;</span><br><span class="line">  greeting: string;</span><br><span class="line">  duration?: number;</span><br><span class="line">  color?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare function greet(setting: GreetingSettings): void;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="可重用类型（类型别名）"><a href="#可重用类型（类型别名）" class="headerlink" title="可重用类型（类型别名）"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e5%8f%af%e9%87%8d%e7%94%a8%e7%b1%bb%e5%9e%8b%ef%bc%88%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d%ef%bc%89">可重用类型（类型别名）</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>在任何需要欢迎词的地方，你可以提供一个string，一个返回string的函数或一个Greeter实例。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting() &#123;</span><br><span class="line">    return &quot;howdy&quot;;</span><br><span class="line">&#125;</span><br><span class="line">class MyGreeter extends Greeter &#123; &#125;</span><br><span class="line"></span><br><span class="line">greet(&quot;hello&quot;);</span><br><span class="line">greet(getGreeting);</span><br><span class="line">greet(new MyGreeter());复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>你可以使用类型别名来定义类型的短名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type GreetingLike = string | (() =&gt; string) | MyGreeter;</span><br><span class="line"></span><br><span class="line">declare function greet(g: GreetingLike): void;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="组织类型"><a href="#组织类型" class="headerlink" title="组织类型"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e7%bb%84%e7%bb%87%e7%b1%bb%e5%9e%8b">组织类型</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>greeter对象能够记录到文件或显示一个警告。 你可以为 .log(…)提供LogOptions和为.alert(…)提供选项。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const g = new Greeter(&quot;Hello&quot;);</span><br><span class="line">g.log(&#123; verbose: true &#125;);</span><br><span class="line">g.alert(&#123; modal: false, title: &quot;Current Greeting&quot; &#125;);复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>使用命名空间组织类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">declare namespace GreetingLib &#123;</span><br><span class="line">    interface LogOptions &#123;</span><br><span class="line">        verbose?: boolean;</span><br><span class="line">    &#125;</span><br><span class="line">    interface AlertOptions &#123;</span><br><span class="line">        modal: boolean;</span><br><span class="line">        title?: string;</span><br><span class="line">        color?: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p>你也可以在一个声明中创建嵌套的命名空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare namespace GreetingLib.Options &#123;</span><br><span class="line">    // Refer to via GreetingLib.Options.Log</span><br><span class="line">    interface Log &#123;</span><br><span class="line">        verbose?: boolean;</span><br><span class="line">    &#125;</span><br><span class="line">    interface Alert &#123;</span><br><span class="line">        modal: boolean;</span><br><span class="line">        title?: string;</span><br><span class="line">        color?: string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a><a target="_blank" rel="noopener" href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/preknowledge/declaration-files?id=%e7%b1%bb">类</a></h3><p><strong>文档</strong></p>
<blockquote>
<p>你可以通过实例化Greeter对象来创建欢迎词，或者继承Greeter对象来自定义欢迎词。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const myGreeter = new Greeter(&quot;hello, world&quot;);</span><br><span class="line">myGreeter.greeting = &quot;howdy&quot;;</span><br><span class="line">myGreeter.showGreeting();</span><br><span class="line"></span><br><span class="line">class SpecialGreeter extends Greeter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super(&quot;Very special greetings&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制到剪贴板复制错误已复制</span><br></pre></td></tr></table></figure>

<p><strong>声明</strong></p>
<p>使用declare class描述一个类或像类一样的对象。 类可以有属性和方法，就和构造函数一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare class Greeter &#123;</span><br><span class="line">    constructor(greeting: string);</span><br><span class="line"></span><br><span class="line">    greeting: string;</span><br><span class="line">    showGreeting(): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>下面我们来看下项目的目录结构，如下图<img src="/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/1719559527174.png" alt="1719559527174"></p>
<p>首先我们来查看一下vsc-extension-quickstart.md这个文件，它对项目运行调试快捷键及重要文件作了介绍。<br>下面来看下这两个比较重要的文件：<br>package.json文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;template-plugin&quot;,   //插件名称</span><br><span class="line">	&quot;displayName&quot;: &quot;template-plugin&quot;,   //插件显示名称</span><br><span class="line">	&quot;description&quot;: &quot;&quot;,</span><br><span class="line">	&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">	&quot;engines&quot;: &#123;</span><br><span class="line">		&quot;vscode&quot;: &quot;^1.52.0&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;categories&quot;: [</span><br><span class="line">		&quot;Other&quot;</span><br><span class="line">	],</span><br><span class="line">	&quot;activationEvents&quot;: [   //插件的激活数组：即插件在什么情况下会被激活</span><br><span class="line">		&quot;onCommand:template-plugin.helloWorld&quot;</span><br><span class="line">	],</span><br><span class="line">	&quot;main&quot;: &quot;./extension.js&quot;,   //入口文件</span><br><span class="line">	&quot;contributes&quot;: &#123;</span><br><span class="line">		&quot;commands&quot;: [   //事件所对应的命令列表</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;command&quot;: &quot;template-plugin.helloWorld&quot;,</span><br><span class="line">				&quot;title&quot;: &quot;Hello World&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
</table>
<p>contributes配置项: 是整个插件的贡献点，也就是说这个插件有哪些功能。contributes字段可以设置的key也基本显示了vscode插件可以做什么。</p>
<p>configuration：通过这个配置项我们可以设置一个属性，这个属性可以在vscode的settings.json中设置，然后在插件工程中可以读取用户设置的这个值，进行相应的逻辑。</p>
<p>commands：命令，通过cmd+shift+p进行输入来实现的。<br>menus：通过这个选项我们可以设置右键的菜单<br>keybindings：可以设置快捷键<br>languages：设置语言特点，包括语言的后缀等<br>grammars：可以在这个配置项里设置描述语言的语法文件的路径，vscode可以根据这个语法文件来自动实现语法高亮功能<br>snippets：设置语法片段相关的路径</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://blog.705553939.xyz">ALTNT</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://blog.705553939.xyz/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">http://blog.705553939.xyz/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-javascript-TypeScript/">vscode插件开发, javascript, TypeScript</a></div><div class="post_share"><div class="social-share" data-image="/img/altnt.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/06/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5/" title="强化学习相关概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">强化学习相关概念</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/altnt.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ALTNT</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ALTNT"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%92%8CVS-Code"><span class="toc-number">1.</span> <span class="toc-text">TypeScript和VS Code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86TypeScript-%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">认识TypeScript-变量和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">1.1.1.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84-Tuple"><span class="toc-number">1.1.5.</span> <span class="toc-text">元组 Tuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.1.6.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Any"><span class="toc-number">1.1.7.</span> <span class="toc-text">Any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Void"><span class="toc-number">1.1.8.</span> <span class="toc-text">Void</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-number">1.1.9.</span> <span class="toc-text">Object</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E7%B1%BB%E5%9E%8B%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">TypeScript类型表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">4.</span> <span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#let%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">let声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">块作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%B1%8F%E8%94%BD"><span class="toc-number">4.1.1.</span> <span class="toc-text">重定义及屏蔽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%A3%B0%E6%98%8E"><span class="toc-number">4.2.</span> <span class="toc-text">const声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">访问&#x2F;设置对象的属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">5.0.1.</span> <span class="toc-text">点表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">5.0.2.</span> <span class="toc-text">中括号表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="toc-number">5.0.3.</span> <span class="toc-text">设置对象成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">变量解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.</span> <span class="toc-text">解构数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">对象解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">6.4.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%B1%95%E5%BC%80"><span class="toc-number">6.5.</span> <span class="toc-text">变量展开</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">声明类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-number">3.0.1.</span> <span class="toc-text">public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-number">3.0.2.</span> <span class="toc-text">private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-number">3.0.3.</span> <span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-number">3.0.4.</span> <span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-set"><span class="toc-number">3.0.5.</span> <span class="toc-text">get&#x2F;set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">3.0.6.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract"><span class="toc-number">3.0.7.</span> <span class="toc-text">abstract</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86TypeScript-%E7%B1%BB%E5%9E%8B%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">认识TypeScript-类型接口和命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2"><span class="toc-number">1.1.</span> <span class="toc-text">接口初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">只读属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly-vs-const"><span class="toc-number">1.3.1.</span> <span class="toc-text">readonly vs const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">1.4.</span> <span class="toc-text">额外的属性检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">可索引的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">类类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E9%83%A8%E5%88%86%E5%92%8C%E5%AE%9E%E4%BE%8B%E9%83%A8%E5%88%86"><span class="toc-number">1.8.</span> <span class="toc-text">类的静态部分和实例部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">1.9.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">混合类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-number">2.1.</span> <span class="toc-text">第一步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-1"><span class="toc-number">2.2.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">分离文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Typescript-%E6%B3%9B%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">认识Typescript-泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%B9%8BHello-World"><span class="toc-number">1.</span> <span class="toc-text">泛型之Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">使用泛型变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">泛型类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">5.</span> <span class="toc-text">泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">在泛型约束中使用类型参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">声明文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">创建一个声明文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">全局函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">带属性的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">可重用类型（接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">可重用类型（类型别名）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">组织类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-1"><span class="toc-number">2.8.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.9.</span> <span class="toc-text">目录结构</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/28/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" title="vscode插件开发">vscode插件开发</a><time datetime="2024-06-28T06:47:30.251Z" title="Created 2024-06-28 14:47:30">2024-06-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5/" title="强化学习相关概念">强化学习相关概念</a><time datetime="2024-06-28T04:03:18.846Z" title="Created 2024-06-28 12:03:18">2024-06-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="机器学习相关概念">机器学习相关概念</a><time datetime="2024-06-26T09:09:56.000Z" title="Created 2024-06-26 17:09:56">2024-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/22/%E8%B5%84%E6%96%99/%E5%91%BD%E4%BB%A4/" title="命令">命令</a><time datetime="2024-06-22T03:44:40.000Z" title="Created 2024-06-22 11:44:40">2024-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/" title="数据库系统概论笔记">数据库系统概论笔记</a><time datetime="2024-06-05T15:46:23.990Z" title="Created 2024-06-05 23:46:23">2024-06-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ALTNT</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>